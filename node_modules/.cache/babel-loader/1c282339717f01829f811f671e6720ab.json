{"ast":null,"code":"'use strict';\n\nconst logger = require('./logging')('kafka-node:ConsumerGroup');\n\nconst util = require('util');\n\nconst EventEmitter = require('events');\n\nconst KafkaClient = require('./kafkaClient');\n\nconst Offset = require('./offset');\n\nconst _ = require('lodash');\n\nconst async = require('async');\n\nconst validateConfig = require('./utils').validateConfig;\n\nconst ConsumerGroupRecovery = require('./consumerGroupRecovery');\n\nconst Heartbeat = require('./consumerGroupHeartbeat');\n\nconst createTopicPartitionList = require('./utils').createTopicPartitionList;\n\nconst errors = require('./errors');\n\nconst NestedError = require('nested-error-stacks');\n\nconst assert = require('assert');\n\nconst builtInProtocols = require('./assignment');\n\nconst LATEST_OFFSET = -1;\nconst EARLIEST_OFFSET = -2;\nconst ACCEPTED_FROM_OFFSET = {\n  latest: LATEST_OFFSET,\n  earliest: EARLIEST_OFFSET,\n  none: false\n};\nconst DEFAULTS = {\n  groupId: 'kafka-node-group',\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  // Fetch message config\n  fetchMaxWaitMs: 100,\n  paused: false,\n  maxNumSegments: 1000,\n  fetchMinBytes: 1,\n  fetchMaxBytes: 1024 * 1024,\n  maxTickMessages: 1000,\n  fromOffset: 'latest',\n  outOfRangeOffset: 'earliest',\n  sessionTimeout: 30000,\n  retries: 10,\n  retryFactor: 1.8,\n  retryMinTimeout: 1000,\n  commitOffsetsOnFirstJoin: true,\n  connectOnReady: true,\n  migrateHLC: false,\n  onRebalance: null,\n  topicPartitionCheckInterval: 30000,\n  protocol: ['roundrobin'],\n  encoding: 'utf8'\n};\n\nfunction ConsumerGroup(memberOptions, topics) {\n  EventEmitter.call(this);\n  const self = this;\n  this.options = _.defaults(memberOptions || {}, DEFAULTS);\n\n  if (!this.options.heartbeatInterval) {\n    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);\n  }\n\n  if (memberOptions.ssl === true) {\n    memberOptions.ssl = {};\n  }\n\n  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {\n    throw new Error(`fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(', ')}`);\n  }\n\n  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {\n    throw new Error(`outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(', ')}`);\n  }\n\n  memberOptions.clientId = memberOptions.id;\n  this.client = new KafkaClient(memberOptions);\n\n  if (_.isString(topics)) {\n    topics = [topics];\n  }\n\n  assert(Array.isArray(topics), 'Array of topics is required');\n  assert(topics.length, 'Array of topics shall not be empty');\n  this.topics = topics;\n  this.recovery = new ConsumerGroupRecovery(this);\n  this.setupProtocols(this.options.protocol);\n\n  if (this.options.connectOnReady && !this.options.migrateHLC) {\n    this.client.once('ready', this.connect.bind(this));\n  }\n\n  if (this.options.migrateHLC) {\n    throw new Error('This version of KafkaClient cannot be used to migrate from Zookeeper use older version of kafka-node instead');\n  }\n\n  this.client.on('error', function (err) {\n    logger.error('Error from %s', self.client.clientId, err);\n    self.emit('error', err);\n  });\n\n  const recoverFromBrokerChange = _.debounce(function () {\n    logger.debug('brokersChanged refreshing metadata');\n    self.client.refreshBrokerMetadata(function (error) {\n      if (error) {\n        self.emit('error', error);\n        return;\n      }\n\n      self.reconnectIfNeeded();\n    });\n  }, 200);\n\n  this.client.on('brokersChanged', function () {\n    self.pause();\n    recoverFromBrokerChange();\n  });\n  this.client.on('reconnect', function () {\n    setImmediate(function () {\n      self.reconnectIfNeeded();\n    });\n  });\n  this.on('offsetOutOfRange', topic => {\n    this.pause();\n\n    if (this.options.outOfRangeOffset === 'none') {\n      this.emit('error', new errors.InvalidConsumerOffsetError(`Offset out of range for topic \"${topic.topic}\" partition ${topic.partition}`));\n      return;\n    }\n\n    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];\n    this.getOffset().fetch([topic], (error, result) => {\n      if (error) {\n        this.emit('error', new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error));\n        return;\n      }\n\n      const offset = _.head(result[topic.topic][topic.partition]);\n\n      const oldOffset = _.find(this.topicPayloads, {\n        topic: topic.topic,\n        partition: topic.partition\n      }).offset;\n\n      logger.debug('replacing %s-%s stale offset of %d with %d', topic.topic, topic.partition, oldOffset, offset);\n      this.setOffset(topic.topic, topic.partition, offset);\n      this.resume();\n    });\n  });\n  this._pendingFetches = 0; // 'processingfetch' emits before we start processing new messages\n  // 'done' will be emit when all messages are done emitting\n\n  this.on('processingfetch', () => this._onFetchProcessing());\n  this.on('done', topics => this._onFetchDone(topics));\n\n  if (this.options.groupId) {\n    validateConfig('options.groupId', this.options.groupId);\n  }\n\n  this.isLeader = false;\n  this.coordinatorId = null;\n  this.generationId = null;\n  this.ready = false;\n  this.topicPayloads = [];\n  this.payloadMap = {};\n}\n\nutil.inherits(ConsumerGroup, EventEmitter);\n\nConsumerGroup.prototype.reconnectIfNeeded = function () {\n  logger.debug('trying to reconnect if needed');\n  this.paused = false;\n\n  if (!this.ready && !this.connecting) {\n    if (this.reconnectTimer) {\n      // brokers changed so bypass backoff retry and reconnect now\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    this.connect();\n  } else if (!this.connecting) {\n    this.fetch();\n  }\n};\n\nConsumerGroup.prototype.setupProtocols = function (protocols) {\n  if (!Array.isArray(protocols)) {\n    protocols = [protocols];\n  }\n\n  this.protocols = protocols.map(function (protocol) {\n    if (typeof protocol === 'string') {\n      if (!(protocol in builtInProtocols)) {\n        throw new Error('Unknown built in assignment protocol ' + protocol);\n      }\n\n      protocol = _.assign({}, builtInProtocols[protocol]);\n    } else {\n      checkProtocol(protocol);\n    }\n\n    protocol.subscription = this.topics;\n    return protocol;\n  }, this);\n};\n\nfunction checkProtocol(protocol) {\n  assert(protocol, 'protocol is null');\n  assert(protocol.assign, 'assign function is not defined in the protocol');\n  assert(protocol.name, 'name must be given to protocol');\n  assert(protocol.version >= 0, 'version must be >= 0');\n}\n\nConsumerGroup.prototype.setCoordinatorId = function (coordinatorId) {\n  this.client.coordinatorId = String(coordinatorId);\n};\n\nConsumerGroup.prototype.assignPartitions = function (protocol, groupMembers, callback) {\n  logger.debug('Assigning Partitions to members', groupMembers);\n  logger.debug('Using group protocol', protocol);\n  protocol = _.find(this.protocols, {\n    name: protocol\n  });\n\n  if (!protocol) {\n    callback(new Error('Unknown group protocol: ' + protocol));\n    return;\n  }\n\n  var self = this;\n\n  var topics = _(groupMembers).map('subscription').flatten().uniq().value();\n\n  async.waterfall([function (callback) {\n    logger.debug('loadingMetadata for topics:', topics);\n    self.client.loadMetadataForTopics(topics, callback);\n  }, function (metadataResponse, callback) {\n    var metadata = mapTopicToPartitions(metadataResponse[1].metadata);\n    self.topicPartitionLength = createTopicPartitionLength(metadata, _.difference(topics, Object.keys(metadata)));\n    logger.debug('mapTopicToPartitions', metadata);\n    protocol.assign(metadata, groupMembers, callback);\n  }], callback);\n};\n\nfunction createTopicPartitionLength(metadata, emptyTopics) {\n  const topicPartitionLength = {};\n\n  _.forOwn(metadata, function (value, key) {\n    topicPartitionLength[key] = value.length;\n  });\n\n  for (const topic of emptyTopics) {\n    if (topic in topicPartitionLength) {\n      throw new Error(`Topic ${topic} is not empty`);\n    }\n\n    topicPartitionLength[topic] = 0;\n  }\n\n  return topicPartitionLength;\n}\n\nConsumerGroup.prototype.scheduleTopicPartitionCheck = function () {\n  if (this.isLeader && !this.topicPartitionCheckTimer && !this.closed) {\n    logger.debug(`${this.client.clientId} is leader scheduled new topic/partition check`);\n    this.topicPartitionCheckTimer = setTimeout(() => {\n      this.topicPartitionCheckTimer = null;\n      if (this.closed) return;\n      logger.debug('checking for new topics and partitions');\n\n      this._checkTopicPartitionChange((error, changed) => {\n        if (error) {\n          this.scheduleTopicPartitionCheck();\n          return this.emit('error', new NestedError('topic/partition change check failed', error));\n        }\n\n        if (changed) {\n          logger.debug('Topic/Partitions has changed');\n          async.series([callback => this.options.autoCommit && this.generationId != null && this.memberId ? this.commit(true, callback) : callback(null), callback => this.leaveGroup(callback), callback => {\n            this.connect();\n            callback(null);\n          }]);\n        } else {\n          logger.debug('no new Topic/Partitions');\n          this.scheduleTopicPartitionCheck();\n        }\n      });\n    }, this.options.topicPartitionCheckInterval);\n  }\n};\n\nConsumerGroup.prototype._checkTopicPartitionChange = function (callback) {\n  this.client.loadMetadataForTopics(this.topics, (error, metadataResponse) => {\n    if (error) {\n      return callback(error);\n    }\n\n    const metadata = mapTopicToPartitions(metadataResponse[1].metadata);\n\n    const topicOrPartitionsChanged = _.some(this.topicPartitionLength, function (numberOfPartitions, topic) {\n      return numberOfPartitions !== _.get(metadata, `['${topic}'].length`, 0);\n    });\n\n    callback(null, topicOrPartitionsChanged);\n  });\n};\n\nfunction mapTopicToPartitions(metadata) {\n  return _.mapValues(metadata, Object.keys);\n}\n\nConsumerGroup.prototype.handleJoinGroup = function (joinGroupResponse, callback) {\n  logger.debug('joinGroupResponse %j from %s', joinGroupResponse, this.client.clientId);\n\n  if (!joinGroupResponse.memberId || !joinGroupResponse.generationId) {\n    callback(new Error('Invalid joinGroupResponse: ' + JSON.stringify(joinGroupResponse)));\n    return;\n  }\n\n  this.isLeader = joinGroupResponse.leaderId === joinGroupResponse.memberId;\n  this.generationId = joinGroupResponse.generationId;\n  this.memberId = joinGroupResponse.memberId;\n  var groupAssignment;\n\n  if (this.isLeader) {\n    // assign partitions\n    return this.assignPartitions(joinGroupResponse.groupProtocol, joinGroupResponse.members, callback);\n  }\n\n  callback(null, groupAssignment);\n};\n\nConsumerGroup.prototype.saveDefaultOffsets = function (topicPartitionList, callback) {\n  var self = this;\n\n  const offsetPayload = _(topicPartitionList).cloneDeep().map(tp => {\n    tp.time = ACCEPTED_FROM_OFFSET[this.options.fromOffset];\n    return tp;\n  });\n\n  self.getOffset().fetch(offsetPayload, function (error, result) {\n    if (error) {\n      return callback(error);\n    }\n\n    self.defaultOffsets = _.mapValues(result, function (partitionOffsets) {\n      return _.mapValues(partitionOffsets, _.head);\n    });\n    callback(null);\n  });\n};\n\nConsumerGroup.prototype.handleSyncGroup = function (syncGroupResponse, callback) {\n  logger.debug('SyncGroup Response');\n  var self = this;\n  var ownedTopics = Object.keys(syncGroupResponse.partitions);\n\n  if (ownedTopics.length) {\n    logger.debug('%s owns topics: ', self.client.clientId, syncGroupResponse.partitions);\n    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);\n    const useDefaultOffsets = (self.options.fromOffset in ACCEPTED_FROM_OFFSET);\n    let noOffset;\n    async.waterfall([function (callback) {\n      self.fetchOffset(syncGroupResponse.partitions, callback);\n    }, function (offsets, callback) {\n      logger.debug('%s fetchOffset Response: %j', self.client.clientId, offsets);\n      noOffset = topicPartitionList.some(function (tp) {\n        return offsets[tp.topic][tp.partition] === -1;\n      });\n\n      if (noOffset) {\n        logger.debug('No saved offsets');\n\n        if (self.options.fromOffset === 'none') {\n          return callback(new Error(`${self.client.clientId} owns topics and partitions which contains no saved offsets for group '${self.options.groupId}'`));\n        }\n\n        async.parallel([function (callback) {\n          if (useDefaultOffsets) {\n            return self.saveDefaultOffsets(topicPartitionList, callback);\n          }\n\n          callback(null);\n        }], function (error) {\n          if (error) {\n            return callback(error);\n          }\n\n          logger.debug('%s defaultOffset Response for %s: %j', self.client.clientId, self.options.fromOffset, self.defaultOffsets);\n          callback(null, offsets);\n        });\n      } else {\n        logger.debug('Has saved offsets');\n        callback(null, offsets);\n      }\n    }, function (offsets, callback) {\n      self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {\n        var offset = offsets[p.topic][p.partition];\n\n        if (offset === -1) {\n          // -1 means no offset was saved for this topic/partition combo\n          offset = useDefaultOffsets ? self.getDefaultOffset(p, 0) : 0;\n        }\n\n        p.offset = offset;\n        return p;\n      });\n      self.payloadMap = self.buildPayloadMap(self.topicPayloads);\n\n      if (noOffset && self.options.commitOffsetsOnFirstJoin) {\n        self.commit(true, err => {\n          callback(err, !err ? true : null);\n        });\n      } else {\n        callback(null, true);\n      }\n    }], callback);\n  } else {\n    self.topicPayloads = [];\n    self.payloadMap = {}; // no partitions assigned\n\n    callback(null, false);\n  }\n};\n\nConsumerGroup.prototype.getDefaultOffset = function (tp, defaultOffset) {\n  return _.get(this.defaultOffsets, [tp.topic, tp.partition], defaultOffset);\n};\n\nConsumerGroup.prototype.getOffset = function () {\n  if (this.offset) {\n    return this.offset;\n  }\n\n  this.offset = new Offset(this.client); // we can ignore this since we are already forwarding error event emitted from client\n\n  this.offset.on('error', _.noop);\n  return this.offset;\n};\n\nfunction emptyStrIfNull(value) {\n  return value == null ? '' : value;\n}\n\nConsumerGroup.prototype.connect = function () {\n  if (this.connecting) {\n    logger.warn('Connect ignored. Currently connecting.');\n    return;\n  }\n\n  if (this.closed) {\n    logger.warn('Connect ignored. Consumer closed.');\n    return;\n  }\n\n  logger.debug('Connecting %s', this.client.clientId);\n  var self = this;\n  this.connecting = true;\n  this.emit('rebalancing');\n  async.waterfall([function (callback) {\n    if (typeof self.options.onRebalance === 'function') {\n      self.options.onRebalance(self.generationId != null && self.memberId != null, function (error) {\n        if (error) {\n          return callback(error);\n        }\n\n        callback(null);\n      });\n      return;\n    }\n\n    callback(null);\n  }, function (callback) {\n    if (self.options.autoCommit && self.generationId != null && self.memberId) {\n      self.commit(true, function (error) {\n        if (error) {\n          return callback(error);\n        }\n\n        callback(null);\n      });\n      return;\n    }\n\n    callback(null);\n  }, function (callback) {\n    if (self.client.coordinatorId) {\n      return callback(null, null);\n    }\n\n    self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);\n  }, function (coordinatorInfo, callback) {\n    logger.debug('GroupCoordinator Response:', coordinatorInfo);\n\n    if (coordinatorInfo) {\n      self.setCoordinatorId(coordinatorInfo.coordinatorId);\n    }\n\n    self.client.sendJoinGroupRequest(self.options.groupId, emptyStrIfNull(self.memberId), self.options.sessionTimeout, self.protocols, callback);\n  }, function (joinGroupResponse, callback) {\n    self.handleJoinGroup(joinGroupResponse, callback);\n  }, function (groupAssignment, callback) {\n    logger.debug('SyncGroup Request from %s', self.memberId);\n    self.client.sendSyncGroupRequest(self.options.groupId, self.generationId, self.memberId, groupAssignment, callback);\n  }, function (syncGroupResponse, callback) {\n    self.handleSyncGroup(syncGroupResponse, callback);\n  }], function (error, startFetch) {\n    self.connecting = false;\n    self.rebalancing = false;\n\n    if (error) {\n      return self.recovery.tryToRecoverFrom(error, 'connect');\n    }\n\n    self.ready = true;\n    self.recovery.clearError();\n    logger.debug('generationId', self.generationId);\n    logger.debug('startFetch is', startFetch);\n\n    self._resetFetchState();\n\n    if (startFetch) {\n      self.clearPendingFetches();\n      self.fetch();\n    }\n\n    self.scheduleTopicPartitionCheck();\n    self.startHeartbeats();\n    self.emit('connect');\n    self.emit('rebalanced');\n  });\n};\n\nConsumerGroup.prototype.clearPendingFetches = function () {\n  _.forEach(this.client.getBrokers(true), broker => {\n    if (broker.socket.waiting) {\n      broker.socket.waiting = false;\n      this.client.clearCallbackQueue(broker.socket);\n    }\n  });\n};\n\nConsumerGroup.prototype.scheduleReconnect = function (timeout) {\n  assert(timeout);\n  this.rebalancing = true;\n\n  if (this.reconnectTimer) {\n    clearTimeout(this.reconnectTimer);\n  }\n\n  var self = this;\n  this.reconnectTimer = setTimeout(function () {\n    self.reconnectTimer = null;\n    self.connect();\n  }, timeout);\n};\n\nConsumerGroup.prototype.startHeartbeats = function () {\n  assert(this.options.sessionTimeout > 0);\n  assert(this.ready, 'consumerGroup is not ready');\n  const heartbeatIntervalMs = this.options.heartbeatInterval || Math.floor(this.options.sessionTimeout / 3);\n  logger.debug('%s started heartbeats at every %d ms', this.client.clientId, heartbeatIntervalMs);\n  this.stopHeartbeats();\n  let heartbeat = this.sendHeartbeat();\n  this.heartbeatInterval = setInterval(() => {\n    // only send another heartbeat if we got a response from the last one\n    if (heartbeat.verifyResolved()) {\n      heartbeat = this.sendHeartbeat();\n    }\n  }, heartbeatIntervalMs);\n};\n\nConsumerGroup.prototype.stopHeartbeats = function () {\n  this.heartbeatInterval && clearInterval(this.heartbeatInterval);\n};\n\nConsumerGroup.prototype.leaveGroup = function (callback) {\n  logger.debug('%s leaving group', this.client.clientId);\n  var self = this;\n  this.stopHeartbeats();\n\n  if (self.generationId != null && self.memberId) {\n    this.client.sendLeaveGroupRequest(this.options.groupId, this.memberId, function (error) {\n      self.generationId = null;\n      callback(error);\n    });\n  } else {\n    callback(null);\n  }\n};\n\nConsumerGroup.prototype.sendHeartbeat = function () {\n  assert(this.memberId, 'invalid memberId');\n  assert(this.generationId >= 0, 'invalid generationId'); // logger.debug('%s ❤️  ->', this.client.clientId);\n\n  var self = this;\n\n  function heartbeatCallback(error) {\n    if (error) {\n      logger.warn('%s Heartbeat error:', self.client.clientId, error);\n      self.recovery.tryToRecoverFrom(error, 'heartbeat');\n    } // logger.debug('%s 💚 <-', self.client.clientId, error);\n\n  }\n\n  const heartbeat = new Heartbeat(this.client, heartbeatCallback);\n  heartbeat.send(this.options.groupId, this.generationId, this.memberId);\n  return heartbeat;\n};\n\nConsumerGroup.prototype.fetchOffset = function (payloads, cb) {\n  this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);\n};\n\nConsumerGroup.prototype.sendOffsetCommitRequest = function (commits, cb) {\n  if (this.generationId && this.memberId) {\n    this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n};\n\nConsumerGroup.prototype.addTopics = function (topics, cb) {\n  topics = Array.isArray(topics) ? topics : [topics];\n\n  if (!this.client.ready) {\n    this.client.once('ready', () => this.addTopics(topics, cb));\n    return;\n  }\n\n  async.series([callback => this.client.topicExists(topics, callback), callback => this.options.autoCommit && this.generationId != null && this.memberId ? this.commit(true, callback) : callback(null), callback => this.leaveGroup(callback), callback => {\n    this.topics = this.topics.concat(topics);\n    this.setupProtocols(this.options.protocol);\n    this.connect();\n    callback(null);\n  }], error => error ? cb(error) : cb(null, `Add Topics ${topics.join(',')} Successfully`));\n};\n\nConsumerGroup.prototype.removeTopics = function (topics, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n  async.series([callback => this.client.topicExists(topics, callback), callback => this.options.autoCommit && this.generationId != null && this.memberId ? this.commit(true, callback) : callback(null), callback => this.leaveGroup(callback), callback => {\n    this.topics = _.difference(this.topics, topics);\n    this.setupProtocols(this.options.protocol);\n    this.connect();\n    callback(null);\n  }], error => error ? cb(error) : cb(null, `Remove Topics ${topics.join(',')} Successfully`));\n};\n\nConsumerGroup.prototype.buildPayloads = function (payloads) {\n  var self = this;\n  return payloads.map(function (p) {\n    if (typeof p !== 'object') p = {\n      topic: p\n    };\n    p.partition = p.partition || 0;\n    p.offset = p.offset || 0;\n    p.maxBytes = self.options.fetchMaxBytes;\n    p.metadata = 'm'; // metadata can be arbitrary\n\n    return p;\n  });\n};\n\nConsumerGroup.prototype.buildPayloadMap = function (payloads) {\n  const payloadMap = {};\n  payloads.forEach(({\n    topic,\n    partition,\n    offset\n  }) => {\n    payloadMap[topic] = payloadMap[topic] || {};\n    payloadMap[topic][partition] = offset;\n  });\n  return payloadMap;\n};\n/*\n * Update offset info in current payloads\n * @param {Object} Topic-partition-offset\n * @param {Boolean} Don't commit when initing consumer\n */\n\n\nConsumerGroup.prototype.updateOffsets = function (topics, initing) {\n  this.topicPayloads.forEach(p => {\n    if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n      var offset = topics[p.topic][p.partition];\n      if (offset === -1) offset = 0;\n      if (!initing) p.offset = offset + 1;else p.offset = offset; // Update the map\n\n      this.needToCommit = true;\n    }\n\n    this.payloadMap[p.topic] = this.payloadMap[p.topic] || {};\n    this.payloadMap[p.topic][p.partition] = p.offset;\n  });\n\n  if (this.options.autoCommit && !initing) {\n    this.autoCommit(false, function (err) {\n      err && logger.debug('auto commit offset', err);\n    });\n  }\n};\n\nConsumerGroup.prototype._onFetchDone = function (topics) {\n  this.updateOffsets(topics);\n\n  if (--this._pendingFetches > 0) {\n    return;\n  }\n\n  this._isFetchPending = false;\n\n  if (!this.paused) {\n    setImmediate(() => this.fetch());\n  }\n};\n\nConsumerGroup.prototype._resetFetchState = function () {\n  this._pendingFetches = 0;\n  this._isFetchPending = false;\n};\n\nConsumerGroup.prototype._onFetchProcessing = function () {\n  this._pendingFetches++;\n};\n\nConsumerGroup.prototype.fetch = function () {\n  if (!this.ready || this.rebalancing || this.paused || this.closing) {\n    return;\n  }\n\n  if (this._isFetchPending) {\n    return;\n  }\n\n  this._isFetchPending = true;\n  this.client.sendFetchRequest(this, this.topicPayloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes, this.options.maxTickMessages, error => {\n    if (error) {\n      this._resetFetchState();\n    }\n  });\n};\n\nConsumerGroup.prototype.setOffset = function (topic, partition, offset) {\n  this.topicPayloads.every(function (p) {\n    // eslint-disable-next-line eqeqeq\n    if (p.topic === topic && p.partition == partition) {\n      p.offset = offset;\n      return false;\n    }\n\n    return true;\n  });\n};\n\nConsumerGroup.prototype.pause = function () {\n  this.paused = true;\n};\n\nConsumerGroup.prototype.resume = function () {\n  this.paused = false;\n  this.fetch();\n};\n\nfunction autoCommit(force, cb) {\n  if (arguments.length === 1) {\n    cb = force;\n    force = false;\n  }\n\n  if (!force) {\n    if (this.committing) return cb(null, 'Offset committing');\n    if (!this.needToCommit) return cb(null, 'Commit not needed');\n  }\n\n  this.needToCommit = false;\n  this.committing = true;\n  setTimeout(function () {\n    this.committing = false;\n  }.bind(this), this.options.autoCommitIntervalMs).unref();\n  var commits = this.topicPayloads.filter(function (p) {\n    return p.offset !== -1;\n  });\n\n  if (commits.length) {\n    this.sendOffsetCommitRequest(commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n}\n\nConsumerGroup.prototype.commit = ConsumerGroup.prototype.autoCommit = autoCommit;\n\nConsumerGroup.prototype.close = function (force, cb) {\n  var self = this;\n  this.ready = false;\n  this.stopHeartbeats();\n  clearTimeout(this.topicPartitionCheckTimer);\n\n  if (typeof force === 'function') {\n    cb = force;\n    force = false;\n  }\n\n  async.series([function (callback) {\n    if (force) {\n      self.commit(true, callback);\n      return;\n    }\n\n    callback(null);\n  }, function (callback) {\n    self.leaveGroup(function (error) {\n      if (error) {\n        logger.error('Leave group failed with', error);\n      }\n\n      callback(null);\n    });\n  }, function (callback) {\n    self.client.close(callback);\n  }], function (error) {\n    if (error) {\n      return cb(error);\n    }\n\n    self.closed = true;\n    cb(null);\n  });\n};\n\nmodule.exports = ConsumerGroup;","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/kafka-node/lib/consumerGroup.js"],"names":["logger","require","util","EventEmitter","KafkaClient","Offset","_","async","validateConfig","ConsumerGroupRecovery","Heartbeat","createTopicPartitionList","errors","NestedError","assert","builtInProtocols","LATEST_OFFSET","EARLIEST_OFFSET","ACCEPTED_FROM_OFFSET","latest","earliest","none","DEFAULTS","groupId","autoCommit","autoCommitIntervalMs","fetchMaxWaitMs","paused","maxNumSegments","fetchMinBytes","fetchMaxBytes","maxTickMessages","fromOffset","outOfRangeOffset","sessionTimeout","retries","retryFactor","retryMinTimeout","commitOffsetsOnFirstJoin","connectOnReady","migrateHLC","onRebalance","topicPartitionCheckInterval","protocol","encoding","ConsumerGroup","memberOptions","topics","call","self","options","defaults","heartbeatInterval","Math","floor","ssl","Error","Object","keys","join","clientId","id","client","isString","Array","isArray","length","recovery","setupProtocols","once","connect","bind","on","err","error","emit","recoverFromBrokerChange","debounce","debug","refreshBrokerMetadata","reconnectIfNeeded","pause","setImmediate","topic","InvalidConsumerOffsetError","partition","time","getOffset","fetch","result","offset","head","oldOffset","find","topicPayloads","setOffset","resume","_pendingFetches","_onFetchProcessing","_onFetchDone","isLeader","coordinatorId","generationId","ready","payloadMap","inherits","prototype","connecting","reconnectTimer","clearTimeout","protocols","map","assign","checkProtocol","subscription","name","version","setCoordinatorId","String","assignPartitions","groupMembers","callback","flatten","uniq","value","waterfall","loadMetadataForTopics","metadataResponse","metadata","mapTopicToPartitions","topicPartitionLength","createTopicPartitionLength","difference","emptyTopics","forOwn","key","scheduleTopicPartitionCheck","topicPartitionCheckTimer","closed","setTimeout","_checkTopicPartitionChange","changed","series","memberId","commit","leaveGroup","topicOrPartitionsChanged","some","numberOfPartitions","get","mapValues","handleJoinGroup","joinGroupResponse","JSON","stringify","leaderId","groupAssignment","groupProtocol","members","saveDefaultOffsets","topicPartitionList","offsetPayload","cloneDeep","tp","defaultOffsets","partitionOffsets","handleSyncGroup","syncGroupResponse","ownedTopics","partitions","useDefaultOffsets","noOffset","fetchOffset","offsets","parallel","buildPayloads","p","getDefaultOffset","buildPayloadMap","defaultOffset","noop","emptyStrIfNull","warn","sendGroupCoordinatorRequest","coordinatorInfo","sendJoinGroupRequest","sendSyncGroupRequest","startFetch","rebalancing","tryToRecoverFrom","clearError","_resetFetchState","clearPendingFetches","startHeartbeats","forEach","getBrokers","broker","socket","waiting","clearCallbackQueue","scheduleReconnect","timeout","heartbeatIntervalMs","stopHeartbeats","heartbeat","sendHeartbeat","setInterval","verifyResolved","clearInterval","sendLeaveGroupRequest","heartbeatCallback","send","payloads","cb","sendOffsetFetchV1Request","sendOffsetCommitRequest","commits","sendOffsetCommitV2Request","addTopics","topicExists","concat","removeTopics","maxBytes","updateOffsets","initing","isEmpty","undefined","needToCommit","_isFetchPending","closing","sendFetchRequest","every","force","arguments","committing","unref","filter","close","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst logger = require('./logging')('kafka-node:ConsumerGroup');\nconst util = require('util');\nconst EventEmitter = require('events');\nconst KafkaClient = require('./kafkaClient');\nconst Offset = require('./offset');\nconst _ = require('lodash');\nconst async = require('async');\nconst validateConfig = require('./utils').validateConfig;\nconst ConsumerGroupRecovery = require('./consumerGroupRecovery');\nconst Heartbeat = require('./consumerGroupHeartbeat');\nconst createTopicPartitionList = require('./utils').createTopicPartitionList;\nconst errors = require('./errors');\nconst NestedError = require('nested-error-stacks');\n\nconst assert = require('assert');\nconst builtInProtocols = require('./assignment');\n\nconst LATEST_OFFSET = -1;\nconst EARLIEST_OFFSET = -2;\nconst ACCEPTED_FROM_OFFSET = {\n  latest: LATEST_OFFSET,\n  earliest: EARLIEST_OFFSET,\n  none: false\n};\n\nconst DEFAULTS = {\n  groupId: 'kafka-node-group',\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  // Fetch message config\n  fetchMaxWaitMs: 100,\n  paused: false,\n  maxNumSegments: 1000,\n  fetchMinBytes: 1,\n  fetchMaxBytes: 1024 * 1024,\n  maxTickMessages: 1000,\n  fromOffset: 'latest',\n  outOfRangeOffset: 'earliest',\n  sessionTimeout: 30000,\n  retries: 10,\n  retryFactor: 1.8,\n  retryMinTimeout: 1000,\n  commitOffsetsOnFirstJoin: true,\n  connectOnReady: true,\n  migrateHLC: false,\n  onRebalance: null,\n  topicPartitionCheckInterval: 30000,\n  protocol: ['roundrobin'],\n  encoding: 'utf8'\n};\n\nfunction ConsumerGroup (memberOptions, topics) {\n  EventEmitter.call(this);\n  const self = this;\n  this.options = _.defaults(memberOptions || {}, DEFAULTS);\n\n  if (!this.options.heartbeatInterval) {\n    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);\n  }\n\n  if (memberOptions.ssl === true) {\n    memberOptions.ssl = {};\n  }\n\n  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {\n    throw new Error(\n      `fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(', ')}`\n    );\n  }\n\n  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {\n    throw new Error(\n      `outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(\n        ', '\n      )}`\n    );\n  }\n\n  memberOptions.clientId = memberOptions.id;\n  this.client = new KafkaClient(memberOptions);\n\n  if (_.isString(topics)) {\n    topics = [topics];\n  }\n\n  assert(Array.isArray(topics), 'Array of topics is required');\n  assert(topics.length, 'Array of topics shall not be empty');\n\n  this.topics = topics;\n\n  this.recovery = new ConsumerGroupRecovery(this);\n\n  this.setupProtocols(this.options.protocol);\n\n  if (this.options.connectOnReady && !this.options.migrateHLC) {\n    this.client.once('ready', this.connect.bind(this));\n  }\n\n  if (this.options.migrateHLC) {\n    throw new Error(\n      'This version of KafkaClient cannot be used to migrate from Zookeeper use older version of kafka-node instead'\n    );\n  }\n\n  this.client.on('error', function (err) {\n    logger.error('Error from %s', self.client.clientId, err);\n    self.emit('error', err);\n  });\n\n  const recoverFromBrokerChange = _.debounce(function () {\n    logger.debug('brokersChanged refreshing metadata');\n    self.client.refreshBrokerMetadata(function (error) {\n      if (error) {\n        self.emit('error', error);\n        return;\n      }\n      self.reconnectIfNeeded();\n    });\n  }, 200);\n\n  this.client.on('brokersChanged', function () {\n    self.pause();\n    recoverFromBrokerChange();\n  });\n\n  this.client.on('reconnect', function () {\n    setImmediate(function () {\n      self.reconnectIfNeeded();\n    });\n  });\n\n  this.on('offsetOutOfRange', topic => {\n    this.pause();\n    if (this.options.outOfRangeOffset === 'none') {\n      this.emit(\n        'error',\n        new errors.InvalidConsumerOffsetError(\n          `Offset out of range for topic \"${topic.topic}\" partition ${topic.partition}`\n        )\n      );\n      return;\n    }\n\n    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];\n\n    this.getOffset().fetch([topic], (error, result) => {\n      if (error) {\n        this.emit(\n          'error',\n          new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error)\n        );\n        return;\n      }\n      const offset = _.head(result[topic.topic][topic.partition]);\n      const oldOffset = _.find(this.topicPayloads, { topic: topic.topic, partition: topic.partition }).offset;\n\n      logger.debug('replacing %s-%s stale offset of %d with %d', topic.topic, topic.partition, oldOffset, offset);\n\n      this.setOffset(topic.topic, topic.partition, offset);\n      this.resume();\n    });\n  });\n\n  this._pendingFetches = 0;\n  // 'processingfetch' emits before we start processing new messages\n  // 'done' will be emit when all messages are done emitting\n  this.on('processingfetch', () => this._onFetchProcessing());\n  this.on('done', topics => this._onFetchDone(topics));\n\n  if (this.options.groupId) {\n    validateConfig('options.groupId', this.options.groupId);\n  }\n\n  this.isLeader = false;\n  this.coordinatorId = null;\n  this.generationId = null;\n  this.ready = false;\n  this.topicPayloads = [];\n  this.payloadMap = {};\n}\n\nutil.inherits(ConsumerGroup, EventEmitter);\n\nConsumerGroup.prototype.reconnectIfNeeded = function () {\n  logger.debug('trying to reconnect if needed');\n  this.paused = false;\n  if (!this.ready && !this.connecting) {\n    if (this.reconnectTimer) {\n      // brokers changed so bypass backoff retry and reconnect now\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    this.connect();\n  } else if (!this.connecting) {\n    this.fetch();\n  }\n};\n\nConsumerGroup.prototype.setupProtocols = function (protocols) {\n  if (!Array.isArray(protocols)) {\n    protocols = [protocols];\n  }\n\n  this.protocols = protocols.map(function (protocol) {\n    if (typeof protocol === 'string') {\n      if (!(protocol in builtInProtocols)) {\n        throw new Error('Unknown built in assignment protocol ' + protocol);\n      }\n      protocol = _.assign({}, builtInProtocols[protocol]);\n    } else {\n      checkProtocol(protocol);\n    }\n\n    protocol.subscription = this.topics;\n    return protocol;\n  }, this);\n};\n\nfunction checkProtocol (protocol) {\n  assert(protocol, 'protocol is null');\n  assert(protocol.assign, 'assign function is not defined in the protocol');\n  assert(protocol.name, 'name must be given to protocol');\n  assert(protocol.version >= 0, 'version must be >= 0');\n}\n\nConsumerGroup.prototype.setCoordinatorId = function (coordinatorId) {\n  this.client.coordinatorId = String(coordinatorId);\n};\n\nConsumerGroup.prototype.assignPartitions = function (protocol, groupMembers, callback) {\n  logger.debug('Assigning Partitions to members', groupMembers);\n  logger.debug('Using group protocol', protocol);\n\n  protocol = _.find(this.protocols, { name: protocol });\n  if (!protocol) {\n    callback(new Error('Unknown group protocol: ' + protocol));\n    return;\n  }\n\n  var self = this;\n  var topics = _(groupMembers)\n    .map('subscription')\n    .flatten()\n    .uniq()\n    .value();\n\n  async.waterfall(\n    [\n      function (callback) {\n        logger.debug('loadingMetadata for topics:', topics);\n        self.client.loadMetadataForTopics(topics, callback);\n      },\n\n      function (metadataResponse, callback) {\n        var metadata = mapTopicToPartitions(metadataResponse[1].metadata);\n\n        self.topicPartitionLength = createTopicPartitionLength(metadata, _.difference(topics, Object.keys(metadata)));\n\n        logger.debug('mapTopicToPartitions', metadata);\n        protocol.assign(metadata, groupMembers, callback);\n      }\n    ],\n    callback\n  );\n};\n\nfunction createTopicPartitionLength (metadata, emptyTopics) {\n  const topicPartitionLength = {};\n  _.forOwn(metadata, function (value, key) {\n    topicPartitionLength[key] = value.length;\n  });\n\n  for (const topic of emptyTopics) {\n    if (topic in topicPartitionLength) {\n      throw new Error(`Topic ${topic} is not empty`);\n    }\n    topicPartitionLength[topic] = 0;\n  }\n  return topicPartitionLength;\n}\n\nConsumerGroup.prototype.scheduleTopicPartitionCheck = function () {\n  if (this.isLeader && !this.topicPartitionCheckTimer && !this.closed) {\n    logger.debug(`${this.client.clientId} is leader scheduled new topic/partition check`);\n    this.topicPartitionCheckTimer = setTimeout(() => {\n      this.topicPartitionCheckTimer = null;\n      if (this.closed) return;\n      logger.debug('checking for new topics and partitions');\n      this._checkTopicPartitionChange((error, changed) => {\n        if (error) {\n          this.scheduleTopicPartitionCheck();\n          return this.emit('error', new NestedError('topic/partition change check failed', error));\n        }\n\n        if (changed) {\n          logger.debug('Topic/Partitions has changed');\n          async.series([\n            callback =>\n              this.options.autoCommit && this.generationId != null && this.memberId\n                ? this.commit(true, callback)\n                : callback(null),\n            callback => this.leaveGroup(callback),\n            callback => {\n              this.connect();\n              callback(null);\n            }\n          ]);\n        } else {\n          logger.debug('no new Topic/Partitions');\n          this.scheduleTopicPartitionCheck();\n        }\n      });\n    }, this.options.topicPartitionCheckInterval);\n  }\n};\n\nConsumerGroup.prototype._checkTopicPartitionChange = function (callback) {\n  this.client.loadMetadataForTopics(this.topics, (error, metadataResponse) => {\n    if (error) {\n      return callback(error);\n    }\n    const metadata = mapTopicToPartitions(metadataResponse[1].metadata);\n\n    const topicOrPartitionsChanged = _.some(this.topicPartitionLength, function (numberOfPartitions, topic) {\n      return numberOfPartitions !== _.get(metadata, `['${topic}'].length`, 0);\n    });\n    callback(null, topicOrPartitionsChanged);\n  });\n};\n\nfunction mapTopicToPartitions (metadata) {\n  return _.mapValues(metadata, Object.keys);\n}\n\nConsumerGroup.prototype.handleJoinGroup = function (joinGroupResponse, callback) {\n  logger.debug('joinGroupResponse %j from %s', joinGroupResponse, this.client.clientId);\n  if (!joinGroupResponse.memberId || !joinGroupResponse.generationId) {\n    callback(new Error('Invalid joinGroupResponse: ' + JSON.stringify(joinGroupResponse)));\n    return;\n  }\n\n  this.isLeader = joinGroupResponse.leaderId === joinGroupResponse.memberId;\n  this.generationId = joinGroupResponse.generationId;\n  this.memberId = joinGroupResponse.memberId;\n\n  var groupAssignment;\n  if (this.isLeader) {\n    // assign partitions\n    return this.assignPartitions(joinGroupResponse.groupProtocol, joinGroupResponse.members, callback);\n  }\n  callback(null, groupAssignment);\n};\n\nConsumerGroup.prototype.saveDefaultOffsets = function (topicPartitionList, callback) {\n  var self = this;\n  const offsetPayload = _(topicPartitionList)\n    .cloneDeep()\n    .map(tp => {\n      tp.time = ACCEPTED_FROM_OFFSET[this.options.fromOffset];\n      return tp;\n    });\n\n  self.getOffset().fetch(offsetPayload, function (error, result) {\n    if (error) {\n      return callback(error);\n    }\n    self.defaultOffsets = _.mapValues(result, function (partitionOffsets) {\n      return _.mapValues(partitionOffsets, _.head);\n    });\n    callback(null);\n  });\n};\n\nConsumerGroup.prototype.handleSyncGroup = function (syncGroupResponse, callback) {\n  logger.debug('SyncGroup Response');\n  var self = this;\n  var ownedTopics = Object.keys(syncGroupResponse.partitions);\n  if (ownedTopics.length) {\n    logger.debug('%s owns topics: ', self.client.clientId, syncGroupResponse.partitions);\n\n    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);\n    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;\n\n    let noOffset;\n    async.waterfall(\n      [\n        function (callback) {\n          self.fetchOffset(syncGroupResponse.partitions, callback);\n        },\n        function (offsets, callback) {\n          logger.debug('%s fetchOffset Response: %j', self.client.clientId, offsets);\n\n          noOffset = topicPartitionList.some(function (tp) {\n            return offsets[tp.topic][tp.partition] === -1;\n          });\n\n          if (noOffset) {\n            logger.debug('No saved offsets');\n\n            if (self.options.fromOffset === 'none') {\n              return callback(\n                new Error(\n                  `${self.client.clientId} owns topics and partitions which contains no saved offsets for group '${\n                    self.options.groupId\n                  }'`\n                )\n              );\n            }\n\n            async.parallel(\n              [\n                function (callback) {\n                  if (useDefaultOffsets) {\n                    return self.saveDefaultOffsets(topicPartitionList, callback);\n                  }\n                  callback(null);\n                }\n              ],\n              function (error) {\n                if (error) {\n                  return callback(error);\n                }\n                logger.debug(\n                  '%s defaultOffset Response for %s: %j',\n                  self.client.clientId,\n                  self.options.fromOffset,\n                  self.defaultOffsets\n                );\n                callback(null, offsets);\n              }\n            );\n          } else {\n            logger.debug('Has saved offsets');\n            callback(null, offsets);\n          }\n        },\n        function (offsets, callback) {\n          self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {\n            var offset = offsets[p.topic][p.partition];\n            if (offset === -1) {\n              // -1 means no offset was saved for this topic/partition combo\n              offset = useDefaultOffsets ? self.getDefaultOffset(p, 0) : 0;\n            }\n            p.offset = offset;\n            return p;\n          });\n          self.payloadMap = self.buildPayloadMap(self.topicPayloads);\n          if (noOffset && self.options.commitOffsetsOnFirstJoin) {\n            self.commit(true, err => {\n              callback(err, !err ? true : null);\n            });\n          } else {\n            callback(null, true);\n          }\n        }\n      ],\n      callback\n    );\n  } else {\n    self.topicPayloads = [];\n    self.payloadMap = {};\n    // no partitions assigned\n    callback(null, false);\n  }\n};\n\nConsumerGroup.prototype.getDefaultOffset = function (tp, defaultOffset) {\n  return _.get(this.defaultOffsets, [tp.topic, tp.partition], defaultOffset);\n};\n\nConsumerGroup.prototype.getOffset = function () {\n  if (this.offset) {\n    return this.offset;\n  }\n  this.offset = new Offset(this.client);\n  // we can ignore this since we are already forwarding error event emitted from client\n  this.offset.on('error', _.noop);\n  return this.offset;\n};\n\nfunction emptyStrIfNull (value) {\n  return value == null ? '' : value;\n}\n\nConsumerGroup.prototype.connect = function () {\n  if (this.connecting) {\n    logger.warn('Connect ignored. Currently connecting.');\n    return;\n  }\n\n  if (this.closed) {\n    logger.warn('Connect ignored. Consumer closed.');\n    return;\n  }\n\n  logger.debug('Connecting %s', this.client.clientId);\n  var self = this;\n\n  this.connecting = true;\n  this.emit('rebalancing');\n\n  async.waterfall(\n    [\n      function (callback) {\n        if (typeof self.options.onRebalance === 'function') {\n          self.options.onRebalance(self.generationId != null && self.memberId != null, function (error) {\n            if (error) {\n              return callback(error);\n            }\n            callback(null);\n          });\n          return;\n        }\n        callback(null);\n      },\n      function (callback) {\n        if (self.options.autoCommit && self.generationId != null && self.memberId) {\n          self.commit(true, function (error) {\n            if (error) {\n              return callback(error);\n            }\n            callback(null);\n          });\n          return;\n        }\n        callback(null);\n      },\n      function (callback) {\n        if (self.client.coordinatorId) {\n          return callback(null, null);\n        }\n        self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);\n      },\n\n      function (coordinatorInfo, callback) {\n        logger.debug('GroupCoordinator Response:', coordinatorInfo);\n        if (coordinatorInfo) {\n          self.setCoordinatorId(coordinatorInfo.coordinatorId);\n        }\n        self.client.sendJoinGroupRequest(\n          self.options.groupId,\n          emptyStrIfNull(self.memberId),\n          self.options.sessionTimeout,\n          self.protocols,\n          callback\n        );\n      },\n\n      function (joinGroupResponse, callback) {\n        self.handleJoinGroup(joinGroupResponse, callback);\n      },\n\n      function (groupAssignment, callback) {\n        logger.debug('SyncGroup Request from %s', self.memberId);\n        self.client.sendSyncGroupRequest(\n          self.options.groupId,\n          self.generationId,\n          self.memberId,\n          groupAssignment,\n          callback\n        );\n      },\n\n      function (syncGroupResponse, callback) {\n        self.handleSyncGroup(syncGroupResponse, callback);\n      }\n    ],\n    function (error, startFetch) {\n      self.connecting = false;\n      self.rebalancing = false;\n      if (error) {\n        return self.recovery.tryToRecoverFrom(error, 'connect');\n      }\n\n      self.ready = true;\n      self.recovery.clearError();\n\n      logger.debug('generationId', self.generationId);\n\n      logger.debug('startFetch is', startFetch);\n      self._resetFetchState();\n      if (startFetch) {\n        self.clearPendingFetches();\n        self.fetch();\n      }\n      self.scheduleTopicPartitionCheck();\n      self.startHeartbeats();\n      self.emit('connect');\n      self.emit('rebalanced');\n    }\n  );\n};\n\nConsumerGroup.prototype.clearPendingFetches = function () {\n  _.forEach(this.client.getBrokers(true), broker => {\n    if (broker.socket.waiting) {\n      broker.socket.waiting = false;\n      this.client.clearCallbackQueue(broker.socket);\n    }\n  });\n};\n\nConsumerGroup.prototype.scheduleReconnect = function (timeout) {\n  assert(timeout);\n  this.rebalancing = true;\n\n  if (this.reconnectTimer) {\n    clearTimeout(this.reconnectTimer);\n  }\n\n  var self = this;\n  this.reconnectTimer = setTimeout(function () {\n    self.reconnectTimer = null;\n    self.connect();\n  }, timeout);\n};\n\nConsumerGroup.prototype.startHeartbeats = function () {\n  assert(this.options.sessionTimeout > 0);\n  assert(this.ready, 'consumerGroup is not ready');\n\n  const heartbeatIntervalMs = this.options.heartbeatInterval || Math.floor(this.options.sessionTimeout / 3);\n\n  logger.debug('%s started heartbeats at every %d ms', this.client.clientId, heartbeatIntervalMs);\n  this.stopHeartbeats();\n\n  let heartbeat = this.sendHeartbeat();\n\n  this.heartbeatInterval = setInterval(() => {\n    // only send another heartbeat if we got a response from the last one\n    if (heartbeat.verifyResolved()) {\n      heartbeat = this.sendHeartbeat();\n    }\n  }, heartbeatIntervalMs);\n};\n\nConsumerGroup.prototype.stopHeartbeats = function () {\n  this.heartbeatInterval && clearInterval(this.heartbeatInterval);\n};\n\nConsumerGroup.prototype.leaveGroup = function (callback) {\n  logger.debug('%s leaving group', this.client.clientId);\n  var self = this;\n  this.stopHeartbeats();\n  if (self.generationId != null && self.memberId) {\n    this.client.sendLeaveGroupRequest(this.options.groupId, this.memberId, function (error) {\n      self.generationId = null;\n      callback(error);\n    });\n  } else {\n    callback(null);\n  }\n};\n\nConsumerGroup.prototype.sendHeartbeat = function () {\n  assert(this.memberId, 'invalid memberId');\n  assert(this.generationId >= 0, 'invalid generationId');\n  // logger.debug('%s ❤️  ->', this.client.clientId);\n  var self = this;\n\n  function heartbeatCallback (error) {\n    if (error) {\n      logger.warn('%s Heartbeat error:', self.client.clientId, error);\n      self.recovery.tryToRecoverFrom(error, 'heartbeat');\n    }\n    // logger.debug('%s 💚 <-', self.client.clientId, error);\n  }\n\n  const heartbeat = new Heartbeat(this.client, heartbeatCallback);\n  heartbeat.send(this.options.groupId, this.generationId, this.memberId);\n\n  return heartbeat;\n};\n\nConsumerGroup.prototype.fetchOffset = function (payloads, cb) {\n  this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);\n};\n\nConsumerGroup.prototype.sendOffsetCommitRequest = function (commits, cb) {\n  if (this.generationId && this.memberId) {\n    this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n};\n\nConsumerGroup.prototype.addTopics = function (topics, cb) {\n  topics = Array.isArray(topics) ? topics : [topics];\n\n  if (!this.client.ready) {\n    this.client.once('ready', () => this.addTopics(topics, cb));\n    return;\n  }\n\n  async.series(\n    [\n      callback => this.client.topicExists(topics, callback),\n      callback =>\n        this.options.autoCommit && this.generationId != null && this.memberId\n          ? this.commit(true, callback)\n          : callback(null),\n      callback => this.leaveGroup(callback),\n      callback => {\n        this.topics = this.topics.concat(topics);\n        this.setupProtocols(this.options.protocol);\n        this.connect();\n        callback(null);\n      }\n    ],\n    error => (error ? cb(error) : cb(null, `Add Topics ${topics.join(',')} Successfully`))\n  );\n};\n\nConsumerGroup.prototype.removeTopics = function (topics, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n\n  async.series(\n    [\n      callback => this.client.topicExists(topics, callback),\n      callback =>\n        this.options.autoCommit && this.generationId != null && this.memberId\n          ? this.commit(true, callback)\n          : callback(null),\n      callback => this.leaveGroup(callback),\n      callback => {\n        this.topics = _.difference(this.topics, topics);\n        this.setupProtocols(this.options.protocol);\n        this.connect();\n        callback(null);\n      }\n    ],\n    error => (error ? cb(error) : cb(null, `Remove Topics ${topics.join(',')} Successfully`))\n  );\n};\n\nConsumerGroup.prototype.buildPayloads = function (payloads) {\n  var self = this;\n  return payloads.map(function (p) {\n    if (typeof p !== 'object') p = { topic: p };\n    p.partition = p.partition || 0;\n    p.offset = p.offset || 0;\n    p.maxBytes = self.options.fetchMaxBytes;\n    p.metadata = 'm'; // metadata can be arbitrary\n    return p;\n  });\n};\n\nConsumerGroup.prototype.buildPayloadMap = function (payloads) {\n  const payloadMap = {};\n  payloads.forEach(({ topic, partition, offset }) => {\n    payloadMap[topic] = payloadMap[topic] || {};\n    payloadMap[topic][partition] = offset;\n  });\n  return payloadMap;\n};\n\n/*\n * Update offset info in current payloads\n * @param {Object} Topic-partition-offset\n * @param {Boolean} Don't commit when initing consumer\n */\nConsumerGroup.prototype.updateOffsets = function (topics, initing) {\n  this.topicPayloads.forEach(p => {\n    if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n      var offset = topics[p.topic][p.partition];\n      if (offset === -1) offset = 0;\n      if (!initing) p.offset = offset + 1;\n      else p.offset = offset;\n      // Update the map\n      this.needToCommit = true;\n    }\n    this.payloadMap[p.topic] = this.payloadMap[p.topic] || {};\n    this.payloadMap[p.topic][p.partition] = p.offset;\n  });\n\n  if (this.options.autoCommit && !initing) {\n    this.autoCommit(false, function (err) {\n      err && logger.debug('auto commit offset', err);\n    });\n  }\n};\n\nConsumerGroup.prototype._onFetchDone = function (topics) {\n  this.updateOffsets(topics);\n  if (--this._pendingFetches > 0) {\n    return;\n  }\n  this._isFetchPending = false;\n  if (!this.paused) {\n    setImmediate(() => this.fetch());\n  }\n};\n\nConsumerGroup.prototype._resetFetchState = function () {\n  this._pendingFetches = 0;\n  this._isFetchPending = false;\n};\n\nConsumerGroup.prototype._onFetchProcessing = function () {\n  this._pendingFetches++;\n};\n\nConsumerGroup.prototype.fetch = function () {\n  if (!this.ready || this.rebalancing || this.paused || this.closing) {\n    return;\n  }\n  if (this._isFetchPending) {\n    return;\n  }\n  this._isFetchPending = true;\n\n  this.client.sendFetchRequest(\n    this,\n    this.topicPayloads,\n    this.options.fetchMaxWaitMs,\n    this.options.fetchMinBytes,\n    this.options.maxTickMessages,\n    error => {\n      if (error) {\n        this._resetFetchState();\n      }\n    }\n  );\n};\n\nConsumerGroup.prototype.setOffset = function (topic, partition, offset) {\n  this.topicPayloads.every(function (p) {\n    // eslint-disable-next-line eqeqeq\n    if (p.topic === topic && p.partition == partition) {\n      p.offset = offset;\n      return false;\n    }\n    return true;\n  });\n};\n\nConsumerGroup.prototype.pause = function () {\n  this.paused = true;\n};\n\nConsumerGroup.prototype.resume = function () {\n  this.paused = false;\n  this.fetch();\n};\n\nfunction autoCommit (force, cb) {\n  if (arguments.length === 1) {\n    cb = force;\n    force = false;\n  }\n\n  if (!force) {\n    if (this.committing) return cb(null, 'Offset committing');\n    if (!this.needToCommit) return cb(null, 'Commit not needed');\n  }\n\n  this.needToCommit = false;\n  this.committing = true;\n  setTimeout(\n    function () {\n      this.committing = false;\n    }.bind(this),\n    this.options.autoCommitIntervalMs\n  ).unref();\n\n  var commits = this.topicPayloads.filter(function (p) {\n    return p.offset !== -1;\n  });\n\n  if (commits.length) {\n    this.sendOffsetCommitRequest(commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n}\n\nConsumerGroup.prototype.commit = ConsumerGroup.prototype.autoCommit = autoCommit;\n\nConsumerGroup.prototype.close = function (force, cb) {\n  var self = this;\n  this.ready = false;\n\n  this.stopHeartbeats();\n  clearTimeout(this.topicPartitionCheckTimer);\n\n  if (typeof force === 'function') {\n    cb = force;\n    force = false;\n  }\n\n  async.series(\n    [\n      function (callback) {\n        if (force) {\n          self.commit(true, callback);\n          return;\n        }\n        callback(null);\n      },\n      function (callback) {\n        self.leaveGroup(function (error) {\n          if (error) {\n            logger.error('Leave group failed with', error);\n          }\n          callback(null);\n        });\n      },\n      function (callback) {\n        self.client.close(callback);\n      }\n    ],\n    function (error) {\n      if (error) {\n        return cb(error);\n      }\n      self.closed = true;\n      cb(null);\n    }\n  );\n};\n\nmodule.exports = ConsumerGroup;\n"]},"metadata":{},"sourceType":"script"}