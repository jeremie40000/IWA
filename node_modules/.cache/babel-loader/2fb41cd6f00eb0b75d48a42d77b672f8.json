{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar _ = require('lodash');\n\nvar EventEmitter = require('events');\n\nvar logger = require('./logging')('kafka-node:Consumer');\n\nvar utils = require('./utils');\n\nvar DEFAULTS = {\n  groupId: 'kafka-node-group',\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  // Fetch message config\n  fetchMaxWaitMs: 100,\n  fetchMinBytes: 1,\n  fetchMaxBytes: 1024 * 1024,\n  fromOffset: false,\n  encoding: 'utf8'\n};\n\nvar nextId = function () {\n  var id = 0;\n  return function () {\n    return id++;\n  };\n}();\n\nfunction Consumer(client, topics, options) {\n  EventEmitter.call(this);\n\n  if (!topics) {\n    throw new Error('Must have payloads');\n  }\n\n  utils.validateTopics(topics);\n  this.fetchCount = 0;\n  this.client = client;\n  this.options = _.defaults(options || {}, DEFAULTS);\n  this.ready = false;\n  this.paused = this.options.paused;\n  this.id = nextId();\n  this.payloads = this.buildPayloads(topics);\n  this.connect();\n  this.encoding = this.options.encoding;\n\n  if (this.options.groupId) {\n    utils.validateConfig('options.groupId', this.options.groupId);\n  }\n}\n\nutil.inherits(Consumer, EventEmitter);\n\nConsumer.prototype.buildPayloads = function (payloads) {\n  var self = this;\n  return payloads.map(function (p) {\n    if (typeof p !== 'object') p = {\n      topic: p\n    };\n    p.partition = p.partition || 0;\n    p.offset = p.offset || 0;\n    p.maxBytes = self.options.fetchMaxBytes;\n    p.metadata = 'm'; // metadata can be arbitrary\n\n    return p;\n  });\n};\n\nConsumer.prototype.connect = function () {\n  var self = this; // Client already exists\n\n  this.ready = this.client.ready;\n  if (this.ready) this.init();\n  this.client.on('ready', function () {\n    logger.debug('consumer ready');\n    if (!self.ready) self.init();\n    self.ready = true;\n  });\n  this.client.on('error', function (err) {\n    logger.error('client error %s', err.message);\n    self.emit('error', err);\n  });\n  this.client.on('close', function () {\n    logger.debug('connection closed');\n  });\n  this.client.on('brokersChanged', function () {\n    var topicNames = self.payloads.map(function (p) {\n      return p.topic;\n    });\n    this.refreshMetadata(topicNames, function (err) {\n      if (err) return self.emit('error', err);\n      self.fetch();\n    });\n  }); // 'done' will be emit when a message fetch request complete\n\n  this.on('done', function (topics) {\n    self.updateOffsets(topics);\n    setImmediate(function () {\n      self.fetch();\n    });\n  });\n};\n\nConsumer.prototype.init = function () {\n  if (!this.payloads.length) {\n    return;\n  }\n\n  var self = this;\n  var topics = self.payloads.map(function (p) {\n    return p.topic;\n  });\n  self.client.topicExists(topics, function (err) {\n    if (err) {\n      return self.emit('error', err);\n    }\n\n    if (self.options.fromOffset) {\n      return self.fetch();\n    }\n\n    self.fetchOffset(self.payloads, function (err, topics) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      self.updateOffsets(topics, true);\n      self.fetch();\n    });\n  });\n};\n/*\n * Update offset info in current payloads\n * @param {Object} Topic-partition-offset\n * @param {Boolean} Don't commit when initing consumer\n */\n\n\nConsumer.prototype.updateOffsets = function (topics, initing) {\n  this.payloads.forEach(function (p) {\n    if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n      var offset = topics[p.topic][p.partition];\n      if (offset === -1) offset = 0;\n      if (!initing) p.offset = offset + 1;else p.offset = offset;\n    }\n  });\n\n  if (this.options.autoCommit && !initing) {\n    this.autoCommit(false, function (err) {\n      err && logger.debug('auto commit offset', err);\n    });\n  }\n};\n\nfunction autoCommit(force, cb) {\n  if (arguments.length === 1) {\n    cb = force;\n    force = false;\n  }\n\n  if (this.committing && !force) return cb(null, 'Offset committing');\n  this.committing = true;\n  setTimeout(function () {\n    this.committing = false;\n  }.bind(this), this.options.autoCommitIntervalMs);\n  var payloads = this.payloads;\n  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);\n  var commits = payloads.filter(function (p) {\n    return p.offset !== 0;\n  });\n\n  if (commits.length) {\n    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n}\n\nConsumer.prototype.commit = Consumer.prototype.autoCommit = autoCommit;\n\nConsumer.prototype.fetch = function () {\n  if (!this.ready || this.paused) return;\n  this.client.sendFetchRequest(this, this.payloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes);\n};\n\nConsumer.prototype.fetchOffset = function (payloads, cb) {\n  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);\n};\n\nConsumer.prototype.addTopics = function (topics, cb, fromOffset) {\n  fromOffset = !!fromOffset;\n  var self = this;\n\n  if (!this.ready) {\n    setTimeout(function () {\n      self.addTopics(topics, cb, fromOffset);\n    }, 100);\n    return;\n  } // The default is that the topics is a string array of topic names\n\n\n  var topicNames = topics; // If the topics is actually an object and not string we assume it is an array of payloads\n\n  if (typeof topics[0] === 'object') {\n    topicNames = topics.map(function (p) {\n      return p.topic;\n    });\n  }\n\n  this.client.addTopics(topicNames, function (err, added) {\n    if (err) return cb && cb(err, added);\n    var payloads = self.buildPayloads(topics);\n    var reFetch = !self.payloads.length;\n\n    if (fromOffset) {\n      payloads.forEach(function (p) {\n        self.payloads.push(p);\n      });\n      if (reFetch) self.fetch();\n      cb && cb(null, added);\n      return;\n    } // update offset of topics that will be added\n\n\n    self.fetchOffset(payloads, function (err, offsets) {\n      if (err) return cb(err);\n      payloads.forEach(function (p) {\n        var offset = offsets[p.topic][p.partition];\n        if (offset === -1) offset = 0;\n        p.offset = offset;\n        self.payloads.push(p);\n      });\n      if (reFetch) self.fetch();\n      cb && cb(null, added);\n    });\n  });\n};\n\nConsumer.prototype.removeTopics = function (topics, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n  this.payloads = this.payloads.filter(function (p) {\n    return !~topics.indexOf(p.topic);\n  });\n  this.client.removeTopicMetadata(topics, cb);\n};\n\nConsumer.prototype.close = function (force, cb) {\n  this.ready = false;\n\n  if (typeof force === 'function') {\n    cb = force;\n    force = false;\n  }\n\n  if (force) {\n    this.commit(force, function (err) {\n      if (err) {\n        return cb(err);\n      }\n\n      this.client.close(cb);\n    }.bind(this));\n  } else {\n    this.client.close(cb);\n  }\n};\n\nConsumer.prototype.setOffset = function (topic, partition, offset) {\n  this.payloads.every(function (p) {\n    if (p.topic === topic && p.partition == partition) {\n      // eslint-disable-line eqeqeq\n      p.offset = offset;\n      return false;\n    }\n\n    return true;\n  });\n};\n\nConsumer.prototype.pause = function () {\n  this.paused = true;\n};\n\nConsumer.prototype.resume = function () {\n  this.paused = false;\n  this.fetch();\n};\n\nConsumer.prototype.pauseTopics = function (topics) {\n  if (!this.pausedPayloads) this.pausedPayloads = [];\n  pauseOrResume(this.payloads, this.pausedPayloads, topics);\n};\n\nConsumer.prototype.resumeTopics = function (topics) {\n  if (!this.pausedPayloads) this.pausedPayloads = [];\n  var reFetch = !this.payloads.length;\n  pauseOrResume(this.pausedPayloads, this.payloads, topics);\n  reFetch = reFetch && this.payloads.length;\n  if (reFetch) this.fetch();\n};\n\nfunction pauseOrResume(payloads, nextPayloads, topics) {\n  if (!topics || !topics.length) return;\n\n  for (var i = 0, j = 0, l = payloads.length; j < l; i++, j++) {\n    if (isInTopics(payloads[i])) {\n      nextPayloads.push(payloads.splice(i, 1)[0]);\n      i--;\n    }\n  }\n\n  function isInTopics(p) {\n    return topics.some(function (topic) {\n      if (typeof topic === 'string') {\n        return p.topic === topic;\n      } else {\n        return p.topic === topic.topic && p.partition === topic.partition;\n      }\n    });\n  }\n}\n\nmodule.exports = Consumer;","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/kafka-node/lib/consumer.js"],"names":["util","require","_","EventEmitter","logger","utils","DEFAULTS","groupId","autoCommit","autoCommitIntervalMs","fetchMaxWaitMs","fetchMinBytes","fetchMaxBytes","fromOffset","encoding","nextId","id","Consumer","client","topics","options","call","Error","validateTopics","fetchCount","defaults","ready","paused","payloads","buildPayloads","connect","validateConfig","inherits","prototype","self","map","p","topic","partition","offset","maxBytes","metadata","init","on","debug","err","error","message","emit","topicNames","refreshMetadata","fetch","updateOffsets","setImmediate","length","topicExists","fetchOffset","initing","forEach","isEmpty","undefined","force","cb","arguments","committing","setTimeout","bind","pausedPayloads","concat","commits","filter","sendOffsetCommitRequest","commit","sendFetchRequest","sendOffsetFetchRequest","addTopics","added","reFetch","push","offsets","removeTopics","indexOf","removeTopicMetadata","close","setOffset","every","pause","resume","pauseTopics","pauseOrResume","resumeTopics","nextPayloads","i","j","l","isInTopics","splice","some","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar util = require('util');\nvar _ = require('lodash');\nvar EventEmitter = require('events');\nvar logger = require('./logging')('kafka-node:Consumer');\nvar utils = require('./utils');\n\nvar DEFAULTS = {\n  groupId: 'kafka-node-group',\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  // Fetch message config\n  fetchMaxWaitMs: 100,\n  fetchMinBytes: 1,\n  fetchMaxBytes: 1024 * 1024,\n  fromOffset: false,\n  encoding: 'utf8'\n};\n\nvar nextId = (function () {\n  var id = 0;\n  return function () {\n    return id++;\n  };\n})();\n\nfunction Consumer (client, topics, options) {\n  EventEmitter.call(this);\n  if (!topics) {\n    throw new Error('Must have payloads');\n  }\n\n  utils.validateTopics(topics);\n\n  this.fetchCount = 0;\n  this.client = client;\n  this.options = _.defaults((options || {}), DEFAULTS);\n  this.ready = false;\n  this.paused = this.options.paused;\n  this.id = nextId();\n  this.payloads = this.buildPayloads(topics);\n  this.connect();\n  this.encoding = this.options.encoding;\n\n  if (this.options.groupId) {\n    utils.validateConfig('options.groupId', this.options.groupId);\n  }\n}\nutil.inherits(Consumer, EventEmitter);\n\nConsumer.prototype.buildPayloads = function (payloads) {\n  var self = this;\n  return payloads.map(function (p) {\n    if (typeof p !== 'object') p = { topic: p };\n    p.partition = p.partition || 0;\n    p.offset = p.offset || 0;\n    p.maxBytes = self.options.fetchMaxBytes;\n    p.metadata = 'm'; // metadata can be arbitrary\n    return p;\n  });\n};\n\nConsumer.prototype.connect = function () {\n  var self = this;\n  // Client already exists\n  this.ready = this.client.ready;\n  if (this.ready) this.init();\n\n  this.client.on('ready', function () {\n    logger.debug('consumer ready');\n    if (!self.ready) self.init();\n    self.ready = true;\n  });\n\n  this.client.on('error', function (err) {\n    logger.error('client error %s', err.message);\n    self.emit('error', err);\n  });\n\n  this.client.on('close', function () {\n    logger.debug('connection closed');\n  });\n\n  this.client.on('brokersChanged', function () {\n    var topicNames = self.payloads.map(function (p) {\n      return p.topic;\n    });\n\n    this.refreshMetadata(topicNames, function (err) {\n      if (err) return self.emit('error', err);\n      self.fetch();\n    });\n  });\n  // 'done' will be emit when a message fetch request complete\n  this.on('done', function (topics) {\n    self.updateOffsets(topics);\n    setImmediate(function () {\n      self.fetch();\n    });\n  });\n};\n\nConsumer.prototype.init = function () {\n  if (!this.payloads.length) {\n    return;\n  }\n\n  var self = this;\n  var topics = self.payloads.map(function (p) { return p.topic; });\n\n  self.client.topicExists(topics, function (err) {\n    if (err) {\n      return self.emit('error', err);\n    }\n\n    if (self.options.fromOffset) {\n      return self.fetch();\n    }\n\n    self.fetchOffset(self.payloads, function (err, topics) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      self.updateOffsets(topics, true);\n      self.fetch();\n    });\n  });\n};\n\n/*\n * Update offset info in current payloads\n * @param {Object} Topic-partition-offset\n * @param {Boolean} Don't commit when initing consumer\n */\nConsumer.prototype.updateOffsets = function (topics, initing) {\n  this.payloads.forEach(function (p) {\n    if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n      var offset = topics[p.topic][p.partition];\n      if (offset === -1) offset = 0;\n      if (!initing) p.offset = offset + 1;\n      else p.offset = offset;\n    }\n  });\n\n  if (this.options.autoCommit && !initing) {\n    this.autoCommit(false, function (err) {\n      err && logger.debug('auto commit offset', err);\n    });\n  }\n};\n\nfunction autoCommit (force, cb) {\n  if (arguments.length === 1) {\n    cb = force;\n    force = false;\n  }\n\n  if (this.committing && !force) return cb(null, 'Offset committing');\n\n  this.committing = true;\n  setTimeout(function () {\n    this.committing = false;\n  }.bind(this), this.options.autoCommitIntervalMs);\n\n  var payloads = this.payloads;\n  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);\n\n  var commits = payloads.filter(function (p) { return p.offset !== 0; });\n  if (commits.length) {\n    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);\n  } else {\n    cb(null, 'Nothing to be committed');\n  }\n}\nConsumer.prototype.commit = Consumer.prototype.autoCommit = autoCommit;\n\nConsumer.prototype.fetch = function () {\n  if (!this.ready || this.paused) return;\n  this.client.sendFetchRequest(this, this.payloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes);\n};\n\nConsumer.prototype.fetchOffset = function (payloads, cb) {\n  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);\n};\n\nConsumer.prototype.addTopics = function (topics, cb, fromOffset) {\n  fromOffset = !!fromOffset;\n  var self = this;\n  if (!this.ready) {\n    setTimeout(function () {\n      self.addTopics(topics, cb, fromOffset);\n    }\n    , 100);\n    return;\n  }\n\n  // The default is that the topics is a string array of topic names\n  var topicNames = topics;\n\n  // If the topics is actually an object and not string we assume it is an array of payloads\n  if (typeof topics[0] === 'object') {\n    topicNames = topics.map(function (p) { return p.topic; });\n  }\n\n  this.client.addTopics(\n    topicNames,\n    function (err, added) {\n      if (err) return cb && cb(err, added);\n\n      var payloads = self.buildPayloads(topics);\n      var reFetch = !self.payloads.length;\n\n      if (fromOffset) {\n        payloads.forEach(function (p) {\n          self.payloads.push(p);\n        });\n        if (reFetch) self.fetch();\n        cb && cb(null, added);\n        return;\n      }\n\n      // update offset of topics that will be added\n      self.fetchOffset(payloads, function (err, offsets) {\n        if (err) return cb(err);\n        payloads.forEach(function (p) {\n          var offset = offsets[p.topic][p.partition];\n          if (offset === -1) offset = 0;\n          p.offset = offset;\n          self.payloads.push(p);\n        });\n        if (reFetch) self.fetch();\n        cb && cb(null, added);\n      });\n    }\n  );\n};\n\nConsumer.prototype.removeTopics = function (topics, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n  this.payloads = this.payloads.filter(function (p) {\n    return !~topics.indexOf(p.topic);\n  });\n\n  this.client.removeTopicMetadata(topics, cb);\n};\n\nConsumer.prototype.close = function (force, cb) {\n  this.ready = false;\n  if (typeof force === 'function') {\n    cb = force;\n    force = false;\n  }\n\n  if (force) {\n    this.commit(force, function (err) {\n      if (err) {\n        return cb(err);\n      }\n      this.client.close(cb);\n    }.bind(this));\n  } else {\n    this.client.close(cb);\n  }\n};\n\nConsumer.prototype.setOffset = function (topic, partition, offset) {\n  this.payloads.every(function (p) {\n    if (p.topic === topic && p.partition == partition) { // eslint-disable-line eqeqeq\n      p.offset = offset;\n      return false;\n    }\n    return true;\n  });\n};\n\nConsumer.prototype.pause = function () {\n  this.paused = true;\n};\n\nConsumer.prototype.resume = function () {\n  this.paused = false;\n  this.fetch();\n};\n\nConsumer.prototype.pauseTopics = function (topics) {\n  if (!this.pausedPayloads) this.pausedPayloads = [];\n  pauseOrResume(this.payloads, this.pausedPayloads, topics);\n};\n\nConsumer.prototype.resumeTopics = function (topics) {\n  if (!this.pausedPayloads) this.pausedPayloads = [];\n  var reFetch = !this.payloads.length;\n  pauseOrResume(this.pausedPayloads, this.payloads, topics);\n  reFetch = reFetch && this.payloads.length;\n  if (reFetch) this.fetch();\n};\n\nfunction pauseOrResume (payloads, nextPayloads, topics) {\n  if (!topics || !topics.length) return;\n\n  for (var i = 0, j = 0, l = payloads.length; j < l; i++, j++) {\n    if (isInTopics(payloads[i])) {\n      nextPayloads.push(\n        payloads.splice(i, 1)[0]\n      );\n      i--;\n    }\n  }\n\n  function isInTopics (p) {\n    return topics.some(function (topic) {\n      if (typeof topic === 'string') {\n        return p.topic === topic;\n      } else {\n        return p.topic === topic.topic && p.partition === topic.partition;\n      }\n    });\n  }\n}\n\nmodule.exports = Consumer;\n"]},"metadata":{},"sourceType":"script"}