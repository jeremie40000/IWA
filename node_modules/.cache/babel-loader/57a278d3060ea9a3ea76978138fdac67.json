{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar _ = require('lodash');\n\nvar async = require('async');\n\nvar retry = require('retry');\n\nvar EventEmitter = require('events');\n\nvar errors = require('./errors');\n\nvar getCodec = require('./codec');\n\nvar protocol = require('./protocol');\n\nvar encodeMessageSet = protocol.encodeMessageSet;\nvar Message = protocol.Message;\n\nvar logger = require('./logging')('kafka-node:BaseClient');\n\nvar validateKafkaTopics = require('./utils').validateTopicNames;\n\nconst MAX_INT32 = 2147483647;\n/**\n *\n * @constructor\n */\n\nfunction Client() {\n  throw new TypeError('BaseClient cannot be instantiated directly');\n}\n\nutil.inherits(Client, EventEmitter);\n\nClient.prototype.closeBrokers = function (brokers) {\n  _.each(brokers, function (broker) {\n    broker.socket.closing = true;\n    broker.socket.end();\n    setImmediate(function () {\n      broker.socket.destroy();\n      broker.socket.unref();\n    });\n  });\n};\n\nfunction decodeValue(encoding, value) {\n  if (encoding !== 'buffer' && value != null) {\n    return value.toString(encoding);\n  }\n\n  return value;\n}\n\nClient.prototype._createMessageHandler = function (consumer, stateValidator) {\n  return (err, type, message) => {\n    if (stateValidator && !stateValidator(err, type, message)) {\n      return;\n    }\n\n    if (err) {\n      if (err.message === 'OffsetOutOfRange') {\n        return consumer.emit('offsetOutOfRange', err);\n      } else if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n        return this.emit('brokersChanged');\n      }\n\n      return consumer.emit('error', err);\n    }\n\n    var encoding = consumer.options.encoding;\n    const keyEncoding = consumer.options.keyEncoding;\n\n    if (type === 'message') {\n      message.value = decodeValue(encoding, message.value);\n      message.key = decodeValue(keyEncoding || encoding, message.key);\n      consumer.emit('message', message);\n    } else {\n      consumer.emit(type, message);\n    }\n  };\n};\n\nClient.prototype.sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {\n  var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes); // TODO: state validator for HLC for ignoring stale fetch requests\n\n  var decoder = protocol.decodeFetchResponse(this._createMessageHandler(consumer), maxTickMessages);\n  this.send(payloads, encoder, decoder, function (err) {\n    if (err) {\n      Array.prototype.unshift.call(arguments, 'error');\n      consumer.emit.apply(consumer, arguments);\n    }\n  });\n};\n\nClient.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {\n  var encoder = protocol.encodeProduceRequest(requireAcks, ackTimeoutMs);\n  var decoder = protocol.decodeProduceResponse;\n  var self = this;\n  decoder.requireAcks = requireAcks;\n  async.each(payloads, buildRequest, function (err) {\n    if (err) return cb(err);\n    self.send(payloads, encoder, decoder, function (err, result) {\n      if (err) {\n        if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n          self.emit('brokersChanged');\n        }\n\n        cb(err);\n      } else {\n        cb(null, result);\n      }\n    });\n  });\n\n  function buildRequest(payload, cb) {\n    var attributes = payload.attributes;\n    var codec = getCodec(attributes);\n    if (!codec) return cb();\n    var innerSet = encodeMessageSet(payload.messages);\n    codec.encode(innerSet, function (err, message) {\n      if (err) return cb(err);\n      payload.messages = [new Message(0, attributes, '', message)];\n      cb();\n    });\n  }\n};\n\nClient.prototype.sendOffsetCommitRequest = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetCommitRequest(group);\n  var decoder = protocol.decodeOffsetCommitResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\n\nClient.prototype.sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {\n  var encoder = protocol.encodeOffsetCommitV2Request;\n  var decoder = protocol.decodeOffsetCommitResponse;\n  this.sendGroupRequest(encoder, decoder, arguments);\n};\n\nClient.prototype.sendOffsetFetchV1Request = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetFetchV1Request;\n  var decoder = protocol.decodeOffsetFetchV1Response;\n  this.sendGroupRequest(encoder, decoder, arguments);\n};\n\nClient.prototype.setCoordinatorIdAndSendOffsetFetchV1Request = function (group, payloads, cb) {\n  this.sendGroupCoordinatorRequest(group, (err, coordinatorInfo) => {\n    if (err) return cb(new errors.BrokerNotAvailableError('Broker not available'));\n    this.coordinatorId = String(coordinatorInfo.coordinatorId);\n    this.sendOffsetFetchV1Request(group, payloads, cb);\n  });\n};\n\nClient.prototype.sendOffsetFetchRequest = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetFetchRequest(group);\n  var decoder = protocol.decodeOffsetFetchResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\n\nClient.prototype.sendOffsetRequest = function (payloads, cb) {\n  var encoder = protocol.encodeOffsetRequest;\n  var decoder = protocol.decodeOffsetResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\n\nClient.prototype.refreshBrokerMetadata = function () {};\n\nClient.prototype.sendWhenReady = function (broker, correlationId, request, decode, cb) {\n  this.queueCallback(broker.socket, correlationId, [decode, cb]);\n  broker.write(request);\n};\n\nClient.prototype.sendGroupRequest = function (encode, decode, requestArgs) {\n  requestArgs = _.values(requestArgs);\n  var cb = requestArgs.pop();\n  var correlationId = this.nextId();\n  requestArgs.unshift(this.clientId, correlationId);\n  var request = encode.apply(null, requestArgs);\n  var broker = this.brokerForLeader(this.coordinatorId);\n  var brokerError = null;\n\n  if (!broker) {\n    brokerError = 'Could not find broker';\n  } else if (!broker.isConnected()) {\n    brokerError = 'Broker socket is closed' + (broker.socket.error ? ' - ' + broker.socket.error.message : '');\n  }\n\n  if (brokerError) {\n    this.refreshBrokerMetadata();\n    return cb(new errors.BrokerNotAvailableError('Broker not available: ' + brokerError));\n  }\n\n  this.sendWhenReady(broker, correlationId, request, decode, cb);\n};\n\nClient.prototype.sendGroupCoordinatorRequest = function (groupId, cb) {\n  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);\n};\n\nClient.prototype.sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {\n  this.sendGroupRequest(protocol.encodeJoinGroupRequest, protocol.decodeJoinGroupResponse, arguments);\n};\n\nClient.prototype.sendSyncGroupRequest = function (groupId, generationId, memberId, groupAssignment, cb) {\n  this.sendGroupRequest(protocol.encodeSyncGroupRequest, protocol.decodeSyncGroupResponse, arguments);\n};\n\nClient.prototype.sendHeartbeatRequest = function (groupId, generationId, memberId, cb) {\n  this.sendGroupRequest(protocol.encodeGroupHeartbeatRequest, protocol.decodeGroupHeartbeatResponse, arguments);\n};\n\nClient.prototype.sendLeaveGroupRequest = function (groupId, memberId, cb) {\n  this.sendGroupRequest(protocol.encodeLeaveGroupRequest, protocol.decodeLeaveGroupResponse, arguments);\n};\n/*\n *  Helper method\n *  topic in payloads may send to different broker, so we cache data util all request came back\n */\n\n\nfunction wrap(payloads, cb) {\n  var out = {};\n  var count = Object.keys(payloads).length;\n  return function (err, data) {\n    // data: { topicName1: {}, topicName2: {} }\n    if (err) return cb && cb(err);\n\n    _.merge(out, data);\n\n    count -= 1; // Waiting for all request return\n\n    if (count !== 0) return;\n    cb && cb(null, out);\n  };\n}\n/**\n * Fetches metadata information for a topic\n * This includes an array containing a each zookeeper node, their nodeId, host name, and port. As well as an object\n * containing the topic name, partition, leader number, replica count, and in sync replicas per partition.\n *\n * @param {Array} topics An array of topics to load the metadata for\n * @param {Client~loadMetadataForTopicsCallback} cb Function to call once all metadata is loaded\n */\n\n\nClient.prototype.loadMetadataForTopics = function (topics, cb) {\n  var correlationId = this.nextId();\n  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, topics);\n  var broker = this.brokerForLeader();\n\n  if (!broker || !broker.isConnected()) {\n    return cb(new errors.BrokerNotAvailableError('Broker not available'));\n  }\n\n  this.sendWhenReady(broker, correlationId, request, protocol.decodeMetadataResponse, cb);\n};\n\nClient.prototype.createTopics = function (topics, isAsync, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n\n  if (typeof isAsync === 'function' && typeof cb === 'undefined') {\n    cb = isAsync;\n    isAsync = true;\n  }\n\n  try {\n    validateKafkaTopics(topics);\n  } catch (e) {\n    if (isAsync) return cb(e);\n    throw e;\n  }\n\n  cb = _.once(cb);\n\n  const getTopicsFromKafka = (topics, callback) => {\n    this.loadMetadataForTopics(topics, function (error, resp) {\n      if (error) {\n        return callback(error);\n      }\n\n      callback(null, Object.keys(resp[1].metadata));\n    });\n  };\n\n  const operation = retry.operation({\n    minTimeout: 200,\n    maxTimeout: 2000\n  });\n  operation.attempt(currentAttempt => {\n    logger.debug('create topics currentAttempt', currentAttempt);\n    getTopicsFromKafka(topics, function (error, kafkaTopics) {\n      if (error) {\n        if (operation.retry(error)) {\n          return;\n        }\n      }\n\n      logger.debug('kafka reported topics', kafkaTopics);\n\n      const left = _.difference(topics, kafkaTopics);\n\n      if (left.length === 0) {\n        logger.debug(`Topics created ${kafkaTopics}`);\n        return cb(null, kafkaTopics);\n      }\n\n      logger.debug(`Topics left ${left.join(', ')}`);\n\n      if (!operation.retry(new Error(`Topics not created ${left}`))) {\n        cb(operation.mainError());\n      }\n    });\n  });\n\n  if (!isAsync) {\n    cb(null);\n  }\n};\n\nClient.prototype.addTopics = function (topics, cb) {\n  var self = this;\n  this.topicExists(topics, function (err) {\n    if (err) return cb(err);\n    self.loadMetadataForTopics(topics, function (err, resp) {\n      if (err) return cb(err);\n      self.updateMetadatas(resp);\n      cb(null, topics);\n    });\n  });\n};\n\nClient.prototype.nextId = function () {\n  if (this.correlationId >= MAX_INT32) {\n    this.correlationId = 0;\n  }\n\n  return this.correlationId++;\n};\n\nClient.prototype.nextSocketId = function () {\n  return this._socketId++;\n};\n\nClient.prototype.refreshBrokers = function () {\n  var self = this;\n  var validBrokers = Object.keys(this.brokerProfiles);\n\n  function closeDeadBrokers(brokers) {\n    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);\n\n    if (deadBrokerKeys.length) {\n      self.closeBrokers(deadBrokerKeys.map(function (key) {\n        var broker = brokers[key];\n        delete brokers[key];\n        return broker;\n      }));\n    }\n  }\n\n  closeDeadBrokers(this.brokers);\n  closeDeadBrokers(this.longpollingBrokers);\n};\n\nClient.prototype.refreshMetadata = function (topicNames, cb) {\n  var self = this;\n  if (!topicNames.length) return cb();\n  attemptRequestMetadata(topicNames, cb);\n\n  function attemptRequestMetadata(topics, cb) {\n    var operation = retry.operation({\n      minTimeout: 200,\n      maxTimeout: 1000\n    });\n    operation.attempt(function (currentAttempt) {\n      logger.debug('refresh metadata currentAttempt', currentAttempt);\n      self.loadMetadataForTopics(topics, function (err, resp) {\n        err = err || resp[1].error;\n\n        if (Array.isArray(err)) {\n          err = new Error(String(err));\n        }\n\n        if (operation.retry(err)) {\n          return;\n        }\n\n        if (err) {\n          logger.debug('refresh metadata error', err.message);\n          return cb(err);\n        }\n\n        self.updateMetadatas(resp);\n        cb();\n      });\n    });\n  }\n};\n\nClient.prototype.send = function (payloads, encoder, decoder, cb) {\n  var self = this;\n  var _payloads = payloads; // payloads: [ [metadata exists], [metadata not exists] ]\n\n  payloads = this.checkMetadatas(payloads);\n\n  if (payloads[0].length && !payloads[1].length) {\n    this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);\n    return;\n  }\n\n  if (payloads[1].length) {\n    var topicNames = payloads[1].map(function (p) {\n      return p.topic;\n    });\n    this.loadMetadataForTopics(topicNames, function (err, resp) {\n      if (err) {\n        return cb(err);\n      }\n\n      var error = resp[1].error;\n\n      if (error) {\n        return cb(error);\n      }\n\n      self.updateMetadatas(resp); // check payloads again\n\n      payloads = self.checkMetadatas(_payloads);\n\n      if (payloads[1].length) {\n        self.refreshBrokerMetadata();\n        return cb(new errors.BrokerNotAvailableError('Could not find the leader'));\n      }\n\n      self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);\n    });\n  }\n};\n\nClient.prototype.sendToBroker = function (payloads, encoder, decoder, cb) {\n  var longpolling = encoder.name === 'encodeFetchRequest';\n  payloads = this.payloadsByLeader(payloads);\n\n  if (!longpolling) {\n    cb = wrap(payloads, cb);\n  }\n\n  for (var leader in payloads) {\n    if (!payloads.hasOwnProperty(leader)) {\n      continue;\n    }\n\n    var correlationId = this.nextId();\n    var broker = this.brokerForLeader(leader, longpolling);\n    var brokerError = null;\n\n    if (!broker) {\n      brokerError = 'Could not find broker';\n    } else if (!broker.isConnected()) {\n      brokerError = 'Broker socket is closed' + (broker.socket.error ? ' - ' + broker.socket.error.message : '');\n    }\n\n    if (brokerError) {\n      this.refreshBrokerMetadata();\n      return cb(new errors.BrokerNotAvailableError('Broker not available: ' + brokerError), payloads[leader]);\n    }\n\n    if (longpolling) {\n      if (broker.socket.waiting) {\n        continue;\n      }\n\n      broker.socket.waiting = true;\n    }\n\n    var request = encoder(this.clientId, correlationId, payloads[leader]);\n\n    if (decoder.requireAcks === 0) {\n      broker.writeAsync(request);\n      cb(null, {\n        result: 'no ack'\n      });\n    } else {\n      this.sendWhenReady(broker, correlationId, request, decoder, cb);\n    }\n  }\n};\n\nClient.prototype.checkMetadatas = function (payloads) {\n  if (_.isEmpty(this.topicMetadata)) return [[], payloads]; // out: [ [metadata exists], [metadata not exists] ]\n\n  var out = [[], []];\n  payloads.forEach(function (p) {\n    if (this.hasMetadata(p.topic, p.partition)) out[0].push(p);else out[1].push(p);\n  }.bind(this));\n  return out;\n};\n\nClient.prototype.hasMetadata = function (topic, partition) {\n  var brokerMetadata = this.brokerMetadata;\n  var leader = this.leaderByPartition(topic, partition);\n  return leader !== undefined && brokerMetadata[leader];\n};\n\nClient.prototype.updateMetadatas = function (metadatas) {\n  // _.extend(this.brokerMetadata, metadatas[0])\n  _.extend(this.topicMetadata, metadatas[1].metadata);\n\n  for (var topic in this.topicMetadata) {\n    if (!this.topicMetadata.hasOwnProperty(topic)) {\n      continue;\n    }\n\n    this.topicPartitions[topic] = Object.keys(this.topicMetadata[topic]).map(function (val) {\n      return parseInt(val, 10);\n    });\n  }\n};\n\nClient.prototype.removeTopicMetadata = function (topics, cb) {\n  topics.forEach(function (t) {\n    if (this.topicMetadata[t]) delete this.topicMetadata[t];\n  }.bind(this));\n  cb(null, topics.length);\n};\n\nClient.prototype.payloadsByLeader = function (payloads) {\n  return payloads.reduce(function (out, p) {\n    var leader = this.leaderByPartition(p.topic, p.partition);\n    out[leader] = out[leader] || [];\n    out[leader].push(p);\n    return out;\n  }.bind(this), {});\n};\n\nClient.prototype.leaderByPartition = function (topic, partition) {\n  var topicMetadata = this.topicMetadata;\n  return topicMetadata[topic] && topicMetadata[topic][partition] && topicMetadata[topic][partition].leader;\n};\n\nClient.prototype.brokerForLeader = function (leader, longpolling) {\n  var addr;\n  var brokers = this.getBrokers(longpolling); // If leader is not give, choose the first broker as leader\n\n  if (typeof leader === 'undefined') {\n    if (!_.isEmpty(brokers)) {\n      addr = Object.keys(brokers)[0];\n      return brokers[addr];\n    } else if (!_.isEmpty(this.brokerMetadata)) {\n      leader = Object.keys(this.brokerMetadata)[0];\n    } else {\n      return;\n    }\n  }\n\n  var broker = _.find(this.brokerProfiles, {\n    id: leader\n  });\n\n  if (!broker) {\n    return;\n  }\n\n  addr = broker.host + ':' + broker.port;\n  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers);\n};\n\nClient.prototype.getBrokers = function (longpolling) {\n  return longpolling ? this.longpollingBrokers : this.brokers;\n};\n\nClient.prototype.reconnectBroker = function (oldSocket) {\n  oldSocket.retrying = false;\n\n  if (oldSocket.error) {\n    oldSocket.destroy();\n  }\n\n  var brokers = this.getBrokers(oldSocket.longpolling);\n  var newBroker = this.setupBroker(oldSocket.host, oldSocket.port, oldSocket.longpolling, brokers);\n  newBroker.socket.error = oldSocket.error;\n};\n\nClient.prototype.handleReceivedData = function (socket) {\n  var buffer = socket.buffer;\n\n  if (!buffer.length || buffer.length < 4) {\n    return;\n  }\n\n  var size = buffer.readUInt32BE(0) + 4;\n\n  if (buffer.length >= size) {\n    if (socket.longpolling) {\n      socket.waiting = false;\n    }\n\n    var resp = buffer.shallowSlice(0, size);\n    var correlationId = resp.readUInt32BE(4);\n    this.invokeResponseCallback(socket, correlationId, resp);\n    buffer.consume(size);\n  } else {\n    return;\n  }\n\n  if (socket.buffer.length) {\n    setImmediate(function () {\n      this.handleReceivedData(socket);\n    }.bind(this));\n  }\n};\n\nClient.prototype.invokeResponseCallback = function (socket, correlationId, resp) {\n  var handlers = this.unqueueCallback(socket, correlationId);\n\n  if (handlers) {\n    var [decoder, cb] = handlers;\n    var result = decoder(resp);\n\n    if (result instanceof Error) {\n      cb.call(this, result);\n    } else {\n      cb.call(this, null, result);\n    }\n  } else {\n    logger.error(`missing handlers for Correlation ID: ${correlationId}`);\n  }\n};\n\nClient.prototype.queueCallback = function (socket, id, data) {\n  var socketId = socket.socketId;\n  var queue = this.cbqueue.get(socketId);\n\n  if (!queue) {\n    queue = new Map();\n    this.cbqueue.set(socketId, queue);\n  }\n\n  queue.set(id, data);\n};\n\nClient.prototype.unqueueCallback = function (socket, id) {\n  var socketId = socket.socketId;\n  var queue = this.cbqueue.get(socketId);\n\n  try {\n    if (!queue) {\n      return null;\n    }\n\n    if (!queue.has(id)) {\n      return null;\n    }\n\n    var result = queue.get(id); // cleanup socket queue\n\n    queue.delete(id);\n    return result;\n  } finally {\n    if (queue && !queue.size) {\n      this.cbqueue.delete(socketId);\n    }\n  }\n};\n\nClient.prototype.clearCallbackQueue = function (socket, error) {\n  var socketId = socket.socketId;\n  var longpolling = socket.longpolling;\n  var queue = this.cbqueue.get(socketId);\n\n  if (!queue) {\n    return;\n  }\n\n  if (!longpolling) {\n    queue.forEach(function (handlers) {\n      var cb = handlers[1];\n      cb(error);\n    });\n  }\n\n  this.cbqueue.delete(socketId);\n};\n\nmodule.exports = Client;","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/kafka-node/lib/baseClient.js"],"names":["util","require","_","async","retry","EventEmitter","errors","getCodec","protocol","encodeMessageSet","Message","logger","validateKafkaTopics","validateTopicNames","MAX_INT32","Client","TypeError","inherits","prototype","closeBrokers","brokers","each","broker","socket","closing","end","setImmediate","destroy","unref","decodeValue","encoding","value","toString","_createMessageHandler","consumer","stateValidator","err","type","message","emit","options","keyEncoding","key","sendFetchRequest","payloads","fetchMaxWaitMs","fetchMinBytes","maxTickMessages","encoder","encodeFetchRequest","decoder","decodeFetchResponse","send","Array","unshift","call","arguments","apply","sendProduceRequest","requireAcks","ackTimeoutMs","cb","encodeProduceRequest","decodeProduceResponse","self","buildRequest","result","payload","attributes","codec","innerSet","messages","encode","sendOffsetCommitRequest","group","encodeOffsetCommitRequest","decodeOffsetCommitResponse","sendOffsetCommitV2Request","generationId","memberId","encodeOffsetCommitV2Request","sendGroupRequest","sendOffsetFetchV1Request","encodeOffsetFetchV1Request","decodeOffsetFetchV1Response","setCoordinatorIdAndSendOffsetFetchV1Request","sendGroupCoordinatorRequest","coordinatorInfo","BrokerNotAvailableError","coordinatorId","String","sendOffsetFetchRequest","encodeOffsetFetchRequest","decodeOffsetFetchResponse","sendOffsetRequest","encodeOffsetRequest","decodeOffsetResponse","refreshBrokerMetadata","sendWhenReady","correlationId","request","decode","queueCallback","write","requestArgs","values","pop","nextId","clientId","brokerForLeader","brokerError","isConnected","error","groupId","encodeGroupCoordinatorRequest","decodeGroupCoordinatorResponse","sendJoinGroupRequest","sessionTimeout","groupProtocol","encodeJoinGroupRequest","decodeJoinGroupResponse","sendSyncGroupRequest","groupAssignment","encodeSyncGroupRequest","decodeSyncGroupResponse","sendHeartbeatRequest","encodeGroupHeartbeatRequest","decodeGroupHeartbeatResponse","sendLeaveGroupRequest","encodeLeaveGroupRequest","decodeLeaveGroupResponse","wrap","out","count","Object","keys","length","data","merge","loadMetadataForTopics","topics","encodeMetadataRequest","decodeMetadataResponse","createTopics","isAsync","e","once","getTopicsFromKafka","callback","resp","metadata","operation","minTimeout","maxTimeout","attempt","currentAttempt","debug","kafkaTopics","left","difference","join","Error","mainError","addTopics","topicExists","updateMetadatas","nextSocketId","_socketId","refreshBrokers","validBrokers","brokerProfiles","closeDeadBrokers","deadBrokerKeys","map","longpollingBrokers","refreshMetadata","topicNames","attemptRequestMetadata","isArray","_payloads","checkMetadatas","sendToBroker","flatten","p","topic","concat","longpolling","name","payloadsByLeader","leader","hasOwnProperty","waiting","writeAsync","isEmpty","topicMetadata","forEach","hasMetadata","partition","push","bind","brokerMetadata","leaderByPartition","undefined","metadatas","extend","topicPartitions","val","parseInt","removeTopicMetadata","t","reduce","addr","getBrokers","find","id","host","port","setupBroker","reconnectBroker","oldSocket","retrying","newBroker","handleReceivedData","buffer","size","readUInt32BE","shallowSlice","invokeResponseCallback","consume","handlers","unqueueCallback","socketId","queue","cbqueue","get","Map","set","has","delete","clearCallbackQueue","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,CAAC,GAAGD,OAAO,CAAC,QAAD,CAAf;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAII,YAAY,GAAGJ,OAAO,CAAC,QAAD,CAA1B;;AACA,IAAIK,MAAM,GAAGL,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIM,QAAQ,GAAGN,OAAO,CAAC,SAAD,CAAtB;;AACA,IAAIO,QAAQ,GAAGP,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIQ,gBAAgB,GAAGD,QAAQ,CAACC,gBAAhC;AACA,IAAIC,OAAO,GAAGF,QAAQ,CAACE,OAAvB;;AACA,IAAIC,MAAM,GAAGV,OAAO,CAAC,WAAD,CAAP,CAAqB,uBAArB,CAAb;;AACA,IAAIW,mBAAmB,GAAGX,OAAO,CAAC,SAAD,CAAP,CAAmBY,kBAA7C;;AAEA,MAAMC,SAAS,GAAG,UAAlB;AAEA;AACA;AACA;AACA;;AACA,SAASC,MAAT,GAAmB;AACjB,QAAM,IAAIC,SAAJ,CAAc,4CAAd,CAAN;AACD;;AAEDhB,IAAI,CAACiB,QAAL,CAAcF,MAAd,EAAsBV,YAAtB;;AAEAU,MAAM,CAACG,SAAP,CAAiBC,YAAjB,GAAgC,UAAUC,OAAV,EAAmB;AACjDlB,EAAAA,CAAC,CAACmB,IAAF,CAAOD,OAAP,EAAgB,UAAUE,MAAV,EAAkB;AAChCA,IAAAA,MAAM,CAACC,MAAP,CAAcC,OAAd,GAAwB,IAAxB;AACAF,IAAAA,MAAM,CAACC,MAAP,CAAcE,GAAd;AACAC,IAAAA,YAAY,CAAC,YAAY;AACvBJ,MAAAA,MAAM,CAACC,MAAP,CAAcI,OAAd;AACAL,MAAAA,MAAM,CAACC,MAAP,CAAcK,KAAd;AACD,KAHW,CAAZ;AAID,GAPD;AAQD,CATD;;AAWA,SAASC,WAAT,CAAsBC,QAAtB,EAAgCC,KAAhC,EAAuC;AACrC,MAAID,QAAQ,KAAK,QAAb,IAAyBC,KAAK,IAAI,IAAtC,EAA4C;AAC1C,WAAOA,KAAK,CAACC,QAAN,CAAeF,QAAf,CAAP;AACD;;AACD,SAAOC,KAAP;AACD;;AAEDhB,MAAM,CAACG,SAAP,CAAiBe,qBAAjB,GAAyC,UAAUC,QAAV,EAAoBC,cAApB,EAAoC;AAC3E,SAAO,CAACC,GAAD,EAAMC,IAAN,EAAYC,OAAZ,KAAwB;AAC7B,QAAIH,cAAc,IAAI,CAACA,cAAc,CAACC,GAAD,EAAMC,IAAN,EAAYC,OAAZ,CAArC,EAA2D;AACzD;AACD;;AACD,QAAIF,GAAJ,EAAS;AACP,UAAIA,GAAG,CAACE,OAAJ,KAAgB,kBAApB,EAAwC;AACtC,eAAOJ,QAAQ,CAACK,IAAT,CAAc,kBAAd,EAAkCH,GAAlC,CAAP;AACD,OAFD,MAEO,IAAIA,GAAG,CAACE,OAAJ,KAAgB,uBAAhB,IAA2CF,GAAG,CAACE,OAAJ,KAAgB,yBAA/D,EAA0F;AAC/F,eAAO,KAAKC,IAAL,CAAU,gBAAV,CAAP;AACD;;AAED,aAAOL,QAAQ,CAACK,IAAT,CAAc,OAAd,EAAuBH,GAAvB,CAAP;AACD;;AAED,QAAIN,QAAQ,GAAGI,QAAQ,CAACM,OAAT,CAAiBV,QAAhC;AACA,UAAMW,WAAW,GAAGP,QAAQ,CAACM,OAAT,CAAiBC,WAArC;;AAEA,QAAIJ,IAAI,KAAK,SAAb,EAAwB;AACtBC,MAAAA,OAAO,CAACP,KAAR,GAAgBF,WAAW,CAACC,QAAD,EAAWQ,OAAO,CAACP,KAAnB,CAA3B;AACAO,MAAAA,OAAO,CAACI,GAAR,GAAcb,WAAW,CAACY,WAAW,IAAIX,QAAhB,EAA0BQ,OAAO,CAACI,GAAlC,CAAzB;AAEAR,MAAAA,QAAQ,CAACK,IAAT,CAAc,SAAd,EAAyBD,OAAzB;AACD,KALD,MAKO;AACLJ,MAAAA,QAAQ,CAACK,IAAT,CAAcF,IAAd,EAAoBC,OAApB;AACD;AACF,GAzBD;AA0BD,CA3BD;;AA6BAvB,MAAM,CAACG,SAAP,CAAiByB,gBAAjB,GAAoC,UAAUT,QAAV,EAAoBU,QAApB,EAA8BC,cAA9B,EAA8CC,aAA9C,EAA6DC,eAA7D,EAA8E;AAChH,MAAIC,OAAO,GAAGxC,QAAQ,CAACyC,kBAAT,CAA4BJ,cAA5B,EAA4CC,aAA5C,CAAd,CADgH,CAEhH;;AACA,MAAII,OAAO,GAAG1C,QAAQ,CAAC2C,mBAAT,CAA6B,KAAKlB,qBAAL,CAA2BC,QAA3B,CAA7B,EAAmEa,eAAnE,CAAd;AAEA,OAAKK,IAAL,CAAUR,QAAV,EAAoBI,OAApB,EAA6BE,OAA7B,EAAsC,UAAUd,GAAV,EAAe;AACnD,QAAIA,GAAJ,EAAS;AACPiB,MAAAA,KAAK,CAACnC,SAAN,CAAgBoC,OAAhB,CAAwBC,IAAxB,CAA6BC,SAA7B,EAAwC,OAAxC;AACAtB,MAAAA,QAAQ,CAACK,IAAT,CAAckB,KAAd,CAAoBvB,QAApB,EAA8BsB,SAA9B;AACD;AACF,GALD;AAMD,CAXD;;AAaAzC,MAAM,CAACG,SAAP,CAAiBwC,kBAAjB,GAAsC,UAAUd,QAAV,EAAoBe,WAApB,EAAiCC,YAAjC,EAA+CC,EAA/C,EAAmD;AACvF,MAAIb,OAAO,GAAGxC,QAAQ,CAACsD,oBAAT,CAA8BH,WAA9B,EAA2CC,YAA3C,CAAd;AACA,MAAIV,OAAO,GAAG1C,QAAQ,CAACuD,qBAAvB;AACA,MAAIC,IAAI,GAAG,IAAX;AAEAd,EAAAA,OAAO,CAACS,WAAR,GAAsBA,WAAtB;AAEAxD,EAAAA,KAAK,CAACkB,IAAN,CAAWuB,QAAX,EAAqBqB,YAArB,EAAmC,UAAU7B,GAAV,EAAe;AAChD,QAAIA,GAAJ,EAAS,OAAOyB,EAAE,CAACzB,GAAD,CAAT;AACT4B,IAAAA,IAAI,CAACZ,IAAL,CAAUR,QAAV,EAAoBI,OAApB,EAA6BE,OAA7B,EAAsC,UAAUd,GAAV,EAAe8B,MAAf,EAAuB;AAC3D,UAAI9B,GAAJ,EAAS;AACP,YAAIA,GAAG,CAACE,OAAJ,KAAgB,uBAAhB,IAA2CF,GAAG,CAACE,OAAJ,KAAgB,yBAA/D,EAA0F;AACxF0B,UAAAA,IAAI,CAACzB,IAAL,CAAU,gBAAV;AACD;;AACDsB,QAAAA,EAAE,CAACzB,GAAD,CAAF;AACD,OALD,MAKO;AACLyB,QAAAA,EAAE,CAAC,IAAD,EAAOK,MAAP,CAAF;AACD;AACF,KATD;AAUD,GAZD;;AAcA,WAASD,YAAT,CAAuBE,OAAvB,EAAgCN,EAAhC,EAAoC;AAClC,QAAIO,UAAU,GAAGD,OAAO,CAACC,UAAzB;AACA,QAAIC,KAAK,GAAG9D,QAAQ,CAAC6D,UAAD,CAApB;AAEA,QAAI,CAACC,KAAL,EAAY,OAAOR,EAAE,EAAT;AAEZ,QAAIS,QAAQ,GAAG7D,gBAAgB,CAAC0D,OAAO,CAACI,QAAT,CAA/B;AACAF,IAAAA,KAAK,CAACG,MAAN,CAAaF,QAAb,EAAuB,UAAUlC,GAAV,EAAeE,OAAf,EAAwB;AAC7C,UAAIF,GAAJ,EAAS,OAAOyB,EAAE,CAACzB,GAAD,CAAT;AACT+B,MAAAA,OAAO,CAACI,QAAR,GAAmB,CAAC,IAAI7D,OAAJ,CAAY,CAAZ,EAAe0D,UAAf,EAA2B,EAA3B,EAA+B9B,OAA/B,CAAD,CAAnB;AACAuB,MAAAA,EAAE;AACH,KAJD;AAKD;AACF,CAlCD;;AAoCA9C,MAAM,CAACG,SAAP,CAAiBuD,uBAAjB,GAA2C,UAAUC,KAAV,EAAiB9B,QAAjB,EAA2BiB,EAA3B,EAA+B;AACxE,MAAIb,OAAO,GAAGxC,QAAQ,CAACmE,yBAAT,CAAmCD,KAAnC,CAAd;AACA,MAAIxB,OAAO,GAAG1C,QAAQ,CAACoE,0BAAvB;AACA,OAAKxB,IAAL,CAAUR,QAAV,EAAoBI,OAApB,EAA6BE,OAA7B,EAAsCW,EAAtC;AACD,CAJD;;AAMA9C,MAAM,CAACG,SAAP,CAAiB2D,yBAAjB,GAA6C,UAAUH,KAAV,EAAiBI,YAAjB,EAA+BC,QAA/B,EAAyCnC,QAAzC,EAAmDiB,EAAnD,EAAuD;AAClG,MAAIb,OAAO,GAAGxC,QAAQ,CAACwE,2BAAvB;AACA,MAAI9B,OAAO,GAAG1C,QAAQ,CAACoE,0BAAvB;AACA,OAAKK,gBAAL,CAAsBjC,OAAtB,EAA+BE,OAA/B,EAAwCM,SAAxC;AACD,CAJD;;AAMAzC,MAAM,CAACG,SAAP,CAAiBgE,wBAAjB,GAA4C,UAAUR,KAAV,EAAiB9B,QAAjB,EAA2BiB,EAA3B,EAA+B;AACzE,MAAIb,OAAO,GAAGxC,QAAQ,CAAC2E,0BAAvB;AACA,MAAIjC,OAAO,GAAG1C,QAAQ,CAAC4E,2BAAvB;AACA,OAAKH,gBAAL,CAAsBjC,OAAtB,EAA+BE,OAA/B,EAAwCM,SAAxC;AACD,CAJD;;AAMAzC,MAAM,CAACG,SAAP,CAAiBmE,2CAAjB,GAA+D,UAAUX,KAAV,EAAiB9B,QAAjB,EAA2BiB,EAA3B,EAA+B;AAC5F,OAAKyB,2BAAL,CAAiCZ,KAAjC,EAAwC,CAACtC,GAAD,EAAMmD,eAAN,KAA0B;AAChE,QAAInD,GAAJ,EAAS,OAAOyB,EAAE,CAAC,IAAIvD,MAAM,CAACkF,uBAAX,CAAmC,sBAAnC,CAAD,CAAT;AACT,SAAKC,aAAL,GAAqBC,MAAM,CAACH,eAAe,CAACE,aAAjB,CAA3B;AACA,SAAKP,wBAAL,CAA8BR,KAA9B,EAAqC9B,QAArC,EAA+CiB,EAA/C;AACD,GAJD;AAKD,CAND;;AAQA9C,MAAM,CAACG,SAAP,CAAiByE,sBAAjB,GAA0C,UAAUjB,KAAV,EAAiB9B,QAAjB,EAA2BiB,EAA3B,EAA+B;AACvE,MAAIb,OAAO,GAAGxC,QAAQ,CAACoF,wBAAT,CAAkClB,KAAlC,CAAd;AACA,MAAIxB,OAAO,GAAG1C,QAAQ,CAACqF,yBAAvB;AACA,OAAKzC,IAAL,CAAUR,QAAV,EAAoBI,OAApB,EAA6BE,OAA7B,EAAsCW,EAAtC;AACD,CAJD;;AAMA9C,MAAM,CAACG,SAAP,CAAiB4E,iBAAjB,GAAqC,UAAUlD,QAAV,EAAoBiB,EAApB,EAAwB;AAC3D,MAAIb,OAAO,GAAGxC,QAAQ,CAACuF,mBAAvB;AACA,MAAI7C,OAAO,GAAG1C,QAAQ,CAACwF,oBAAvB;AACA,OAAK5C,IAAL,CAAUR,QAAV,EAAoBI,OAApB,EAA6BE,OAA7B,EAAsCW,EAAtC;AACD,CAJD;;AAMA9C,MAAM,CAACG,SAAP,CAAiB+E,qBAAjB,GAAyC,YAAY,CAAE,CAAvD;;AAEAlF,MAAM,CAACG,SAAP,CAAiBgF,aAAjB,GAAiC,UAAU5E,MAAV,EAAkB6E,aAAlB,EAAiCC,OAAjC,EAA0CC,MAA1C,EAAkDxC,EAAlD,EAAsD;AACrF,OAAKyC,aAAL,CAAmBhF,MAAM,CAACC,MAA1B,EAAkC4E,aAAlC,EAAiD,CAACE,MAAD,EAASxC,EAAT,CAAjD;AACAvC,EAAAA,MAAM,CAACiF,KAAP,CAAaH,OAAb;AACD,CAHD;;AAKArF,MAAM,CAACG,SAAP,CAAiB+D,gBAAjB,GAAoC,UAAUT,MAAV,EAAkB6B,MAAlB,EAA0BG,WAA1B,EAAuC;AACzEA,EAAAA,WAAW,GAAGtG,CAAC,CAACuG,MAAF,CAASD,WAAT,CAAd;AACA,MAAI3C,EAAE,GAAG2C,WAAW,CAACE,GAAZ,EAAT;AACA,MAAIP,aAAa,GAAG,KAAKQ,MAAL,EAApB;AAEAH,EAAAA,WAAW,CAAClD,OAAZ,CAAoB,KAAKsD,QAAzB,EAAmCT,aAAnC;AAEA,MAAIC,OAAO,GAAG5B,MAAM,CAACf,KAAP,CAAa,IAAb,EAAmB+C,WAAnB,CAAd;AACA,MAAIlF,MAAM,GAAG,KAAKuF,eAAL,CAAqB,KAAKpB,aAA1B,CAAb;AACA,MAAIqB,WAAW,GAAG,IAAlB;;AACA,MAAI,CAACxF,MAAL,EAAa;AACXwF,IAAAA,WAAW,GAAG,uBAAd;AACD,GAFD,MAEO,IAAI,CAACxF,MAAM,CAACyF,WAAP,EAAL,EAA2B;AAChCD,IAAAA,WAAW,GAAG,6BAA6BxF,MAAM,CAACC,MAAP,CAAcyF,KAAd,GAAsB,QAAQ1F,MAAM,CAACC,MAAP,CAAcyF,KAAd,CAAoB1E,OAAlD,GAA4D,EAAzF,CAAd;AACD;;AACD,MAAIwE,WAAJ,EAAiB;AACf,SAAKb,qBAAL;AACA,WAAOpC,EAAE,CAAC,IAAIvD,MAAM,CAACkF,uBAAX,CAAmC,2BAA2BsB,WAA9D,CAAD,CAAT;AACD;;AAED,OAAKZ,aAAL,CAAmB5E,MAAnB,EAA2B6E,aAA3B,EAA0CC,OAA1C,EAAmDC,MAAnD,EAA2DxC,EAA3D;AACD,CArBD;;AAuBA9C,MAAM,CAACG,SAAP,CAAiBoE,2BAAjB,GAA+C,UAAU2B,OAAV,EAAmBpD,EAAnB,EAAuB;AACpE,OAAKoB,gBAAL,CAAsBzE,QAAQ,CAAC0G,6BAA/B,EAA8D1G,QAAQ,CAAC2G,8BAAvE,EAAuG3D,SAAvG;AACD,CAFD;;AAIAzC,MAAM,CAACG,SAAP,CAAiBkG,oBAAjB,GAAwC,UAAUH,OAAV,EAAmBlC,QAAnB,EAA6BsC,cAA7B,EAA6CC,aAA7C,EAA4DzD,EAA5D,EAAgE;AACtG,OAAKoB,gBAAL,CAAsBzE,QAAQ,CAAC+G,sBAA/B,EAAuD/G,QAAQ,CAACgH,uBAAhE,EAAyFhE,SAAzF;AACD,CAFD;;AAIAzC,MAAM,CAACG,SAAP,CAAiBuG,oBAAjB,GAAwC,UAAUR,OAAV,EAAmBnC,YAAnB,EAAiCC,QAAjC,EAA2C2C,eAA3C,EAA4D7D,EAA5D,EAAgE;AACtG,OAAKoB,gBAAL,CAAsBzE,QAAQ,CAACmH,sBAA/B,EAAuDnH,QAAQ,CAACoH,uBAAhE,EAAyFpE,SAAzF;AACD,CAFD;;AAIAzC,MAAM,CAACG,SAAP,CAAiB2G,oBAAjB,GAAwC,UAAUZ,OAAV,EAAmBnC,YAAnB,EAAiCC,QAAjC,EAA2ClB,EAA3C,EAA+C;AACrF,OAAKoB,gBAAL,CAAsBzE,QAAQ,CAACsH,2BAA/B,EAA4DtH,QAAQ,CAACuH,4BAArE,EAAmGvE,SAAnG;AACD,CAFD;;AAIAzC,MAAM,CAACG,SAAP,CAAiB8G,qBAAjB,GAAyC,UAAUf,OAAV,EAAmBlC,QAAnB,EAA6BlB,EAA7B,EAAiC;AACxE,OAAKoB,gBAAL,CAAsBzE,QAAQ,CAACyH,uBAA/B,EAAwDzH,QAAQ,CAAC0H,wBAAjE,EAA2F1E,SAA3F;AACD,CAFD;AAIA;AACA;AACA;AACA;;;AACA,SAAS2E,IAAT,CAAevF,QAAf,EAAyBiB,EAAzB,EAA6B;AAC3B,MAAIuE,GAAG,GAAG,EAAV;AACA,MAAIC,KAAK,GAAGC,MAAM,CAACC,IAAP,CAAY3F,QAAZ,EAAsB4F,MAAlC;AAEA,SAAO,UAAUpG,GAAV,EAAeqG,IAAf,EAAqB;AAC1B;AACA,QAAIrG,GAAJ,EAAS,OAAOyB,EAAE,IAAIA,EAAE,CAACzB,GAAD,CAAf;;AACTlC,IAAAA,CAAC,CAACwI,KAAF,CAAQN,GAAR,EAAaK,IAAb;;AACAJ,IAAAA,KAAK,IAAI,CAAT,CAJ0B,CAK1B;;AACA,QAAIA,KAAK,KAAK,CAAd,EAAiB;AACjBxE,IAAAA,EAAE,IAAIA,EAAE,CAAC,IAAD,EAAOuE,GAAP,CAAR;AACD,GARD;AASD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACArH,MAAM,CAACG,SAAP,CAAiByH,qBAAjB,GAAyC,UAAUC,MAAV,EAAkB/E,EAAlB,EAAsB;AAC7D,MAAIsC,aAAa,GAAG,KAAKQ,MAAL,EAApB;AACA,MAAIP,OAAO,GAAG5F,QAAQ,CAACqI,qBAAT,CAA+B,KAAKjC,QAApC,EAA8CT,aAA9C,EAA6DyC,MAA7D,CAAd;AACA,MAAItH,MAAM,GAAG,KAAKuF,eAAL,EAAb;;AAEA,MAAI,CAACvF,MAAD,IAAW,CAACA,MAAM,CAACyF,WAAP,EAAhB,EAAsC;AACpC,WAAOlD,EAAE,CAAC,IAAIvD,MAAM,CAACkF,uBAAX,CAAmC,sBAAnC,CAAD,CAAT;AACD;;AAED,OAAKU,aAAL,CAAmB5E,MAAnB,EAA2B6E,aAA3B,EAA0CC,OAA1C,EAAmD5F,QAAQ,CAACsI,sBAA5D,EAAoFjF,EAApF;AACD,CAVD;;AAYA9C,MAAM,CAACG,SAAP,CAAiB6H,YAAjB,GAAgC,UAAUH,MAAV,EAAkBI,OAAlB,EAA2BnF,EAA3B,EAA+B;AAC7D+E,EAAAA,MAAM,GAAG,OAAOA,MAAP,KAAkB,QAAlB,GAA6B,CAACA,MAAD,CAA7B,GAAwCA,MAAjD;;AAEA,MAAI,OAAOI,OAAP,KAAmB,UAAnB,IAAiC,OAAOnF,EAAP,KAAc,WAAnD,EAAgE;AAC9DA,IAAAA,EAAE,GAAGmF,OAAL;AACAA,IAAAA,OAAO,GAAG,IAAV;AACD;;AAED,MAAI;AACFpI,IAAAA,mBAAmB,CAACgI,MAAD,CAAnB;AACD,GAFD,CAEE,OAAOK,CAAP,EAAU;AACV,QAAID,OAAJ,EAAa,OAAOnF,EAAE,CAACoF,CAAD,CAAT;AACb,UAAMA,CAAN;AACD;;AAEDpF,EAAAA,EAAE,GAAG3D,CAAC,CAACgJ,IAAF,CAAOrF,EAAP,CAAL;;AAEA,QAAMsF,kBAAkB,GAAG,CAACP,MAAD,EAASQ,QAAT,KAAsB;AAC/C,SAAKT,qBAAL,CAA2BC,MAA3B,EAAmC,UAAU5B,KAAV,EAAiBqC,IAAjB,EAAuB;AACxD,UAAIrC,KAAJ,EAAW;AACT,eAAOoC,QAAQ,CAACpC,KAAD,CAAf;AACD;;AACDoC,MAAAA,QAAQ,CAAC,IAAD,EAAOd,MAAM,CAACC,IAAP,CAAYc,IAAI,CAAC,CAAD,CAAJ,CAAQC,QAApB,CAAP,CAAR;AACD,KALD;AAMD,GAPD;;AASA,QAAMC,SAAS,GAAGnJ,KAAK,CAACmJ,SAAN,CAAgB;AAAEC,IAAAA,UAAU,EAAE,GAAd;AAAmBC,IAAAA,UAAU,EAAE;AAA/B,GAAhB,CAAlB;AAEAF,EAAAA,SAAS,CAACG,OAAV,CAAkBC,cAAc,IAAI;AAClChJ,IAAAA,MAAM,CAACiJ,KAAP,CAAa,8BAAb,EAA6CD,cAA7C;AACAR,IAAAA,kBAAkB,CAACP,MAAD,EAAS,UAAU5B,KAAV,EAAiB6C,WAAjB,EAA8B;AACvD,UAAI7C,KAAJ,EAAW;AACT,YAAIuC,SAAS,CAACnJ,KAAV,CAAgB4G,KAAhB,CAAJ,EAA4B;AAC1B;AACD;AACF;;AAEDrG,MAAAA,MAAM,CAACiJ,KAAP,CAAa,uBAAb,EAAsCC,WAAtC;;AACA,YAAMC,IAAI,GAAG5J,CAAC,CAAC6J,UAAF,CAAanB,MAAb,EAAqBiB,WAArB,CAAb;;AACA,UAAIC,IAAI,CAACtB,MAAL,KAAgB,CAApB,EAAuB;AACrB7H,QAAAA,MAAM,CAACiJ,KAAP,CAAc,kBAAiBC,WAAY,EAA3C;AACA,eAAOhG,EAAE,CAAC,IAAD,EAAOgG,WAAP,CAAT;AACD;;AAEDlJ,MAAAA,MAAM,CAACiJ,KAAP,CAAc,eAAcE,IAAI,CAACE,IAAL,CAAU,IAAV,CAAgB,EAA5C;;AACA,UAAI,CAACT,SAAS,CAACnJ,KAAV,CAAgB,IAAI6J,KAAJ,CAAW,sBAAqBH,IAAK,EAArC,CAAhB,CAAL,EAA+D;AAC7DjG,QAAAA,EAAE,CAAC0F,SAAS,CAACW,SAAV,EAAD,CAAF;AACD;AACF,KAlBiB,CAAlB;AAmBD,GArBD;;AAuBA,MAAI,CAAClB,OAAL,EAAc;AACZnF,IAAAA,EAAE,CAAC,IAAD,CAAF;AACD;AACF,CAtDD;;AAwDA9C,MAAM,CAACG,SAAP,CAAiBiJ,SAAjB,GAA6B,UAAUvB,MAAV,EAAkB/E,EAAlB,EAAsB;AACjD,MAAIG,IAAI,GAAG,IAAX;AACA,OAAKoG,WAAL,CAAiBxB,MAAjB,EAAyB,UAAUxG,GAAV,EAAe;AACtC,QAAIA,GAAJ,EAAS,OAAOyB,EAAE,CAACzB,GAAD,CAAT;AACT4B,IAAAA,IAAI,CAAC2E,qBAAL,CAA2BC,MAA3B,EAAmC,UAAUxG,GAAV,EAAeiH,IAAf,EAAqB;AACtD,UAAIjH,GAAJ,EAAS,OAAOyB,EAAE,CAACzB,GAAD,CAAT;AACT4B,MAAAA,IAAI,CAACqG,eAAL,CAAqBhB,IAArB;AACAxF,MAAAA,EAAE,CAAC,IAAD,EAAO+E,MAAP,CAAF;AACD,KAJD;AAKD,GAPD;AAQD,CAVD;;AAYA7H,MAAM,CAACG,SAAP,CAAiByF,MAAjB,GAA0B,YAAY;AACpC,MAAI,KAAKR,aAAL,IAAsBrF,SAA1B,EAAqC;AACnC,SAAKqF,aAAL,GAAqB,CAArB;AACD;;AACD,SAAO,KAAKA,aAAL,EAAP;AACD,CALD;;AAOApF,MAAM,CAACG,SAAP,CAAiBoJ,YAAjB,GAAgC,YAAY;AAC1C,SAAO,KAAKC,SAAL,EAAP;AACD,CAFD;;AAIAxJ,MAAM,CAACG,SAAP,CAAiBsJ,cAAjB,GAAkC,YAAY;AAC5C,MAAIxG,IAAI,GAAG,IAAX;AACA,MAAIyG,YAAY,GAAGnC,MAAM,CAACC,IAAP,CAAY,KAAKmC,cAAjB,CAAnB;;AAEA,WAASC,gBAAT,CAA2BvJ,OAA3B,EAAoC;AAClC,QAAIwJ,cAAc,GAAG1K,CAAC,CAAC6J,UAAF,CAAazB,MAAM,CAACC,IAAP,CAAYnH,OAAZ,CAAb,EAAmCqJ,YAAnC,CAArB;;AACA,QAAIG,cAAc,CAACpC,MAAnB,EAA2B;AACzBxE,MAAAA,IAAI,CAAC7C,YAAL,CACEyJ,cAAc,CAACC,GAAf,CAAmB,UAAUnI,GAAV,EAAe;AAChC,YAAIpB,MAAM,GAAGF,OAAO,CAACsB,GAAD,CAApB;AACA,eAAOtB,OAAO,CAACsB,GAAD,CAAd;AACA,eAAOpB,MAAP;AACD,OAJD,CADF;AAOD;AACF;;AAEDqJ,EAAAA,gBAAgB,CAAC,KAAKvJ,OAAN,CAAhB;AACAuJ,EAAAA,gBAAgB,CAAC,KAAKG,kBAAN,CAAhB;AACD,CAnBD;;AAqBA/J,MAAM,CAACG,SAAP,CAAiB6J,eAAjB,GAAmC,UAAUC,UAAV,EAAsBnH,EAAtB,EAA0B;AAC3D,MAAIG,IAAI,GAAG,IAAX;AACA,MAAI,CAACgH,UAAU,CAACxC,MAAhB,EAAwB,OAAO3E,EAAE,EAAT;AACxBoH,EAAAA,sBAAsB,CAACD,UAAD,EAAanH,EAAb,CAAtB;;AAEA,WAASoH,sBAAT,CAAiCrC,MAAjC,EAAyC/E,EAAzC,EAA6C;AAC3C,QAAI0F,SAAS,GAAGnJ,KAAK,CAACmJ,SAAN,CAAgB;AAAEC,MAAAA,UAAU,EAAE,GAAd;AAAmBC,MAAAA,UAAU,EAAE;AAA/B,KAAhB,CAAhB;AACAF,IAAAA,SAAS,CAACG,OAAV,CAAkB,UAAUC,cAAV,EAA0B;AAC1ChJ,MAAAA,MAAM,CAACiJ,KAAP,CAAa,iCAAb,EAAgDD,cAAhD;AACA3F,MAAAA,IAAI,CAAC2E,qBAAL,CAA2BC,MAA3B,EAAmC,UAAUxG,GAAV,EAAeiH,IAAf,EAAqB;AACtDjH,QAAAA,GAAG,GAAGA,GAAG,IAAIiH,IAAI,CAAC,CAAD,CAAJ,CAAQrC,KAArB;;AACA,YAAI3D,KAAK,CAAC6H,OAAN,CAAc9I,GAAd,CAAJ,EAAwB;AACtBA,UAAAA,GAAG,GAAG,IAAI6H,KAAJ,CAAUvE,MAAM,CAACtD,GAAD,CAAhB,CAAN;AACD;;AACD,YAAImH,SAAS,CAACnJ,KAAV,CAAgBgC,GAAhB,CAAJ,EAA0B;AACxB;AACD;;AACD,YAAIA,GAAJ,EAAS;AACPzB,UAAAA,MAAM,CAACiJ,KAAP,CAAa,wBAAb,EAAuCxH,GAAG,CAACE,OAA3C;AACA,iBAAOuB,EAAE,CAACzB,GAAD,CAAT;AACD;;AACD4B,QAAAA,IAAI,CAACqG,eAAL,CAAqBhB,IAArB;AACAxF,QAAAA,EAAE;AACH,OAdD;AAeD,KAjBD;AAkBD;AACF,CA1BD;;AA4BA9C,MAAM,CAACG,SAAP,CAAiBkC,IAAjB,GAAwB,UAAUR,QAAV,EAAoBI,OAApB,EAA6BE,OAA7B,EAAsCW,EAAtC,EAA0C;AAChE,MAAIG,IAAI,GAAG,IAAX;AACA,MAAImH,SAAS,GAAGvI,QAAhB,CAFgE,CAGhE;;AACAA,EAAAA,QAAQ,GAAG,KAAKwI,cAAL,CAAoBxI,QAApB,CAAX;;AACA,MAAIA,QAAQ,CAAC,CAAD,CAAR,CAAY4F,MAAZ,IAAsB,CAAC5F,QAAQ,CAAC,CAAD,CAAR,CAAY4F,MAAvC,EAA+C;AAC7C,SAAK6C,YAAL,CAAkBnL,CAAC,CAACoL,OAAF,CAAU1I,QAAV,CAAlB,EAAuCI,OAAvC,EAAgDE,OAAhD,EAAyDW,EAAzD;AACA;AACD;;AACD,MAAIjB,QAAQ,CAAC,CAAD,CAAR,CAAY4F,MAAhB,EAAwB;AACtB,QAAIwC,UAAU,GAAGpI,QAAQ,CAAC,CAAD,CAAR,CAAYiI,GAAZ,CAAgB,UAAUU,CAAV,EAAa;AAC5C,aAAOA,CAAC,CAACC,KAAT;AACD,KAFgB,CAAjB;AAGA,SAAK7C,qBAAL,CAA2BqC,UAA3B,EAAuC,UAAU5I,GAAV,EAAeiH,IAAf,EAAqB;AAC1D,UAAIjH,GAAJ,EAAS;AACP,eAAOyB,EAAE,CAACzB,GAAD,CAAT;AACD;;AAED,UAAI4E,KAAK,GAAGqC,IAAI,CAAC,CAAD,CAAJ,CAAQrC,KAApB;;AACA,UAAIA,KAAJ,EAAW;AACT,eAAOnD,EAAE,CAACmD,KAAD,CAAT;AACD;;AAEDhD,MAAAA,IAAI,CAACqG,eAAL,CAAqBhB,IAArB,EAV0D,CAW1D;;AACAzG,MAAAA,QAAQ,GAAGoB,IAAI,CAACoH,cAAL,CAAoBD,SAApB,CAAX;;AACA,UAAIvI,QAAQ,CAAC,CAAD,CAAR,CAAY4F,MAAhB,EAAwB;AACtBxE,QAAAA,IAAI,CAACiC,qBAAL;AACA,eAAOpC,EAAE,CAAC,IAAIvD,MAAM,CAACkF,uBAAX,CAAmC,2BAAnC,CAAD,CAAT;AACD;;AAEDxB,MAAAA,IAAI,CAACqH,YAAL,CAAkBzI,QAAQ,CAAC,CAAD,CAAR,CAAY6I,MAAZ,CAAmB7I,QAAQ,CAAC,CAAD,CAA3B,CAAlB,EAAmDI,OAAnD,EAA4DE,OAA5D,EAAqEW,EAArE;AACD,KAnBD;AAoBD;AACF,CAlCD;;AAoCA9C,MAAM,CAACG,SAAP,CAAiBmK,YAAjB,GAAgC,UAAUzI,QAAV,EAAoBI,OAApB,EAA6BE,OAA7B,EAAsCW,EAAtC,EAA0C;AACxE,MAAI6H,WAAW,GAAG1I,OAAO,CAAC2I,IAAR,KAAiB,oBAAnC;AACA/I,EAAAA,QAAQ,GAAG,KAAKgJ,gBAAL,CAAsBhJ,QAAtB,CAAX;;AACA,MAAI,CAAC8I,WAAL,EAAkB;AAChB7H,IAAAA,EAAE,GAAGsE,IAAI,CAACvF,QAAD,EAAWiB,EAAX,CAAT;AACD;;AACD,OAAK,IAAIgI,MAAT,IAAmBjJ,QAAnB,EAA6B;AAC3B,QAAI,CAACA,QAAQ,CAACkJ,cAAT,CAAwBD,MAAxB,CAAL,EAAsC;AACpC;AACD;;AACD,QAAI1F,aAAa,GAAG,KAAKQ,MAAL,EAApB;AACA,QAAIrF,MAAM,GAAG,KAAKuF,eAAL,CAAqBgF,MAArB,EAA6BH,WAA7B,CAAb;AACA,QAAI5E,WAAW,GAAG,IAAlB;;AACA,QAAI,CAACxF,MAAL,EAAa;AACXwF,MAAAA,WAAW,GAAG,uBAAd;AACD,KAFD,MAEO,IAAI,CAACxF,MAAM,CAACyF,WAAP,EAAL,EAA2B;AAChCD,MAAAA,WAAW,GAAG,6BAA6BxF,MAAM,CAACC,MAAP,CAAcyF,KAAd,GAAsB,QAAQ1F,MAAM,CAACC,MAAP,CAAcyF,KAAd,CAAoB1E,OAAlD,GAA4D,EAAzF,CAAd;AACD;;AACD,QAAIwE,WAAJ,EAAiB;AACf,WAAKb,qBAAL;AACA,aAAOpC,EAAE,CAAC,IAAIvD,MAAM,CAACkF,uBAAX,CAAmC,2BAA2BsB,WAA9D,CAAD,EAA6ElE,QAAQ,CAACiJ,MAAD,CAArF,CAAT;AACD;;AAED,QAAIH,WAAJ,EAAiB;AACf,UAAIpK,MAAM,CAACC,MAAP,CAAcwK,OAAlB,EAA2B;AACzB;AACD;;AACDzK,MAAAA,MAAM,CAACC,MAAP,CAAcwK,OAAd,GAAwB,IAAxB;AACD;;AACD,QAAI3F,OAAO,GAAGpD,OAAO,CAAC,KAAK4D,QAAN,EAAgBT,aAAhB,EAA+BvD,QAAQ,CAACiJ,MAAD,CAAvC,CAArB;;AAEA,QAAI3I,OAAO,CAACS,WAAR,KAAwB,CAA5B,EAA+B;AAC7BrC,MAAAA,MAAM,CAAC0K,UAAP,CAAkB5F,OAAlB;AACAvC,MAAAA,EAAE,CAAC,IAAD,EAAO;AAAEK,QAAAA,MAAM,EAAE;AAAV,OAAP,CAAF;AACD,KAHD,MAGO;AACL,WAAKgC,aAAL,CAAmB5E,MAAnB,EAA2B6E,aAA3B,EAA0CC,OAA1C,EAAmDlD,OAAnD,EAA4DW,EAA5D;AACD;AACF;AACF,CAtCD;;AAwCA9C,MAAM,CAACG,SAAP,CAAiBkK,cAAjB,GAAkC,UAAUxI,QAAV,EAAoB;AACpD,MAAI1C,CAAC,CAAC+L,OAAF,CAAU,KAAKC,aAAf,CAAJ,EAAmC,OAAO,CAAC,EAAD,EAAKtJ,QAAL,CAAP,CADiB,CAEpD;;AACA,MAAIwF,GAAG,GAAG,CAAC,EAAD,EAAK,EAAL,CAAV;AACAxF,EAAAA,QAAQ,CAACuJ,OAAT,CACE,UAAUZ,CAAV,EAAa;AACX,QAAI,KAAKa,WAAL,CAAiBb,CAAC,CAACC,KAAnB,EAA0BD,CAAC,CAACc,SAA5B,CAAJ,EAA4CjE,GAAG,CAAC,CAAD,CAAH,CAAOkE,IAAP,CAAYf,CAAZ,EAA5C,KACKnD,GAAG,CAAC,CAAD,CAAH,CAAOkE,IAAP,CAAYf,CAAZ;AACN,GAHD,CAGEgB,IAHF,CAGO,IAHP,CADF;AAMA,SAAOnE,GAAP;AACD,CAXD;;AAaArH,MAAM,CAACG,SAAP,CAAiBkL,WAAjB,GAA+B,UAAUZ,KAAV,EAAiBa,SAAjB,EAA4B;AACzD,MAAIG,cAAc,GAAG,KAAKA,cAA1B;AACA,MAAIX,MAAM,GAAG,KAAKY,iBAAL,CAAuBjB,KAAvB,EAA8Ba,SAA9B,CAAb;AAEA,SAAOR,MAAM,KAAKa,SAAX,IAAwBF,cAAc,CAACX,MAAD,CAA7C;AACD,CALD;;AAOA9K,MAAM,CAACG,SAAP,CAAiBmJ,eAAjB,GAAmC,UAAUsC,SAAV,EAAqB;AACtD;AACAzM,EAAAA,CAAC,CAAC0M,MAAF,CAAS,KAAKV,aAAd,EAA6BS,SAAS,CAAC,CAAD,CAAT,CAAarD,QAA1C;;AACA,OAAK,IAAIkC,KAAT,IAAkB,KAAKU,aAAvB,EAAsC;AACpC,QAAI,CAAC,KAAKA,aAAL,CAAmBJ,cAAnB,CAAkCN,KAAlC,CAAL,EAA+C;AAC7C;AACD;;AACD,SAAKqB,eAAL,CAAqBrB,KAArB,IAA8BlD,MAAM,CAACC,IAAP,CAAY,KAAK2D,aAAL,CAAmBV,KAAnB,CAAZ,EAAuCX,GAAvC,CAA2C,UAAUiC,GAAV,EAAe;AACtF,aAAOC,QAAQ,CAACD,GAAD,EAAM,EAAN,CAAf;AACD,KAF6B,CAA9B;AAGD;AACF,CAXD;;AAaA/L,MAAM,CAACG,SAAP,CAAiB8L,mBAAjB,GAAuC,UAAUpE,MAAV,EAAkB/E,EAAlB,EAAsB;AAC3D+E,EAAAA,MAAM,CAACuD,OAAP,CACE,UAAUc,CAAV,EAAa;AACX,QAAI,KAAKf,aAAL,CAAmBe,CAAnB,CAAJ,EAA2B,OAAO,KAAKf,aAAL,CAAmBe,CAAnB,CAAP;AAC5B,GAFD,CAEEV,IAFF,CAEO,IAFP,CADF;AAKA1I,EAAAA,EAAE,CAAC,IAAD,EAAO+E,MAAM,CAACJ,MAAd,CAAF;AACD,CAPD;;AASAzH,MAAM,CAACG,SAAP,CAAiB0K,gBAAjB,GAAoC,UAAUhJ,QAAV,EAAoB;AACtD,SAAOA,QAAQ,CAACsK,MAAT,CACL,UAAU9E,GAAV,EAAemD,CAAf,EAAkB;AAChB,QAAIM,MAAM,GAAG,KAAKY,iBAAL,CAAuBlB,CAAC,CAACC,KAAzB,EAAgCD,CAAC,CAACc,SAAlC,CAAb;AACAjE,IAAAA,GAAG,CAACyD,MAAD,CAAH,GAAczD,GAAG,CAACyD,MAAD,CAAH,IAAe,EAA7B;AACAzD,IAAAA,GAAG,CAACyD,MAAD,CAAH,CAAYS,IAAZ,CAAiBf,CAAjB;AACA,WAAOnD,GAAP;AACD,GALD,CAKEmE,IALF,CAKO,IALP,CADK,EAOL,EAPK,CAAP;AASD,CAVD;;AAYAxL,MAAM,CAACG,SAAP,CAAiBuL,iBAAjB,GAAqC,UAAUjB,KAAV,EAAiBa,SAAjB,EAA4B;AAC/D,MAAIH,aAAa,GAAG,KAAKA,aAAzB;AACA,SAAOA,aAAa,CAACV,KAAD,CAAb,IAAwBU,aAAa,CAACV,KAAD,CAAb,CAAqBa,SAArB,CAAxB,IAA2DH,aAAa,CAACV,KAAD,CAAb,CAAqBa,SAArB,EAAgCR,MAAlG;AACD,CAHD;;AAKA9K,MAAM,CAACG,SAAP,CAAiB2F,eAAjB,GAAmC,UAAUgF,MAAV,EAAkBH,WAAlB,EAA+B;AAChE,MAAIyB,IAAJ;AACA,MAAI/L,OAAO,GAAG,KAAKgM,UAAL,CAAgB1B,WAAhB,CAAd,CAFgE,CAGhE;;AACA,MAAI,OAAOG,MAAP,KAAkB,WAAtB,EAAmC;AACjC,QAAI,CAAC3L,CAAC,CAAC+L,OAAF,CAAU7K,OAAV,CAAL,EAAyB;AACvB+L,MAAAA,IAAI,GAAG7E,MAAM,CAACC,IAAP,CAAYnH,OAAZ,EAAqB,CAArB,CAAP;AACA,aAAOA,OAAO,CAAC+L,IAAD,CAAd;AACD,KAHD,MAGO,IAAI,CAACjN,CAAC,CAAC+L,OAAF,CAAU,KAAKO,cAAf,CAAL,EAAqC;AAC1CX,MAAAA,MAAM,GAAGvD,MAAM,CAACC,IAAP,CAAY,KAAKiE,cAAjB,EAAiC,CAAjC,CAAT;AACD,KAFM,MAEA;AACL;AACD;AACF;;AAED,MAAIlL,MAAM,GAAGpB,CAAC,CAACmN,IAAF,CAAO,KAAK3C,cAAZ,EAA4B;AAAE4C,IAAAA,EAAE,EAAEzB;AAAN,GAA5B,CAAb;;AAEA,MAAI,CAACvK,MAAL,EAAa;AACX;AACD;;AAED6L,EAAAA,IAAI,GAAG7L,MAAM,CAACiM,IAAP,GAAc,GAAd,GAAoBjM,MAAM,CAACkM,IAAlC;AAEA,SAAOpM,OAAO,CAAC+L,IAAD,CAAP,IAAiB,KAAKM,WAAL,CAAiBnM,MAAM,CAACiM,IAAxB,EAA8BjM,MAAM,CAACkM,IAArC,EAA2C9B,WAA3C,EAAwDtK,OAAxD,CAAxB;AACD,CAxBD;;AA0BAL,MAAM,CAACG,SAAP,CAAiBkM,UAAjB,GAA8B,UAAU1B,WAAV,EAAuB;AACnD,SAAOA,WAAW,GAAG,KAAKZ,kBAAR,GAA6B,KAAK1J,OAApD;AACD,CAFD;;AAIAL,MAAM,CAACG,SAAP,CAAiBwM,eAAjB,GAAmC,UAAUC,SAAV,EAAqB;AACtDA,EAAAA,SAAS,CAACC,QAAV,GAAqB,KAArB;;AACA,MAAID,SAAS,CAAC3G,KAAd,EAAqB;AACnB2G,IAAAA,SAAS,CAAChM,OAAV;AACD;;AACD,MAAIP,OAAO,GAAG,KAAKgM,UAAL,CAAgBO,SAAS,CAACjC,WAA1B,CAAd;AACA,MAAImC,SAAS,GAAG,KAAKJ,WAAL,CAAiBE,SAAS,CAACJ,IAA3B,EAAiCI,SAAS,CAACH,IAA3C,EAAiDG,SAAS,CAACjC,WAA3D,EAAwEtK,OAAxE,CAAhB;AACAyM,EAAAA,SAAS,CAACtM,MAAV,CAAiByF,KAAjB,GAAyB2G,SAAS,CAAC3G,KAAnC;AACD,CARD;;AAUAjG,MAAM,CAACG,SAAP,CAAiB4M,kBAAjB,GAAsC,UAAUvM,MAAV,EAAkB;AACtD,MAAIwM,MAAM,GAAGxM,MAAM,CAACwM,MAApB;;AACA,MAAI,CAACA,MAAM,CAACvF,MAAR,IAAkBuF,MAAM,CAACvF,MAAP,GAAgB,CAAtC,EAAyC;AACvC;AACD;;AACD,MAAIwF,IAAI,GAAGD,MAAM,CAACE,YAAP,CAAoB,CAApB,IAAyB,CAApC;;AAEA,MAAIF,MAAM,CAACvF,MAAP,IAAiBwF,IAArB,EAA2B;AACzB,QAAIzM,MAAM,CAACmK,WAAX,EAAwB;AACtBnK,MAAAA,MAAM,CAACwK,OAAP,GAAiB,KAAjB;AACD;;AAED,QAAI1C,IAAI,GAAG0E,MAAM,CAACG,YAAP,CAAoB,CAApB,EAAuBF,IAAvB,CAAX;AACA,QAAI7H,aAAa,GAAGkD,IAAI,CAAC4E,YAAL,CAAkB,CAAlB,CAApB;AAEA,SAAKE,sBAAL,CAA4B5M,MAA5B,EAAoC4E,aAApC,EAAmDkD,IAAnD;AACA0E,IAAAA,MAAM,CAACK,OAAP,CAAeJ,IAAf;AACD,GAVD,MAUO;AACL;AACD;;AAED,MAAIzM,MAAM,CAACwM,MAAP,CAAcvF,MAAlB,EAA0B;AACxB9G,IAAAA,YAAY,CACV,YAAY;AACV,WAAKoM,kBAAL,CAAwBvM,MAAxB;AACD,KAFD,CAEEgL,IAFF,CAEO,IAFP,CADU,CAAZ;AAKD;AACF,CA5BD;;AA8BAxL,MAAM,CAACG,SAAP,CAAiBiN,sBAAjB,GAA0C,UAAU5M,MAAV,EAAkB4E,aAAlB,EAAiCkD,IAAjC,EAAuC;AAC/E,MAAIgF,QAAQ,GAAG,KAAKC,eAAL,CAAqB/M,MAArB,EAA6B4E,aAA7B,CAAf;;AAEA,MAAIkI,QAAJ,EAAc;AACZ,QAAI,CAACnL,OAAD,EAAUW,EAAV,IAAgBwK,QAApB;AACA,QAAInK,MAAM,GAAGhB,OAAO,CAACmG,IAAD,CAApB;;AACA,QAAInF,MAAM,YAAY+F,KAAtB,EAA6B;AAC3BpG,MAAAA,EAAE,CAACN,IAAH,CAAQ,IAAR,EAAcW,MAAd;AACD,KAFD,MAEO;AACLL,MAAAA,EAAE,CAACN,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoBW,MAApB;AACD;AACF,GARD,MAQO;AACLvD,IAAAA,MAAM,CAACqG,KAAP,CAAc,wCAAuCb,aAAc,EAAnE;AACD;AACF,CAdD;;AAgBApF,MAAM,CAACG,SAAP,CAAiBoF,aAAjB,GAAiC,UAAU/E,MAAV,EAAkB+L,EAAlB,EAAsB7E,IAAtB,EAA4B;AAC3D,MAAI8F,QAAQ,GAAGhN,MAAM,CAACgN,QAAtB;AACA,MAAIC,KAAK,GAAG,KAAKC,OAAL,CAAaC,GAAb,CAAiBH,QAAjB,CAAZ;;AACA,MAAI,CAACC,KAAL,EAAY;AACVA,IAAAA,KAAK,GAAG,IAAIG,GAAJ,EAAR;AACA,SAAKF,OAAL,CAAaG,GAAb,CAAiBL,QAAjB,EAA2BC,KAA3B;AACD;;AAEDA,EAAAA,KAAK,CAACI,GAAN,CAAUtB,EAAV,EAAc7E,IAAd;AACD,CATD;;AAWA1H,MAAM,CAACG,SAAP,CAAiBoN,eAAjB,GAAmC,UAAU/M,MAAV,EAAkB+L,EAAlB,EAAsB;AACvD,MAAIiB,QAAQ,GAAGhN,MAAM,CAACgN,QAAtB;AAEA,MAAIC,KAAK,GAAG,KAAKC,OAAL,CAAaC,GAAb,CAAiBH,QAAjB,CAAZ;;AACA,MAAI;AACF,QAAI,CAACC,KAAL,EAAY;AACV,aAAO,IAAP;AACD;;AAED,QAAI,CAACA,KAAK,CAACK,GAAN,CAAUvB,EAAV,CAAL,EAAoB;AAClB,aAAO,IAAP;AACD;;AAED,QAAIpJ,MAAM,GAAGsK,KAAK,CAACE,GAAN,CAAUpB,EAAV,CAAb,CATE,CAWF;;AACAkB,IAAAA,KAAK,CAACM,MAAN,CAAaxB,EAAb;AAEA,WAAOpJ,MAAP;AACD,GAfD,SAeU;AACR,QAAIsK,KAAK,IAAI,CAACA,KAAK,CAACR,IAApB,EAA0B;AACxB,WAAKS,OAAL,CAAaK,MAAb,CAAoBP,QAApB;AACD;AACF;AACF,CAxBD;;AA0BAxN,MAAM,CAACG,SAAP,CAAiB6N,kBAAjB,GAAsC,UAAUxN,MAAV,EAAkByF,KAAlB,EAAyB;AAC7D,MAAIuH,QAAQ,GAAGhN,MAAM,CAACgN,QAAtB;AACA,MAAI7C,WAAW,GAAGnK,MAAM,CAACmK,WAAzB;AAEA,MAAI8C,KAAK,GAAG,KAAKC,OAAL,CAAaC,GAAb,CAAiBH,QAAjB,CAAZ;;AACA,MAAI,CAACC,KAAL,EAAY;AACV;AACD;;AAED,MAAI,CAAC9C,WAAL,EAAkB;AAChB8C,IAAAA,KAAK,CAACrC,OAAN,CAAc,UAAUkC,QAAV,EAAoB;AAChC,UAAIxK,EAAE,GAAGwK,QAAQ,CAAC,CAAD,CAAjB;AACAxK,MAAAA,EAAE,CAACmD,KAAD,CAAF;AACD,KAHD;AAID;;AAED,OAAKyH,OAAL,CAAaK,MAAb,CAAoBP,QAApB;AACD,CAjBD;;AAmBAS,MAAM,CAACC,OAAP,GAAiBlO,MAAjB","sourcesContent":["'use strict';\n\nvar util = require('util');\nvar _ = require('lodash');\nvar async = require('async');\nvar retry = require('retry');\nvar EventEmitter = require('events');\nvar errors = require('./errors');\nvar getCodec = require('./codec');\nvar protocol = require('./protocol');\nvar encodeMessageSet = protocol.encodeMessageSet;\nvar Message = protocol.Message;\nvar logger = require('./logging')('kafka-node:BaseClient');\nvar validateKafkaTopics = require('./utils').validateTopicNames;\n\nconst MAX_INT32 = 2147483647;\n\n/**\n *\n * @constructor\n */\nfunction Client () {\n  throw new TypeError('BaseClient cannot be instantiated directly');\n}\n\nutil.inherits(Client, EventEmitter);\n\nClient.prototype.closeBrokers = function (brokers) {\n  _.each(brokers, function (broker) {\n    broker.socket.closing = true;\n    broker.socket.end();\n    setImmediate(function () {\n      broker.socket.destroy();\n      broker.socket.unref();\n    });\n  });\n};\n\nfunction decodeValue (encoding, value) {\n  if (encoding !== 'buffer' && value != null) {\n    return value.toString(encoding);\n  }\n  return value;\n}\n\nClient.prototype._createMessageHandler = function (consumer, stateValidator) {\n  return (err, type, message) => {\n    if (stateValidator && !stateValidator(err, type, message)) {\n      return;\n    }\n    if (err) {\n      if (err.message === 'OffsetOutOfRange') {\n        return consumer.emit('offsetOutOfRange', err);\n      } else if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n        return this.emit('brokersChanged');\n      }\n\n      return consumer.emit('error', err);\n    }\n\n    var encoding = consumer.options.encoding;\n    const keyEncoding = consumer.options.keyEncoding;\n\n    if (type === 'message') {\n      message.value = decodeValue(encoding, message.value);\n      message.key = decodeValue(keyEncoding || encoding, message.key);\n\n      consumer.emit('message', message);\n    } else {\n      consumer.emit(type, message);\n    }\n  };\n};\n\nClient.prototype.sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {\n  var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes);\n  // TODO: state validator for HLC for ignoring stale fetch requests\n  var decoder = protocol.decodeFetchResponse(this._createMessageHandler(consumer), maxTickMessages);\n\n  this.send(payloads, encoder, decoder, function (err) {\n    if (err) {\n      Array.prototype.unshift.call(arguments, 'error');\n      consumer.emit.apply(consumer, arguments);\n    }\n  });\n};\n\nClient.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {\n  var encoder = protocol.encodeProduceRequest(requireAcks, ackTimeoutMs);\n  var decoder = protocol.decodeProduceResponse;\n  var self = this;\n\n  decoder.requireAcks = requireAcks;\n\n  async.each(payloads, buildRequest, function (err) {\n    if (err) return cb(err);\n    self.send(payloads, encoder, decoder, function (err, result) {\n      if (err) {\n        if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n          self.emit('brokersChanged');\n        }\n        cb(err);\n      } else {\n        cb(null, result);\n      }\n    });\n  });\n\n  function buildRequest (payload, cb) {\n    var attributes = payload.attributes;\n    var codec = getCodec(attributes);\n\n    if (!codec) return cb();\n\n    var innerSet = encodeMessageSet(payload.messages);\n    codec.encode(innerSet, function (err, message) {\n      if (err) return cb(err);\n      payload.messages = [new Message(0, attributes, '', message)];\n      cb();\n    });\n  }\n};\n\nClient.prototype.sendOffsetCommitRequest = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetCommitRequest(group);\n  var decoder = protocol.decodeOffsetCommitResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\n\nClient.prototype.sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {\n  var encoder = protocol.encodeOffsetCommitV2Request;\n  var decoder = protocol.decodeOffsetCommitResponse;\n  this.sendGroupRequest(encoder, decoder, arguments);\n};\n\nClient.prototype.sendOffsetFetchV1Request = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetFetchV1Request;\n  var decoder = protocol.decodeOffsetFetchV1Response;\n  this.sendGroupRequest(encoder, decoder, arguments);\n};\n\nClient.prototype.setCoordinatorIdAndSendOffsetFetchV1Request = function (group, payloads, cb) {\n  this.sendGroupCoordinatorRequest(group, (err, coordinatorInfo) => {\n    if (err) return cb(new errors.BrokerNotAvailableError('Broker not available'));\n    this.coordinatorId = String(coordinatorInfo.coordinatorId);\n    this.sendOffsetFetchV1Request(group, payloads, cb);\n  });\n};\n\nClient.prototype.sendOffsetFetchRequest = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetFetchRequest(group);\n  var decoder = protocol.decodeOffsetFetchResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\n\nClient.prototype.sendOffsetRequest = function (payloads, cb) {\n  var encoder = protocol.encodeOffsetRequest;\n  var decoder = protocol.decodeOffsetResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\n\nClient.prototype.refreshBrokerMetadata = function () {};\n\nClient.prototype.sendWhenReady = function (broker, correlationId, request, decode, cb) {\n  this.queueCallback(broker.socket, correlationId, [decode, cb]);\n  broker.write(request);\n};\n\nClient.prototype.sendGroupRequest = function (encode, decode, requestArgs) {\n  requestArgs = _.values(requestArgs);\n  var cb = requestArgs.pop();\n  var correlationId = this.nextId();\n\n  requestArgs.unshift(this.clientId, correlationId);\n\n  var request = encode.apply(null, requestArgs);\n  var broker = this.brokerForLeader(this.coordinatorId);\n  var brokerError = null;\n  if (!broker) {\n    brokerError = 'Could not find broker';\n  } else if (!broker.isConnected()) {\n    brokerError = 'Broker socket is closed' + (broker.socket.error ? ' - ' + broker.socket.error.message : '');\n  }\n  if (brokerError) {\n    this.refreshBrokerMetadata();\n    return cb(new errors.BrokerNotAvailableError('Broker not available: ' + brokerError));\n  }\n\n  this.sendWhenReady(broker, correlationId, request, decode, cb);\n};\n\nClient.prototype.sendGroupCoordinatorRequest = function (groupId, cb) {\n  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);\n};\n\nClient.prototype.sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {\n  this.sendGroupRequest(protocol.encodeJoinGroupRequest, protocol.decodeJoinGroupResponse, arguments);\n};\n\nClient.prototype.sendSyncGroupRequest = function (groupId, generationId, memberId, groupAssignment, cb) {\n  this.sendGroupRequest(protocol.encodeSyncGroupRequest, protocol.decodeSyncGroupResponse, arguments);\n};\n\nClient.prototype.sendHeartbeatRequest = function (groupId, generationId, memberId, cb) {\n  this.sendGroupRequest(protocol.encodeGroupHeartbeatRequest, protocol.decodeGroupHeartbeatResponse, arguments);\n};\n\nClient.prototype.sendLeaveGroupRequest = function (groupId, memberId, cb) {\n  this.sendGroupRequest(protocol.encodeLeaveGroupRequest, protocol.decodeLeaveGroupResponse, arguments);\n};\n\n/*\n *  Helper method\n *  topic in payloads may send to different broker, so we cache data util all request came back\n */\nfunction wrap (payloads, cb) {\n  var out = {};\n  var count = Object.keys(payloads).length;\n\n  return function (err, data) {\n    // data: { topicName1: {}, topicName2: {} }\n    if (err) return cb && cb(err);\n    _.merge(out, data);\n    count -= 1;\n    // Waiting for all request return\n    if (count !== 0) return;\n    cb && cb(null, out);\n  };\n}\n\n/**\n * Fetches metadata information for a topic\n * This includes an array containing a each zookeeper node, their nodeId, host name, and port. As well as an object\n * containing the topic name, partition, leader number, replica count, and in sync replicas per partition.\n *\n * @param {Array} topics An array of topics to load the metadata for\n * @param {Client~loadMetadataForTopicsCallback} cb Function to call once all metadata is loaded\n */\nClient.prototype.loadMetadataForTopics = function (topics, cb) {\n  var correlationId = this.nextId();\n  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, topics);\n  var broker = this.brokerForLeader();\n\n  if (!broker || !broker.isConnected()) {\n    return cb(new errors.BrokerNotAvailableError('Broker not available'));\n  }\n\n  this.sendWhenReady(broker, correlationId, request, protocol.decodeMetadataResponse, cb);\n};\n\nClient.prototype.createTopics = function (topics, isAsync, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n\n  if (typeof isAsync === 'function' && typeof cb === 'undefined') {\n    cb = isAsync;\n    isAsync = true;\n  }\n\n  try {\n    validateKafkaTopics(topics);\n  } catch (e) {\n    if (isAsync) return cb(e);\n    throw e;\n  }\n\n  cb = _.once(cb);\n\n  const getTopicsFromKafka = (topics, callback) => {\n    this.loadMetadataForTopics(topics, function (error, resp) {\n      if (error) {\n        return callback(error);\n      }\n      callback(null, Object.keys(resp[1].metadata));\n    });\n  };\n\n  const operation = retry.operation({ minTimeout: 200, maxTimeout: 2000 });\n\n  operation.attempt(currentAttempt => {\n    logger.debug('create topics currentAttempt', currentAttempt);\n    getTopicsFromKafka(topics, function (error, kafkaTopics) {\n      if (error) {\n        if (operation.retry(error)) {\n          return;\n        }\n      }\n\n      logger.debug('kafka reported topics', kafkaTopics);\n      const left = _.difference(topics, kafkaTopics);\n      if (left.length === 0) {\n        logger.debug(`Topics created ${kafkaTopics}`);\n        return cb(null, kafkaTopics);\n      }\n\n      logger.debug(`Topics left ${left.join(', ')}`);\n      if (!operation.retry(new Error(`Topics not created ${left}`))) {\n        cb(operation.mainError());\n      }\n    });\n  });\n\n  if (!isAsync) {\n    cb(null);\n  }\n};\n\nClient.prototype.addTopics = function (topics, cb) {\n  var self = this;\n  this.topicExists(topics, function (err) {\n    if (err) return cb(err);\n    self.loadMetadataForTopics(topics, function (err, resp) {\n      if (err) return cb(err);\n      self.updateMetadatas(resp);\n      cb(null, topics);\n    });\n  });\n};\n\nClient.prototype.nextId = function () {\n  if (this.correlationId >= MAX_INT32) {\n    this.correlationId = 0;\n  }\n  return this.correlationId++;\n};\n\nClient.prototype.nextSocketId = function () {\n  return this._socketId++;\n};\n\nClient.prototype.refreshBrokers = function () {\n  var self = this;\n  var validBrokers = Object.keys(this.brokerProfiles);\n\n  function closeDeadBrokers (brokers) {\n    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);\n    if (deadBrokerKeys.length) {\n      self.closeBrokers(\n        deadBrokerKeys.map(function (key) {\n          var broker = brokers[key];\n          delete brokers[key];\n          return broker;\n        })\n      );\n    }\n  }\n\n  closeDeadBrokers(this.brokers);\n  closeDeadBrokers(this.longpollingBrokers);\n};\n\nClient.prototype.refreshMetadata = function (topicNames, cb) {\n  var self = this;\n  if (!topicNames.length) return cb();\n  attemptRequestMetadata(topicNames, cb);\n\n  function attemptRequestMetadata (topics, cb) {\n    var operation = retry.operation({ minTimeout: 200, maxTimeout: 1000 });\n    operation.attempt(function (currentAttempt) {\n      logger.debug('refresh metadata currentAttempt', currentAttempt);\n      self.loadMetadataForTopics(topics, function (err, resp) {\n        err = err || resp[1].error;\n        if (Array.isArray(err)) {\n          err = new Error(String(err));\n        }\n        if (operation.retry(err)) {\n          return;\n        }\n        if (err) {\n          logger.debug('refresh metadata error', err.message);\n          return cb(err);\n        }\n        self.updateMetadatas(resp);\n        cb();\n      });\n    });\n  }\n};\n\nClient.prototype.send = function (payloads, encoder, decoder, cb) {\n  var self = this;\n  var _payloads = payloads;\n  // payloads: [ [metadata exists], [metadata not exists] ]\n  payloads = this.checkMetadatas(payloads);\n  if (payloads[0].length && !payloads[1].length) {\n    this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);\n    return;\n  }\n  if (payloads[1].length) {\n    var topicNames = payloads[1].map(function (p) {\n      return p.topic;\n    });\n    this.loadMetadataForTopics(topicNames, function (err, resp) {\n      if (err) {\n        return cb(err);\n      }\n\n      var error = resp[1].error;\n      if (error) {\n        return cb(error);\n      }\n\n      self.updateMetadatas(resp);\n      // check payloads again\n      payloads = self.checkMetadatas(_payloads);\n      if (payloads[1].length) {\n        self.refreshBrokerMetadata();\n        return cb(new errors.BrokerNotAvailableError('Could not find the leader'));\n      }\n\n      self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);\n    });\n  }\n};\n\nClient.prototype.sendToBroker = function (payloads, encoder, decoder, cb) {\n  var longpolling = encoder.name === 'encodeFetchRequest';\n  payloads = this.payloadsByLeader(payloads);\n  if (!longpolling) {\n    cb = wrap(payloads, cb);\n  }\n  for (var leader in payloads) {\n    if (!payloads.hasOwnProperty(leader)) {\n      continue;\n    }\n    var correlationId = this.nextId();\n    var broker = this.brokerForLeader(leader, longpolling);\n    var brokerError = null;\n    if (!broker) {\n      brokerError = 'Could not find broker';\n    } else if (!broker.isConnected()) {\n      brokerError = 'Broker socket is closed' + (broker.socket.error ? ' - ' + broker.socket.error.message : '');\n    }\n    if (brokerError) {\n      this.refreshBrokerMetadata();\n      return cb(new errors.BrokerNotAvailableError('Broker not available: ' + brokerError), payloads[leader]);\n    }\n\n    if (longpolling) {\n      if (broker.socket.waiting) {\n        continue;\n      }\n      broker.socket.waiting = true;\n    }\n    var request = encoder(this.clientId, correlationId, payloads[leader]);\n\n    if (decoder.requireAcks === 0) {\n      broker.writeAsync(request);\n      cb(null, { result: 'no ack' });\n    } else {\n      this.sendWhenReady(broker, correlationId, request, decoder, cb);\n    }\n  }\n};\n\nClient.prototype.checkMetadatas = function (payloads) {\n  if (_.isEmpty(this.topicMetadata)) return [[], payloads];\n  // out: [ [metadata exists], [metadata not exists] ]\n  var out = [[], []];\n  payloads.forEach(\n    function (p) {\n      if (this.hasMetadata(p.topic, p.partition)) out[0].push(p);\n      else out[1].push(p);\n    }.bind(this)\n  );\n  return out;\n};\n\nClient.prototype.hasMetadata = function (topic, partition) {\n  var brokerMetadata = this.brokerMetadata;\n  var leader = this.leaderByPartition(topic, partition);\n\n  return leader !== undefined && brokerMetadata[leader];\n};\n\nClient.prototype.updateMetadatas = function (metadatas) {\n  // _.extend(this.brokerMetadata, metadatas[0])\n  _.extend(this.topicMetadata, metadatas[1].metadata);\n  for (var topic in this.topicMetadata) {\n    if (!this.topicMetadata.hasOwnProperty(topic)) {\n      continue;\n    }\n    this.topicPartitions[topic] = Object.keys(this.topicMetadata[topic]).map(function (val) {\n      return parseInt(val, 10);\n    });\n  }\n};\n\nClient.prototype.removeTopicMetadata = function (topics, cb) {\n  topics.forEach(\n    function (t) {\n      if (this.topicMetadata[t]) delete this.topicMetadata[t];\n    }.bind(this)\n  );\n  cb(null, topics.length);\n};\n\nClient.prototype.payloadsByLeader = function (payloads) {\n  return payloads.reduce(\n    function (out, p) {\n      var leader = this.leaderByPartition(p.topic, p.partition);\n      out[leader] = out[leader] || [];\n      out[leader].push(p);\n      return out;\n    }.bind(this),\n    {}\n  );\n};\n\nClient.prototype.leaderByPartition = function (topic, partition) {\n  var topicMetadata = this.topicMetadata;\n  return topicMetadata[topic] && topicMetadata[topic][partition] && topicMetadata[topic][partition].leader;\n};\n\nClient.prototype.brokerForLeader = function (leader, longpolling) {\n  var addr;\n  var brokers = this.getBrokers(longpolling);\n  // If leader is not give, choose the first broker as leader\n  if (typeof leader === 'undefined') {\n    if (!_.isEmpty(brokers)) {\n      addr = Object.keys(brokers)[0];\n      return brokers[addr];\n    } else if (!_.isEmpty(this.brokerMetadata)) {\n      leader = Object.keys(this.brokerMetadata)[0];\n    } else {\n      return;\n    }\n  }\n\n  var broker = _.find(this.brokerProfiles, { id: leader });\n\n  if (!broker) {\n    return;\n  }\n\n  addr = broker.host + ':' + broker.port;\n\n  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers);\n};\n\nClient.prototype.getBrokers = function (longpolling) {\n  return longpolling ? this.longpollingBrokers : this.brokers;\n};\n\nClient.prototype.reconnectBroker = function (oldSocket) {\n  oldSocket.retrying = false;\n  if (oldSocket.error) {\n    oldSocket.destroy();\n  }\n  var brokers = this.getBrokers(oldSocket.longpolling);\n  var newBroker = this.setupBroker(oldSocket.host, oldSocket.port, oldSocket.longpolling, brokers);\n  newBroker.socket.error = oldSocket.error;\n};\n\nClient.prototype.handleReceivedData = function (socket) {\n  var buffer = socket.buffer;\n  if (!buffer.length || buffer.length < 4) {\n    return;\n  }\n  var size = buffer.readUInt32BE(0) + 4;\n\n  if (buffer.length >= size) {\n    if (socket.longpolling) {\n      socket.waiting = false;\n    }\n\n    var resp = buffer.shallowSlice(0, size);\n    var correlationId = resp.readUInt32BE(4);\n\n    this.invokeResponseCallback(socket, correlationId, resp);\n    buffer.consume(size);\n  } else {\n    return;\n  }\n\n  if (socket.buffer.length) {\n    setImmediate(\n      function () {\n        this.handleReceivedData(socket);\n      }.bind(this)\n    );\n  }\n};\n\nClient.prototype.invokeResponseCallback = function (socket, correlationId, resp) {\n  var handlers = this.unqueueCallback(socket, correlationId);\n\n  if (handlers) {\n    var [decoder, cb] = handlers;\n    var result = decoder(resp);\n    if (result instanceof Error) {\n      cb.call(this, result);\n    } else {\n      cb.call(this, null, result);\n    }\n  } else {\n    logger.error(`missing handlers for Correlation ID: ${correlationId}`);\n  }\n};\n\nClient.prototype.queueCallback = function (socket, id, data) {\n  var socketId = socket.socketId;\n  var queue = this.cbqueue.get(socketId);\n  if (!queue) {\n    queue = new Map();\n    this.cbqueue.set(socketId, queue);\n  }\n\n  queue.set(id, data);\n};\n\nClient.prototype.unqueueCallback = function (socket, id) {\n  var socketId = socket.socketId;\n\n  var queue = this.cbqueue.get(socketId);\n  try {\n    if (!queue) {\n      return null;\n    }\n\n    if (!queue.has(id)) {\n      return null;\n    }\n\n    var result = queue.get(id);\n\n    // cleanup socket queue\n    queue.delete(id);\n\n    return result;\n  } finally {\n    if (queue && !queue.size) {\n      this.cbqueue.delete(socketId);\n    }\n  }\n};\n\nClient.prototype.clearCallbackQueue = function (socket, error) {\n  var socketId = socket.socketId;\n  var longpolling = socket.longpolling;\n\n  var queue = this.cbqueue.get(socketId);\n  if (!queue) {\n    return;\n  }\n\n  if (!longpolling) {\n    queue.forEach(function (handlers) {\n      var cb = handlers[1];\n      cb(error);\n    });\n  }\n\n  this.cbqueue.delete(socketId);\n};\n\nmodule.exports = Client;\n"]},"metadata":{},"sourceType":"script"}