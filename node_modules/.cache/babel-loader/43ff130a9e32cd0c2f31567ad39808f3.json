{"ast":null,"code":"'use strict';\n\nvar optional = require('optional');\n\nvar async = require('async');\n\nvar snappy = optional('snappy');\n\nif (snappy == null) {\n  var unavailableCodec = function unavailableCodec() {\n    throw new Error('Snappy codec is not installed');\n  };\n\n  module.exports = {\n    encode: unavailableCodec,\n    decode: unavailableCodec\n  };\n} else {\n  var SNAPPY_MAGIC_BYTES = [130, 83, 78, 65, 80, 80, 89, 0];\n  var SNAPPY_MAGIC_BYTES_LEN = SNAPPY_MAGIC_BYTES.length;\n  var SNAPPY_MAGIC = Buffer.from(SNAPPY_MAGIC_BYTES).toString('hex');\n  exports.encode = snappy.compress;\n  exports.decode = decodeSnappy;\n}\n\nfunction isChunked(buffer) {\n  var prefix = buffer.toString('hex', 0, SNAPPY_MAGIC_BYTES_LEN);\n  return prefix === SNAPPY_MAGIC;\n} // Ported from:\n// https://github.com/Shopify/sarama/blob/a3e2437d6d26cda6b2dc501dbdab4d3f6befa295/snappy.go\n\n\nfunction decodeSnappy(buffer, cb) {\n  if (isChunked(buffer)) {\n    var pos = 16;\n    var max = buffer.length;\n    var encoded = [];\n    var size;\n\n    while (pos < max) {\n      size = buffer.readUInt32BE(pos);\n      pos += 4;\n      encoded.push(buffer.slice(pos, pos + size));\n      pos += size;\n    }\n\n    return async.mapSeries(encoded, snappy.uncompress, function (err, decodedChunks) {\n      if (err) return cb(err);\n      return cb(null, Buffer.concat(decodedChunks));\n    });\n  }\n\n  return snappy.uncompress(buffer, cb);\n}","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/kafka-node/lib/codec/snappy.js"],"names":["optional","require","async","snappy","unavailableCodec","Error","module","exports","encode","decode","SNAPPY_MAGIC_BYTES","SNAPPY_MAGIC_BYTES_LEN","length","SNAPPY_MAGIC","Buffer","from","toString","compress","decodeSnappy","isChunked","buffer","prefix","cb","pos","max","encoded","size","readUInt32BE","push","slice","mapSeries","uncompress","err","decodedChunks","concat"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIE,MAAM,GAAGH,QAAQ,CAAC,QAAD,CAArB;;AAEA,IAAIG,MAAM,IAAI,IAAd,EAAoB;AAClB,MAAIC,gBAAgB,GAAG,SAASA,gBAAT,GAA6B;AAClD,UAAM,IAAIC,KAAJ,CAAU,+BAAV,CAAN;AACD,GAFD;;AAGAC,EAAAA,MAAM,CAACC,OAAP,GAAiB;AACfC,IAAAA,MAAM,EAAEJ,gBADO;AAEfK,IAAAA,MAAM,EAAEL;AAFO,GAAjB;AAID,CARD,MAQO;AACL,MAAIM,kBAAkB,GAAG,CAAC,GAAD,EAAM,EAAN,EAAU,EAAV,EAAc,EAAd,EAAkB,EAAlB,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,CAA9B,CAAzB;AACA,MAAIC,sBAAsB,GAAGD,kBAAkB,CAACE,MAAhD;AACA,MAAIC,YAAY,GAAGC,MAAM,CAACC,IAAP,CAAYL,kBAAZ,EAAgCM,QAAhC,CAAyC,KAAzC,CAAnB;AAEAT,EAAAA,OAAO,CAACC,MAAR,GAAiBL,MAAM,CAACc,QAAxB;AACAV,EAAAA,OAAO,CAACE,MAAR,GAAiBS,YAAjB;AACD;;AAED,SAASC,SAAT,CAAoBC,MAApB,EAA4B;AAC1B,MAAIC,MAAM,GAAGD,MAAM,CAACJ,QAAP,CAAgB,KAAhB,EAAuB,CAAvB,EAA0BL,sBAA1B,CAAb;AACA,SAAOU,MAAM,KAAKR,YAAlB;AACD,C,CAED;AACA;;;AACA,SAASK,YAAT,CAAuBE,MAAvB,EAA+BE,EAA/B,EAAmC;AACjC,MAAIH,SAAS,CAACC,MAAD,CAAb,EAAuB;AACrB,QAAIG,GAAG,GAAG,EAAV;AACA,QAAIC,GAAG,GAAGJ,MAAM,CAACR,MAAjB;AACA,QAAIa,OAAO,GAAG,EAAd;AACA,QAAIC,IAAJ;;AAEA,WAAOH,GAAG,GAAGC,GAAb,EAAkB;AAChBE,MAAAA,IAAI,GAAGN,MAAM,CAACO,YAAP,CAAoBJ,GAApB,CAAP;AACAA,MAAAA,GAAG,IAAI,CAAP;AACAE,MAAAA,OAAO,CAACG,IAAR,CAAaR,MAAM,CAACS,KAAP,CAAaN,GAAb,EAAkBA,GAAG,GAAGG,IAAxB,CAAb;AACAH,MAAAA,GAAG,IAAIG,IAAP;AACD;;AACD,WAAOxB,KAAK,CAAC4B,SAAN,CAAgBL,OAAhB,EAAyBtB,MAAM,CAAC4B,UAAhC,EAA4C,UAAUC,GAAV,EAAeC,aAAf,EAA8B;AAC/E,UAAID,GAAJ,EAAS,OAAOV,EAAE,CAACU,GAAD,CAAT;AACT,aAAOV,EAAE,CAAC,IAAD,EAAOR,MAAM,CAACoB,MAAP,CAAcD,aAAd,CAAP,CAAT;AACD,KAHM,CAAP;AAID;;AACD,SAAO9B,MAAM,CAAC4B,UAAP,CAAkBX,MAAlB,EAA0BE,EAA1B,CAAP;AACD","sourcesContent":["'use strict';\n\nvar optional = require('optional');\nvar async = require('async');\nvar snappy = optional('snappy');\n\nif (snappy == null) {\n  var unavailableCodec = function unavailableCodec () {\n    throw new Error('Snappy codec is not installed');\n  };\n  module.exports = {\n    encode: unavailableCodec,\n    decode: unavailableCodec\n  };\n} else {\n  var SNAPPY_MAGIC_BYTES = [130, 83, 78, 65, 80, 80, 89, 0];\n  var SNAPPY_MAGIC_BYTES_LEN = SNAPPY_MAGIC_BYTES.length;\n  var SNAPPY_MAGIC = Buffer.from(SNAPPY_MAGIC_BYTES).toString('hex');\n\n  exports.encode = snappy.compress;\n  exports.decode = decodeSnappy;\n}\n\nfunction isChunked (buffer) {\n  var prefix = buffer.toString('hex', 0, SNAPPY_MAGIC_BYTES_LEN);\n  return prefix === SNAPPY_MAGIC;\n}\n\n// Ported from:\n// https://github.com/Shopify/sarama/blob/a3e2437d6d26cda6b2dc501dbdab4d3f6befa295/snappy.go\nfunction decodeSnappy (buffer, cb) {\n  if (isChunked(buffer)) {\n    var pos = 16;\n    var max = buffer.length;\n    var encoded = [];\n    var size;\n\n    while (pos < max) {\n      size = buffer.readUInt32BE(pos);\n      pos += 4;\n      encoded.push(buffer.slice(pos, pos + size));\n      pos += size;\n    }\n    return async.mapSeries(encoded, snappy.uncompress, function (err, decodedChunks) {\n      if (err) return cb(err);\n      return cb(null, Buffer.concat(decodedChunks));\n    });\n  }\n  return snappy.uncompress(buffer, cb);\n}\n"]},"metadata":{},"sourceType":"script"}