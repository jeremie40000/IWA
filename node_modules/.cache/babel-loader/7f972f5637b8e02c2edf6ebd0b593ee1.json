{"ast":null,"code":"var Long = require('long');\n\nvar BufferMaker = function () {\n  this.plan = [];\n};\n\nvar types = {\n  \"UInt8\": {\n    bytes: 1\n  },\n  \"Int8\": {\n    bytes: 1\n  },\n  \"Int16BE\": {\n    bytes: 2\n  },\n  \"Int32BE\": {\n    bytes: 4\n  },\n  \"Int16LE\": {\n    bytes: 2\n  },\n  \"Int32LE\": {\n    bytes: 4\n  },\n  \"UInt16BE\": {\n    bytes: 2\n  },\n  \"UInt32BE\": {\n    bytes: 4\n  },\n  \"FloatLE\": {\n    bytes: 4\n  },\n  \"DoubleLE\": {\n    bytes: 8\n  },\n  \"FloatBE\": {\n    bytes: 4\n  },\n  \"DoubleBE\": {\n    bytes: 8\n  },\n  \"UInt16LE\": {\n    bytes: 2\n  },\n  \"UInt32LE\": {\n    bytes: 4\n  },\n  \"Int64BE\": {\n    bytes: 8\n  },\n  \"string\": {}\n}; // create methods for each type\n\nfunction addTypeMethod(type) {\n  BufferMaker.prototype[type] = function (val) {\n    this.plan.push({\n      type: type,\n      value: val\n    });\n    return this;\n  };\n}\n\nfor (var type in types) {\n  addTypeMethod(type);\n}\n\nBufferMaker.prototype.make = function () {\n  var bytecount = 0;\n  var offset = 0;\n  var item;\n  var i,\n      j = 0;\n\n  for (i = 0; i < this.plan.length; i++) {\n    item = this.plan[i];\n\n    if (item.type === 'string') {\n      if (Buffer.isBuffer(item.value)) {\n        bytecount += item.value.length;\n      } else {\n        bytecount += Buffer.byteLength(item.value);\n      }\n    } else {\n      bytecount += types[item.type].bytes;\n    }\n  }\n\n  var buffer = new Buffer(bytecount);\n\n  for (i = 0; i < this.plan.length; i++) {\n    item = this.plan[i];\n\n    switch (item.type) {\n      case \"Int64BE\":\n        var longVal = Long.fromString(item.value + \"\");\n        buffer.writeInt32BE(longVal.getHighBits(), offset); //write the high order bits (shifted over)\n\n        buffer.writeInt32BE(longVal.getLowBits(), offset + 4); //write the low order bits\n\n        offset += 8;\n        break;\n\n      case \"string\":\n        if (typeof item.value === 'string') {\n          buffer.write(item.value, offset);\n          offset += Buffer.byteLength(item.value);\n        } else {\n          item.value.copy(buffer, offset, 0);\n          offset += item.value.length;\n        }\n\n        break;\n\n      default:\n        buffer['write' + item.type](item.value, offset);\n        offset += types[item.type].bytes;\n    }\n  }\n\n  return buffer;\n};\n\nmodule.exports = BufferMaker;","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/buffermaker/lib/BufferMaker.js"],"names":["Long","require","BufferMaker","plan","types","bytes","addTypeMethod","type","prototype","val","push","value","make","bytecount","offset","item","i","j","length","Buffer","isBuffer","byteLength","buffer","longVal","fromString","writeInt32BE","getHighBits","getLowBits","write","copy","module","exports"],"mappings":"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","sourcesContent":["var Long = require('long');\n\n\nvar BufferMaker = function(){\n  this.plan = [];\n};\n\nvar types = {\"UInt8\" : { bytes : 1},\n              \"Int8\" : { bytes : 1},\n              \"Int16BE\" : { bytes : 2},\n              \"Int32BE\" : { bytes : 4},\n              \"Int16LE\" : { bytes : 2},\n              \"Int32LE\" : { bytes : 4},\n              \"UInt16BE\" : { bytes : 2},\n              \"UInt32BE\" : { bytes : 4},\n              \"FloatLE\" : { bytes : 4},\n              \"DoubleLE\" : { bytes: 8},\n              \"FloatBE\" : { bytes : 4},\n              \"DoubleBE\" : { bytes : 8},\n              \"UInt16LE\" : { bytes : 2},\n              \"UInt32LE\" : { bytes : 4},\n              \"Int64BE\" : { bytes : 8},\n              \"string\" : {}\n            };\n\n// create methods for each type\nfunction addTypeMethod(type){\n  BufferMaker.prototype[type] = function(val){\n    this.plan.push({ type : type, value : val});\n    return this;\n  };\n}\n\nfor(var type in types){\n  addTypeMethod(type);\n}\n\n\nBufferMaker.prototype.make = function(){\n  var bytecount = 0;\n  var offset = 0;\n  var item;\n  var i, j = 0;\n  for(i = 0; i < this.plan.length; i++){\n    item = this.plan[i];\n    if (item.type === 'string'){\n      if (Buffer.isBuffer(item.value)){\n        bytecount += item.value.length;\n      } else {\n        bytecount += Buffer.byteLength(item.value);\n      }\n    } else {\n      bytecount += types[item.type].bytes;\n    }\n  }\n  var buffer = new Buffer(bytecount);\n  for(i = 0; i < this.plan.length; i++){\n    item = this.plan[i];\n    switch(item.type){\n      case \"Int64BE\":\n        var longVal = Long.fromString(item.value  + \"\");\n        buffer.writeInt32BE(longVal.getHighBits(), offset); //write the high order bits (shifted over)\n        buffer.writeInt32BE(longVal.getLowBits(), offset + 4); //write the low order bits\n        offset += 8;\n        break;\n      case \"string\": \n        if (typeof item.value === 'string'){\n          buffer.write(item.value, offset);\n          offset += Buffer.byteLength(item.value);\n        } else {\n          item.value.copy(buffer, offset, 0);\n          offset += item.value.length;\n        }\n\n        break;\n      default :\n        buffer['write' + item.type](item.value, offset);\n        offset += types[item.type].bytes;\n    }\n  }\n  return buffer;\n\n};\n\nmodule.exports = BufferMaker;\n"]},"metadata":{},"sourceType":"script"}