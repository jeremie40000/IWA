{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst Transform = stream.Transform;\n\nconst _ = require('lodash');\n\nvar DEFAULTS = {\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  autoCommitMsgCount: 100,\n  // Whether to act as a transform stream and emit the events we observe.\n  // If we write all data this stream will fill its buffer and then provide\n  // backpressure preventing our continued reading.\n  passthrough: false\n};\n\nclass CommitStream extends Transform {\n  constructor(client, topics, groupId, options) {\n    options = options || {};\n\n    let parentOptions = _.defaults({\n      highWaterMark: options.highWaterMark\n    }, {\n      objectMode: true\n    });\n\n    super(parentOptions);\n    this.options = _.defaults(options || {}, DEFAULTS);\n    this.client = client;\n    this.topicPartionOffsets = this.buildTopicData(_.cloneDeep(topics));\n    this.committing = false;\n    this.groupId = groupId;\n    this.autoCommit = options.autoCommit;\n    this.autoCommitMsgCount = options.autoCommitMsgCount;\n    this.autoCommitIntervalMs = options.autoCommitIntervalMs;\n    this.autoCommitIntervalTimer = null;\n\n    if (this.autoCommit && this.autoCommitIntervalMs) {\n      this.autoCommitIntervalTimer = setInterval(function () {\n        this.commit();\n      }.bind(this), this.autoCommitIntervalMs);\n    }\n\n    this.messageCount = 0;\n  }\n  /**\n   * Extend Transform::on() to act as a pipe if someone consumes data from us.\n   */\n\n\n  on(eventName) {\n    if (eventName === 'data') {\n      this.options.passthrough = true;\n    }\n\n    super.on.apply(this, arguments);\n  }\n  /**\n   * Extend Transform::pipe() to act as a pipe if someone consumes data from us.\n   */\n\n\n  pipe() {\n    this.options.passthrough = true;\n    super.pipe.apply(this, arguments);\n  }\n\n  _transform(data, encoding, done) {\n    let topicUpdate = {};\n    let self = this;\n    topicUpdate[data.topic] = {};\n    topicUpdate[data.topic][data.partition] = data.offset;\n    self.updateOffsets(topicUpdate);\n    self.messageCount++;\n\n    const doneWrapper = function () {\n      // We need to act as a through stream if we are not\n      // purely a terminal write stream.\n      if (self.options.passthrough) {\n        return done(null, data);\n      }\n\n      done();\n    };\n\n    if (self.autoCommit && self.messageCount === self.autoCommitMsgCount) {\n      self.messageCount = 0;\n      return self.commit(doneWrapper);\n    }\n\n    doneWrapper();\n  }\n\n  buildTopicData(topicPartions) {\n    return topicPartions.map(function (partion) {\n      if (typeof partion !== 'object') partion = {\n        topic: partion\n      };\n      partion.partition = partion.partition || 0;\n      partion.offset = partion.offset || 0; // Metadata can be arbitrary\n\n      partion.metadata = 'm';\n      return partion;\n    });\n  }\n  /**\n   * @param {Object} topics - An object containing topic offset data keyed by\n   *   topic with keys for partion containing the offset last seen.\n   */\n\n\n  updateOffsets(topics, initing) {\n    this.topicPartionOffsets.forEach(function (p) {\n      if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n        var offset = topics[p.topic][p.partition];\n        if (offset === -1) offset = 0; // Note, we track the offset of the next message we want to see,\n        // not the most recent message we have seen.\n\n        if (!initing) p.offset = offset + 1;else p.offset = offset;\n      }\n    });\n  }\n  /**\n   * Clear the autocommit interval of this commitStream if set.\n   */\n\n\n  clearInterval() {\n    clearInterval(this.autoCommitIntervalTimer);\n  }\n\n  commit(cb) {\n    let self = this;\n\n    if (!cb) {\n      cb = function noop() {};\n    }\n\n    if (self.committing) {\n      return cb(null, 'Commit in progress');\n    }\n\n    let topicPartionOffsets = self.topicPartionOffsets;\n    let commits = topicPartionOffsets.filter(function (partition) {\n      return partition.offset !== 0;\n    });\n\n    if (commits.length) {\n      self.committing = true;\n      self.client.sendOffsetCommitRequest(self.groupId, commits, function () {\n        self.emit('commitComplete', {\n          group: self.groupId,\n          commits\n        });\n        self.committing = false;\n        cb.apply(this, arguments);\n      });\n    } else {\n      cb(null, 'Nothing to be committed');\n    }\n  }\n\n}\n\nmodule.exports = CommitStream;","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/kafka-node/lib/commitStream.js"],"names":["stream","require","Transform","_","DEFAULTS","autoCommit","autoCommitIntervalMs","autoCommitMsgCount","passthrough","CommitStream","constructor","client","topics","groupId","options","parentOptions","defaults","highWaterMark","objectMode","topicPartionOffsets","buildTopicData","cloneDeep","committing","autoCommitIntervalTimer","setInterval","commit","bind","messageCount","on","eventName","apply","arguments","pipe","_transform","data","encoding","done","topicUpdate","self","topic","partition","offset","updateOffsets","doneWrapper","topicPartions","map","partion","metadata","initing","forEach","p","isEmpty","undefined","clearInterval","cb","noop","commits","filter","length","sendOffsetCommitRequest","emit","group","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst Transform = stream.Transform;\n\nconst _ = require('lodash');\n\nvar DEFAULTS = {\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  autoCommitMsgCount: 100,\n  // Whether to act as a transform stream and emit the events we observe.\n  // If we write all data this stream will fill its buffer and then provide\n  // backpressure preventing our continued reading.\n  passthrough: false\n};\n\nclass CommitStream extends Transform {\n  constructor (client, topics, groupId, options) {\n    options = options || {};\n    let parentOptions = _.defaults({ highWaterMark: options.highWaterMark }, { objectMode: true });\n    super(parentOptions);\n\n    this.options = _.defaults(options || {}, DEFAULTS);\n    this.client = client;\n    this.topicPartionOffsets = this.buildTopicData(_.cloneDeep(topics));\n\n    this.committing = false;\n    this.groupId = groupId;\n\n    this.autoCommit = options.autoCommit;\n    this.autoCommitMsgCount = options.autoCommitMsgCount;\n    this.autoCommitIntervalMs = options.autoCommitIntervalMs;\n\n    this.autoCommitIntervalTimer = null;\n\n    if (this.autoCommit && this.autoCommitIntervalMs) {\n      this.autoCommitIntervalTimer = setInterval(\n        function () {\n          this.commit();\n        }.bind(this),\n        this.autoCommitIntervalMs\n      );\n    }\n\n    this.messageCount = 0;\n  }\n\n  /**\n   * Extend Transform::on() to act as a pipe if someone consumes data from us.\n   */\n  on (eventName) {\n    if (eventName === 'data') {\n      this.options.passthrough = true;\n    }\n    super.on.apply(this, arguments);\n  }\n\n  /**\n   * Extend Transform::pipe() to act as a pipe if someone consumes data from us.\n   */\n  pipe () {\n    this.options.passthrough = true;\n    super.pipe.apply(this, arguments);\n  }\n\n  _transform (data, encoding, done) {\n    let topicUpdate = {};\n    let self = this;\n    topicUpdate[data.topic] = {};\n    topicUpdate[data.topic][data.partition] = data.offset;\n    self.updateOffsets(topicUpdate);\n    self.messageCount++;\n    const doneWrapper = function () {\n      // We need to act as a through stream if we are not\n      // purely a terminal write stream.\n      if (self.options.passthrough) {\n        return done(null, data);\n      }\n      done();\n    };\n    if (self.autoCommit && self.messageCount === self.autoCommitMsgCount) {\n      self.messageCount = 0;\n      return self.commit(doneWrapper);\n    }\n    doneWrapper();\n  }\n\n  buildTopicData (topicPartions) {\n    return topicPartions.map(function (partion) {\n      if (typeof partion !== 'object') partion = { topic: partion };\n      partion.partition = partion.partition || 0;\n      partion.offset = partion.offset || 0;\n      // Metadata can be arbitrary\n      partion.metadata = 'm';\n      return partion;\n    });\n  }\n\n  /**\n   * @param {Object} topics - An object containing topic offset data keyed by\n   *   topic with keys for partion containing the offset last seen.\n   */\n  updateOffsets (topics, initing) {\n    this.topicPartionOffsets.forEach(function (p) {\n      if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n        var offset = topics[p.topic][p.partition];\n        if (offset === -1) offset = 0;\n        // Note, we track the offset of the next message we want to see,\n        // not the most recent message we have seen.\n        if (!initing) p.offset = offset + 1;\n        else p.offset = offset;\n      }\n    });\n  }\n\n  /**\n   * Clear the autocommit interval of this commitStream if set.\n   */\n  clearInterval () {\n    clearInterval(this.autoCommitIntervalTimer);\n  }\n\n  commit (cb) {\n    let self = this;\n\n    if (!cb) {\n      cb = function noop () {};\n    }\n\n    if (self.committing) {\n      return cb(null, 'Commit in progress');\n    }\n\n    let topicPartionOffsets = self.topicPartionOffsets;\n\n    let commits = topicPartionOffsets.filter(function (partition) {\n      return partition.offset !== 0;\n    });\n\n    if (commits.length) {\n      self.committing = true;\n      self.client.sendOffsetCommitRequest(self.groupId, commits, function () {\n        self.emit('commitComplete', { group: self.groupId, commits });\n        self.committing = false;\n        cb.apply(this, arguments);\n      });\n    } else {\n      cb(null, 'Nothing to be committed');\n    }\n  }\n}\n\nmodule.exports = CommitStream;\n"]},"metadata":{},"sourceType":"script"}