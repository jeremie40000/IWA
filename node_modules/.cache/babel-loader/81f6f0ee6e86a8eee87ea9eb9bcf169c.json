{"ast":null,"code":"'use strict';\n\nconst Readable = require('stream').Readable;\n\nconst ConsumerGroup = require('./consumerGroup');\n\nconst _ = require('lodash');\n\nconst logger = require('./logging')('kafka-node:ConsumerGroupStream');\n\nconst async = require('async');\n\nconst DEFAULT_HIGH_WATER_MARK = 100;\n\nconst Denque = require('denque');\n\nconst DEFAULTS = {\n  autoCommit: true\n};\n\nfunction convertToCommitPayload(messages) {\n  const ret = [];\n\n  _.forEach(messages, function (partitionOffset, topic) {\n    _.forEach(partitionOffset, function (offset, partition) {\n      if (offset != null) {\n        ret.push({\n          topic: topic,\n          partition: partition,\n          offset: offset,\n          metadata: 'm'\n        });\n      }\n    });\n  });\n\n  return ret;\n}\n\nclass ConsumerGroupStream extends Readable {\n  constructor(options, topics) {\n    super({\n      objectMode: true,\n      highWaterMark: options.highWaterMark || DEFAULT_HIGH_WATER_MARK\n    });\n\n    _.defaultsDeep(options || {}, DEFAULTS);\n\n    const self = this;\n    this.autoCommit = options.autoCommit;\n    options.connectOnReady = false;\n    options.autoCommit = false;\n    const originalOnRebalance = options.onRebalance;\n\n    options.onRebalance = function (isAlreadyMember, callback) {\n      const autoCommit = _.once(function (err) {\n        if (err) {\n          callback(err);\n        } else {\n          self.commit(null, true, callback);\n        }\n      });\n\n      if (typeof originalOnRebalance === 'function') {\n        try {\n          originalOnRebalance(isAlreadyMember, autoCommit);\n        } catch (e) {\n          autoCommit(e);\n        }\n      } else {\n        autoCommit();\n      }\n    };\n\n    this.consumerGroup = new ConsumerGroup(options, topics);\n    this.messageBuffer = new Denque();\n    this.commitQueue = {};\n    this.consumerGroup.on('error', error => this.emit('error', error));\n    this.consumerGroup.on('connect', () => this.emit('connect'));\n    this.consumerGroup.on('message', message => {\n      this.messageBuffer.push(message);\n      this.consumerGroup.pause();\n    });\n    this.consumerGroup.on('done', message => {\n      setImmediate(() => this.transmitMessages());\n    });\n  }\n\n  emit(event, value) {\n    if (event === 'data' && this.autoCommit && !_.isEmpty(value)) {\n      setImmediate(() => this.commit(value));\n    }\n\n    super.emit.apply(this, arguments);\n  }\n\n  _read() {\n    logger.debug('_read called');\n\n    if (!this.consumerGroup.ready) {\n      logger.debug('consumerGroup is not ready, calling consumerGroup.connect');\n      this.consumerGroup.connect();\n    }\n\n    this._reading = true;\n    this.transmitMessages();\n  }\n\n  commit(message, force, callback) {\n    if (message != null && message.offset !== -1) {\n      _.set(this.commitQueue, [message.topic, message.partition], message.offset + 1);\n    }\n\n    if (this.committing && !force) {\n      logger.debug('skipping committing');\n      return callback && callback(null);\n    }\n\n    const commits = convertToCommitPayload(this.commitQueue);\n    this.commitQueued(commits, force, callback);\n  }\n\n  commitQueued(commits, force, callback) {\n    if (!force) {\n      this.committing = true;\n      this.autoCommitTimer = setTimeout(() => {\n        logger.debug('setting committing to false');\n        this.committing = false;\n        const queuedCommits = convertToCommitPayload(this.commitQueue);\n        if (!_.isEmpty(queuedCommits)) this.commitQueued(queuedCommits);\n      }, this.consumerGroup.options.autoCommitIntervalMs);\n    }\n\n    if (_.isEmpty(commits)) {\n      logger.debug('commit ignored. no commits to make.');\n      return callback && callback(null);\n    }\n\n    logger.debug('committing', commits);\n    this.consumerGroup.sendOffsetCommitRequest(commits, error => {\n      if (error) {\n        logger.error('commit request failed', error);\n\n        if (callback) {\n          return callback(error);\n        }\n\n        this.emit('error', error);\n        return;\n      }\n\n      for (let tp of commits) {\n        if (_.get(this.commitQueue, [tp.topic, tp.partition]) === tp.offset) {\n          this.commitQueue[tp.topic][tp.partition] = null;\n        }\n      }\n\n      callback && callback(null);\n    });\n  }\n\n  transmitMessages() {\n    while (this._reading && !this.messageBuffer.isEmpty()) {\n      this._reading = this.push(this.messageBuffer.shift());\n    }\n\n    if (this.messageBuffer.isEmpty() && this._reading) {\n      this.consumerGroup.resume();\n    }\n  }\n\n  close(callback) {\n    clearTimeout(this.autoCommitTimer);\n    async.series([callback => {\n      if (this.autoCommit) {\n        this.commit(null, true, callback);\n      } else {\n        callback(null);\n      }\n    }, callback => {\n      this.consumerGroup.close(false, () => {\n        callback();\n        this.emit('close');\n      });\n    }], callback || _.noop);\n  }\n\n  _destroy() {\n    this.close();\n  }\n\n}\n\nmodule.exports = ConsumerGroupStream;","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/kafka-node/lib/consumerGroupStream.js"],"names":["Readable","require","ConsumerGroup","_","logger","async","DEFAULT_HIGH_WATER_MARK","Denque","DEFAULTS","autoCommit","convertToCommitPayload","messages","ret","forEach","partitionOffset","topic","offset","partition","push","metadata","ConsumerGroupStream","constructor","options","topics","objectMode","highWaterMark","defaultsDeep","self","connectOnReady","originalOnRebalance","onRebalance","isAlreadyMember","callback","once","err","commit","e","consumerGroup","messageBuffer","commitQueue","on","error","emit","message","pause","setImmediate","transmitMessages","event","value","isEmpty","apply","arguments","_read","debug","ready","connect","_reading","force","set","committing","commits","commitQueued","autoCommitTimer","setTimeout","queuedCommits","autoCommitIntervalMs","sendOffsetCommitRequest","tp","get","shift","resume","close","clearTimeout","series","noop","_destroy","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Readable = require('stream').Readable;\nconst ConsumerGroup = require('./consumerGroup');\nconst _ = require('lodash');\nconst logger = require('./logging')('kafka-node:ConsumerGroupStream');\nconst async = require('async');\nconst DEFAULT_HIGH_WATER_MARK = 100;\nconst Denque = require('denque');\n\nconst DEFAULTS = {\n  autoCommit: true\n};\n\nfunction convertToCommitPayload (messages) {\n  const ret = [];\n  _.forEach(messages, function (partitionOffset, topic) {\n    _.forEach(partitionOffset, function (offset, partition) {\n      if (offset != null) {\n        ret.push({\n          topic: topic,\n          partition: partition,\n          offset: offset,\n          metadata: 'm'\n        });\n      }\n    });\n  });\n  return ret;\n}\n\nclass ConsumerGroupStream extends Readable {\n  constructor (options, topics) {\n    super({ objectMode: true, highWaterMark: options.highWaterMark || DEFAULT_HIGH_WATER_MARK });\n\n    _.defaultsDeep(options || {}, DEFAULTS);\n    const self = this;\n\n    this.autoCommit = options.autoCommit;\n\n    options.connectOnReady = false;\n    options.autoCommit = false;\n    const originalOnRebalance = options.onRebalance;\n    options.onRebalance = function (isAlreadyMember, callback) {\n      const autoCommit = _.once(function (err) {\n        if (err) {\n          callback(err);\n        } else {\n          self.commit(null, true, callback);\n        }\n      });\n      if (typeof originalOnRebalance === 'function') {\n        try {\n          originalOnRebalance(isAlreadyMember, autoCommit);\n        } catch (e) {\n          autoCommit(e);\n        }\n      } else {\n        autoCommit();\n      }\n    };\n\n    this.consumerGroup = new ConsumerGroup(options, topics);\n\n    this.messageBuffer = new Denque();\n    this.commitQueue = {};\n\n    this.consumerGroup.on('error', error => this.emit('error', error));\n    this.consumerGroup.on('connect', () => this.emit('connect'));\n    this.consumerGroup.on('message', message => {\n      this.messageBuffer.push(message);\n      this.consumerGroup.pause();\n    });\n    this.consumerGroup.on('done', message => {\n      setImmediate(() => this.transmitMessages());\n    });\n  }\n\n  emit (event, value) {\n    if (event === 'data' && this.autoCommit && !_.isEmpty(value)) {\n      setImmediate(() => this.commit(value));\n    }\n    super.emit.apply(this, arguments);\n  }\n\n  _read () {\n    logger.debug('_read called');\n    if (!this.consumerGroup.ready) {\n      logger.debug('consumerGroup is not ready, calling consumerGroup.connect');\n      this.consumerGroup.connect();\n    }\n    this._reading = true;\n    this.transmitMessages();\n  }\n\n  commit (message, force, callback) {\n    if (message != null && message.offset !== -1) {\n      _.set(this.commitQueue, [message.topic, message.partition], message.offset + 1);\n    }\n\n    if (this.committing && !force) {\n      logger.debug('skipping committing');\n      return callback && callback(null);\n    }\n\n    const commits = convertToCommitPayload(this.commitQueue);\n    this.commitQueued(commits, force, callback);\n  }\n\n  commitQueued (commits, force, callback) {\n    if (!force) {\n      this.committing = true;\n\n      this.autoCommitTimer = setTimeout(() => {\n        logger.debug('setting committing to false');\n        this.committing = false;\n\n        const queuedCommits = convertToCommitPayload(this.commitQueue);\n        if (!_.isEmpty(queuedCommits)) this.commitQueued(queuedCommits);\n      }, this.consumerGroup.options.autoCommitIntervalMs);\n    }\n\n    if (_.isEmpty(commits)) {\n      logger.debug('commit ignored. no commits to make.');\n      return callback && callback(null);\n    }\n\n    logger.debug('committing', commits);\n\n    this.consumerGroup.sendOffsetCommitRequest(commits, error => {\n      if (error) {\n        logger.error('commit request failed', error);\n        if (callback) {\n          return callback(error);\n        }\n        this.emit('error', error);\n        return;\n      }\n      for (let tp of commits) {\n        if (_.get(this.commitQueue, [tp.topic, tp.partition]) === tp.offset) {\n          this.commitQueue[tp.topic][tp.partition] = null;\n        }\n      }\n      callback && callback(null);\n    });\n  }\n\n  transmitMessages () {\n    while (this._reading && !this.messageBuffer.isEmpty()) {\n      this._reading = this.push(this.messageBuffer.shift());\n    }\n    if (this.messageBuffer.isEmpty() && this._reading) {\n      this.consumerGroup.resume();\n    }\n  }\n\n  close (callback) {\n    clearTimeout(this.autoCommitTimer);\n    async.series(\n      [\n        callback => {\n          if (this.autoCommit) {\n            this.commit(null, true, callback);\n          } else {\n            callback(null);\n          }\n        },\n        callback => {\n          this.consumerGroup.close(false, () => {\n            callback();\n            this.emit('close');\n          });\n        }\n      ],\n      callback || _.noop\n    );\n  }\n\n  _destroy () {\n    this.close();\n  }\n}\n\nmodule.exports = ConsumerGroupStream;\n"]},"metadata":{},"sourceType":"script"}