{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar util = require('util');\n\nvar EventEmitter = require('events');\n\nvar _ = require('lodash');\n\nvar protocol = require('./protocol');\n\nvar Message = protocol.Message;\nvar KeyedMessage = protocol.KeyedMessage;\nvar ProduceRequest = protocol.ProduceRequest;\n\nvar partitioner = require('./partitioner');\n\nvar DefaultPartitioner = partitioner.DefaultPartitioner;\nvar RandomPartitioner = partitioner.RandomPartitioner;\nvar CyclicPartitioner = partitioner.CyclicPartitioner;\nvar KeyedPartitioner = partitioner.KeyedPartitioner;\nvar CustomPartitioner = partitioner.CustomPartitioner;\nvar PARTITIONER_TYPES = {\n  default: 0,\n  random: 1,\n  cyclic: 2,\n  keyed: 3,\n  custom: 4\n};\nvar PARTITIONER_MAP = {\n  0: DefaultPartitioner,\n  1: RandomPartitioner,\n  2: CyclicPartitioner,\n  3: KeyedPartitioner,\n  4: CustomPartitioner\n};\nvar DEFAULTS = {\n  requireAcks: 1,\n  ackTimeoutMs: 100\n};\n/**\n * Provides common functionality for a kafka producer\n *\n * @param {Client} client A kafka client object to use for the producer\n * @param {Object} [options] An object containing configuration options\n * @param {Number} [options.requireAcks=1] Configuration for when to consider a message as acknowledged.\n *      <li>0 = No ack required</li>\n *      <li>1 = Leader ack required</li>\n *      <li>-1 = All in sync replicas ack required</li>\n *\n * @param {Number} [options.ackTimeoutMs=100] The amount of time in milliseconds to wait for all acks before considered\n *      the message as errored\n * @param {Number} [defaultPartitionType] The default partitioner type\n * @param {Object} [customPartitioner] a custom partitinoer to use of the form: function (partitions, key)\n * @constructor\n */\n\nfunction BaseProducer(client, options, defaultPartitionerType, customPartitioner) {\n  EventEmitter.call(this);\n  options = options || {};\n  this.ready = false;\n  this.client = client;\n  this.requireAcks = options.requireAcks === undefined ? DEFAULTS.requireAcks : options.requireAcks;\n  this.ackTimeoutMs = options.ackTimeoutMs === undefined ? DEFAULTS.ackTimeoutMs : options.ackTimeoutMs;\n\n  if (customPartitioner !== undefined && options.partitionerType !== PARTITIONER_TYPES.custom) {\n    throw new Error('Partitioner Type must be custom if providing a customPartitioner.');\n  } else if (customPartitioner === undefined && options.partitionerType === PARTITIONER_TYPES.custom) {\n    throw new Error('No customer partitioner defined');\n  }\n\n  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType]; // eslint-disable-next-line\n\n  this.partitioner = new partitionerType(customPartitioner);\n  this.connect();\n}\n\nutil.inherits(BaseProducer, EventEmitter);\n\nBaseProducer.prototype.connect = function () {\n  // emiter...\n  var self = this;\n  this.ready = this.client.ready;\n  if (this.ready) self.emit('ready');\n  this.client.on('ready', function () {\n    if (!self.ready) {\n      self.ready = true;\n      self.emit('ready');\n    }\n  });\n  this.client.on('brokersChanged', function () {\n    let topics = Object.keys(this.topicMetadata);\n    this.refreshMetadata(topics, function (error) {\n      if (error) {\n        self.emit('error', error);\n      }\n    });\n  });\n  this.client.on('error', function (err) {\n    self.emit('error', err);\n  });\n  this.client.on('close', function () {});\n};\n/**\n * Sends a new message or array of messages to a topic/partition\n * This will use the\n *\n * @see Client#sendProduceRequest for a more low level way to send messages to kafka\n *\n * @param {Array.<BaseProducer~sendPayload>} payloads An array of topic payloads\n * @param {BaseProducer~sendCallback} cb A function to call once the send has completed\n */\n\n\nBaseProducer.prototype.send = function (payloads, cb) {\n  var client = this.client;\n  var requireAcks = this.requireAcks;\n  var ackTimeoutMs = this.ackTimeoutMs;\n  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);\n};\n\nBaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {\n  const topicPartitionRequests = Object.create(null);\n  payloads.forEach(p => {\n    p.partition = p.hasOwnProperty('partition') ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic], 'partition'), p.key);\n    p.attributes = p.hasOwnProperty('attributes') ? p.attributes : 0;\n    let messages = _.isArray(p.messages) ? p.messages : [p.messages];\n    messages = messages.map(function (message) {\n      if (message instanceof KeyedMessage) {\n        return message;\n      }\n\n      return new Message(0, 0, p.key, message, p.timestamp || Date.now());\n    });\n    let key = p.topic + p.partition;\n    let request = topicPartitionRequests[key];\n\n    if (request == null) {\n      topicPartitionRequests[key] = new ProduceRequest(p.topic, p.partition, messages, p.attributes);\n    } else {\n      assert(request.attributes === p.attributes);\n      Array.prototype.push.apply(request.messages, messages);\n    }\n  });\n  return _.values(topicPartitionRequests);\n};\n\nBaseProducer.prototype.createTopics = function (topics, async, cb) {\n  if (!this.ready) {\n    return cb(new Error('Producer not ready!'));\n  }\n\n  this.client.createTopics(topics, async, cb);\n};\n\nBaseProducer.prototype.close = function (cb) {\n  this.client.close(cb);\n};\n\nBaseProducer.PARTITIONER_TYPES = PARTITIONER_TYPES;\nmodule.exports = BaseProducer;","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/kafka-node/lib/baseProducer.js"],"names":["assert","require","util","EventEmitter","_","protocol","Message","KeyedMessage","ProduceRequest","partitioner","DefaultPartitioner","RandomPartitioner","CyclicPartitioner","KeyedPartitioner","CustomPartitioner","PARTITIONER_TYPES","default","random","cyclic","keyed","custom","PARTITIONER_MAP","DEFAULTS","requireAcks","ackTimeoutMs","BaseProducer","client","options","defaultPartitionerType","customPartitioner","call","ready","undefined","partitionerType","Error","connect","inherits","prototype","self","emit","on","topics","Object","keys","topicMetadata","refreshMetadata","error","err","send","payloads","cb","sendProduceRequest","buildPayloads","topicPartitionRequests","create","forEach","p","partition","hasOwnProperty","getPartition","map","topic","key","attributes","messages","isArray","message","timestamp","Date","now","request","Array","push","apply","values","createTopics","async","close","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,YAAY,GAAGF,OAAO,CAAC,QAAD,CAA1B;;AACA,IAAIG,CAAC,GAAGH,OAAO,CAAC,QAAD,CAAf;;AACA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIK,OAAO,GAAGD,QAAQ,CAACC,OAAvB;AACA,IAAIC,YAAY,GAAGF,QAAQ,CAACE,YAA5B;AACA,IAAIC,cAAc,GAAGH,QAAQ,CAACG,cAA9B;;AACA,IAAIC,WAAW,GAAGR,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIS,kBAAkB,GAAGD,WAAW,CAACC,kBAArC;AACA,IAAIC,iBAAiB,GAAGF,WAAW,CAACE,iBAApC;AACA,IAAIC,iBAAiB,GAAGH,WAAW,CAACG,iBAApC;AACA,IAAIC,gBAAgB,GAAGJ,WAAW,CAACI,gBAAnC;AACA,IAAIC,iBAAiB,GAAGL,WAAW,CAACK,iBAApC;AAEA,IAAIC,iBAAiB,GAAG;AACtBC,EAAAA,OAAO,EAAE,CADa;AAEtBC,EAAAA,MAAM,EAAE,CAFc;AAGtBC,EAAAA,MAAM,EAAE,CAHc;AAItBC,EAAAA,KAAK,EAAE,CAJe;AAKtBC,EAAAA,MAAM,EAAE;AALc,CAAxB;AAQA,IAAIC,eAAe,GAAG;AACpB,KAAGX,kBADiB;AAEpB,KAAGC,iBAFiB;AAGpB,KAAGC,iBAHiB;AAIpB,KAAGC,gBAJiB;AAKpB,KAAGC;AALiB,CAAtB;AAQA,IAAIQ,QAAQ,GAAG;AACbC,EAAAA,WAAW,EAAE,CADA;AAEbC,EAAAA,YAAY,EAAE;AAFD,CAAf;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAuBC,MAAvB,EAA+BC,OAA/B,EAAwCC,sBAAxC,EAAgEC,iBAAhE,EAAmF;AACjF1B,EAAAA,YAAY,CAAC2B,IAAb,CAAkB,IAAlB;AACAH,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,OAAKI,KAAL,GAAa,KAAb;AACA,OAAKL,MAAL,GAAcA,MAAd;AAEA,OAAKH,WAAL,GAAmBI,OAAO,CAACJ,WAAR,KAAwBS,SAAxB,GAAoCV,QAAQ,CAACC,WAA7C,GAA2DI,OAAO,CAACJ,WAAtF;AACA,OAAKC,YAAL,GAAoBG,OAAO,CAACH,YAAR,KAAyBQ,SAAzB,GAAqCV,QAAQ,CAACE,YAA9C,GAA6DG,OAAO,CAACH,YAAzF;;AAEA,MAAIK,iBAAiB,KAAKG,SAAtB,IAAmCL,OAAO,CAACM,eAAR,KAA4BlB,iBAAiB,CAACK,MAArF,EAA6F;AAC3F,UAAM,IAAIc,KAAJ,CAAU,mEAAV,CAAN;AACD,GAFD,MAEO,IAAIL,iBAAiB,KAAKG,SAAtB,IAAmCL,OAAO,CAACM,eAAR,KAA4BlB,iBAAiB,CAACK,MAArF,EAA6F;AAClG,UAAM,IAAIc,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAED,MAAID,eAAe,GAAGZ,eAAe,CAACM,OAAO,CAACM,eAAT,CAAf,IAA4CZ,eAAe,CAACO,sBAAD,CAAjF,CAhBiF,CAkBjF;;AACA,OAAKnB,WAAL,GAAmB,IAAIwB,eAAJ,CAAoBJ,iBAApB,CAAnB;AAEA,OAAKM,OAAL;AACD;;AAEDjC,IAAI,CAACkC,QAAL,CAAcX,YAAd,EAA4BtB,YAA5B;;AAEAsB,YAAY,CAACY,SAAb,CAAuBF,OAAvB,GAAiC,YAAY;AAC3C;AACA,MAAIG,IAAI,GAAG,IAAX;AACA,OAAKP,KAAL,GAAa,KAAKL,MAAL,CAAYK,KAAzB;AACA,MAAI,KAAKA,KAAT,EAAgBO,IAAI,CAACC,IAAL,CAAU,OAAV;AAChB,OAAKb,MAAL,CAAYc,EAAZ,CAAe,OAAf,EAAwB,YAAY;AAClC,QAAI,CAACF,IAAI,CAACP,KAAV,EAAiB;AACfO,MAAAA,IAAI,CAACP,KAAL,GAAa,IAAb;AACAO,MAAAA,IAAI,CAACC,IAAL,CAAU,OAAV;AACD;AACF,GALD;AAMA,OAAKb,MAAL,CAAYc,EAAZ,CAAe,gBAAf,EAAiC,YAAY;AAC3C,QAAIC,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAY,KAAKC,aAAjB,CAAb;AACA,SAAKC,eAAL,CAAqBJ,MAArB,EAA6B,UAAUK,KAAV,EAAiB;AAC5C,UAAIA,KAAJ,EAAW;AACTR,QAAAA,IAAI,CAACC,IAAL,CAAU,OAAV,EAAmBO,KAAnB;AACD;AACF,KAJD;AAKD,GAPD;AAQA,OAAKpB,MAAL,CAAYc,EAAZ,CAAe,OAAf,EAAwB,UAAUO,GAAV,EAAe;AACrCT,IAAAA,IAAI,CAACC,IAAL,CAAU,OAAV,EAAmBQ,GAAnB;AACD,GAFD;AAGA,OAAKrB,MAAL,CAAYc,EAAZ,CAAe,OAAf,EAAwB,YAAY,CAAE,CAAtC;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAf,YAAY,CAACY,SAAb,CAAuBW,IAAvB,GAA8B,UAAUC,QAAV,EAAoBC,EAApB,EAAwB;AACpD,MAAIxB,MAAM,GAAG,KAAKA,MAAlB;AACA,MAAIH,WAAW,GAAG,KAAKA,WAAvB;AACA,MAAIC,YAAY,GAAG,KAAKA,YAAxB;AAEAE,EAAAA,MAAM,CAACyB,kBAAP,CAA0B,KAAKC,aAAL,CAAmBH,QAAnB,EAA6BvB,MAAM,CAACkB,aAApC,CAA1B,EAA8ErB,WAA9E,EAA2FC,YAA3F,EAAyG0B,EAAzG;AACD,CAND;;AAQAzB,YAAY,CAACY,SAAb,CAAuBe,aAAvB,GAAuC,UAAUH,QAAV,EAAoBL,aAApB,EAAmC;AACxE,QAAMS,sBAAsB,GAAGX,MAAM,CAACY,MAAP,CAAc,IAAd,CAA/B;AACAL,EAAAA,QAAQ,CAACM,OAAT,CAAiBC,CAAC,IAAI;AACpBA,IAAAA,CAAC,CAACC,SAAF,GAAcD,CAAC,CAACE,cAAF,CAAiB,WAAjB,IACVF,CAAC,CAACC,SADQ,GAEV,KAAKhD,WAAL,CAAiBkD,YAAjB,CAA8BvD,CAAC,CAACwD,GAAF,CAAMhB,aAAa,CAACY,CAAC,CAACK,KAAH,CAAnB,EAA8B,WAA9B,CAA9B,EAA0EL,CAAC,CAACM,GAA5E,CAFJ;AAGAN,IAAAA,CAAC,CAACO,UAAF,GAAeP,CAAC,CAACE,cAAF,CAAiB,YAAjB,IAAiCF,CAAC,CAACO,UAAnC,GAAgD,CAA/D;AACA,QAAIC,QAAQ,GAAG5D,CAAC,CAAC6D,OAAF,CAAUT,CAAC,CAACQ,QAAZ,IAAwBR,CAAC,CAACQ,QAA1B,GAAqC,CAACR,CAAC,CAACQ,QAAH,CAApD;AAEAA,IAAAA,QAAQ,GAAGA,QAAQ,CAACJ,GAAT,CAAa,UAAUM,OAAV,EAAmB;AACzC,UAAIA,OAAO,YAAY3D,YAAvB,EAAqC;AACnC,eAAO2D,OAAP;AACD;;AACD,aAAO,IAAI5D,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkBkD,CAAC,CAACM,GAApB,EAAyBI,OAAzB,EAAkCV,CAAC,CAACW,SAAF,IAAeC,IAAI,CAACC,GAAL,EAAjD,CAAP;AACD,KALU,CAAX;AAOA,QAAIP,GAAG,GAAGN,CAAC,CAACK,KAAF,GAAUL,CAAC,CAACC,SAAtB;AACA,QAAIa,OAAO,GAAGjB,sBAAsB,CAACS,GAAD,CAApC;;AAEA,QAAIQ,OAAO,IAAI,IAAf,EAAqB;AACnBjB,MAAAA,sBAAsB,CAACS,GAAD,CAAtB,GAA8B,IAAItD,cAAJ,CAAmBgD,CAAC,CAACK,KAArB,EAA4BL,CAAC,CAACC,SAA9B,EAAyCO,QAAzC,EAAmDR,CAAC,CAACO,UAArD,CAA9B;AACD,KAFD,MAEO;AACL/D,MAAAA,MAAM,CAACsE,OAAO,CAACP,UAAR,KAAuBP,CAAC,CAACO,UAA1B,CAAN;AACAQ,MAAAA,KAAK,CAAClC,SAAN,CAAgBmC,IAAhB,CAAqBC,KAArB,CAA2BH,OAAO,CAACN,QAAnC,EAA6CA,QAA7C;AACD;AACF,GAvBD;AAwBA,SAAO5D,CAAC,CAACsE,MAAF,CAASrB,sBAAT,CAAP;AACD,CA3BD;;AA6BA5B,YAAY,CAACY,SAAb,CAAuBsC,YAAvB,GAAsC,UAAUlC,MAAV,EAAkBmC,KAAlB,EAAyB1B,EAAzB,EAA6B;AACjE,MAAI,CAAC,KAAKnB,KAAV,EAAiB;AACf,WAAOmB,EAAE,CAAC,IAAIhB,KAAJ,CAAU,qBAAV,CAAD,CAAT;AACD;;AAED,OAAKR,MAAL,CAAYiD,YAAZ,CAAyBlC,MAAzB,EAAiCmC,KAAjC,EAAwC1B,EAAxC;AACD,CAND;;AAQAzB,YAAY,CAACY,SAAb,CAAuBwC,KAAvB,GAA+B,UAAU3B,EAAV,EAAc;AAC3C,OAAKxB,MAAL,CAAYmD,KAAZ,CAAkB3B,EAAlB;AACD,CAFD;;AAIAzB,YAAY,CAACV,iBAAb,GAAiCA,iBAAjC;AAEA+D,MAAM,CAACC,OAAP,GAAiBtD,YAAjB","sourcesContent":["'use strict';\n\nvar assert = require('assert');\nvar util = require('util');\nvar EventEmitter = require('events');\nvar _ = require('lodash');\nvar protocol = require('./protocol');\nvar Message = protocol.Message;\nvar KeyedMessage = protocol.KeyedMessage;\nvar ProduceRequest = protocol.ProduceRequest;\nvar partitioner = require('./partitioner');\nvar DefaultPartitioner = partitioner.DefaultPartitioner;\nvar RandomPartitioner = partitioner.RandomPartitioner;\nvar CyclicPartitioner = partitioner.CyclicPartitioner;\nvar KeyedPartitioner = partitioner.KeyedPartitioner;\nvar CustomPartitioner = partitioner.CustomPartitioner;\n\nvar PARTITIONER_TYPES = {\n  default: 0,\n  random: 1,\n  cyclic: 2,\n  keyed: 3,\n  custom: 4\n};\n\nvar PARTITIONER_MAP = {\n  0: DefaultPartitioner,\n  1: RandomPartitioner,\n  2: CyclicPartitioner,\n  3: KeyedPartitioner,\n  4: CustomPartitioner\n};\n\nvar DEFAULTS = {\n  requireAcks: 1,\n  ackTimeoutMs: 100\n};\n\n/**\n * Provides common functionality for a kafka producer\n *\n * @param {Client} client A kafka client object to use for the producer\n * @param {Object} [options] An object containing configuration options\n * @param {Number} [options.requireAcks=1] Configuration for when to consider a message as acknowledged.\n *      <li>0 = No ack required</li>\n *      <li>1 = Leader ack required</li>\n *      <li>-1 = All in sync replicas ack required</li>\n *\n * @param {Number} [options.ackTimeoutMs=100] The amount of time in milliseconds to wait for all acks before considered\n *      the message as errored\n * @param {Number} [defaultPartitionType] The default partitioner type\n * @param {Object} [customPartitioner] a custom partitinoer to use of the form: function (partitions, key)\n * @constructor\n */\nfunction BaseProducer (client, options, defaultPartitionerType, customPartitioner) {\n  EventEmitter.call(this);\n  options = options || {};\n\n  this.ready = false;\n  this.client = client;\n\n  this.requireAcks = options.requireAcks === undefined ? DEFAULTS.requireAcks : options.requireAcks;\n  this.ackTimeoutMs = options.ackTimeoutMs === undefined ? DEFAULTS.ackTimeoutMs : options.ackTimeoutMs;\n\n  if (customPartitioner !== undefined && options.partitionerType !== PARTITIONER_TYPES.custom) {\n    throw new Error('Partitioner Type must be custom if providing a customPartitioner.');\n  } else if (customPartitioner === undefined && options.partitionerType === PARTITIONER_TYPES.custom) {\n    throw new Error('No customer partitioner defined');\n  }\n\n  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];\n\n  // eslint-disable-next-line\n  this.partitioner = new partitionerType(customPartitioner);\n\n  this.connect();\n}\n\nutil.inherits(BaseProducer, EventEmitter);\n\nBaseProducer.prototype.connect = function () {\n  // emiter...\n  var self = this;\n  this.ready = this.client.ready;\n  if (this.ready) self.emit('ready');\n  this.client.on('ready', function () {\n    if (!self.ready) {\n      self.ready = true;\n      self.emit('ready');\n    }\n  });\n  this.client.on('brokersChanged', function () {\n    let topics = Object.keys(this.topicMetadata);\n    this.refreshMetadata(topics, function (error) {\n      if (error) {\n        self.emit('error', error);\n      }\n    });\n  });\n  this.client.on('error', function (err) {\n    self.emit('error', err);\n  });\n  this.client.on('close', function () {});\n};\n\n/**\n * Sends a new message or array of messages to a topic/partition\n * This will use the\n *\n * @see Client#sendProduceRequest for a more low level way to send messages to kafka\n *\n * @param {Array.<BaseProducer~sendPayload>} payloads An array of topic payloads\n * @param {BaseProducer~sendCallback} cb A function to call once the send has completed\n */\nBaseProducer.prototype.send = function (payloads, cb) {\n  var client = this.client;\n  var requireAcks = this.requireAcks;\n  var ackTimeoutMs = this.ackTimeoutMs;\n\n  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);\n};\n\nBaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {\n  const topicPartitionRequests = Object.create(null);\n  payloads.forEach(p => {\n    p.partition = p.hasOwnProperty('partition')\n      ? p.partition\n      : this.partitioner.getPartition(_.map(topicMetadata[p.topic], 'partition'), p.key);\n    p.attributes = p.hasOwnProperty('attributes') ? p.attributes : 0;\n    let messages = _.isArray(p.messages) ? p.messages : [p.messages];\n\n    messages = messages.map(function (message) {\n      if (message instanceof KeyedMessage) {\n        return message;\n      }\n      return new Message(0, 0, p.key, message, p.timestamp || Date.now());\n    });\n\n    let key = p.topic + p.partition;\n    let request = topicPartitionRequests[key];\n\n    if (request == null) {\n      topicPartitionRequests[key] = new ProduceRequest(p.topic, p.partition, messages, p.attributes);\n    } else {\n      assert(request.attributes === p.attributes);\n      Array.prototype.push.apply(request.messages, messages);\n    }\n  });\n  return _.values(topicPartitionRequests);\n};\n\nBaseProducer.prototype.createTopics = function (topics, async, cb) {\n  if (!this.ready) {\n    return cb(new Error('Producer not ready!'));\n  }\n\n  this.client.createTopics(topics, async, cb);\n};\n\nBaseProducer.prototype.close = function (cb) {\n  this.client.close(cb);\n};\n\nBaseProducer.PARTITIONER_TYPES = PARTITIONER_TYPES;\n\nmodule.exports = BaseProducer;\n"]},"metadata":{},"sourceType":"script"}