{"ast":null,"code":"var assert = require('assert');\n\nvar InvalidConfigError = require('./errors/InvalidConfigError');\n\nvar legalChars = new RegExp('^[a-zA-Z0-9._-]*$');\nconst allowedTopicLength = 249;\n\nfunction validateConfig(property, value) {\n  if (!legalChars.test(value)) {\n    throw new InvalidConfigError([property, value, \"is illegal, contains a character other than ASCII alphanumerics, '.', '_' and '-'\"].join(' '));\n  }\n}\n\nfunction validateTopicNames(topics) {\n  // Rewriting same validations done by Apache Kafka team for topics\n  // iterating over topics\n  topics.some(function (topic) {\n    if (topic.length <= 0) {\n      throw new InvalidConfigError('topic name is illegal, cannot be empty');\n    }\n\n    if (topic === '.' || topic === '..') {\n      throw new InvalidConfigError('topic name cannot be . or ..');\n    }\n\n    if (topic.length > allowedTopicLength) {\n      throw new InvalidConfigError(`topic name is illegal, cannot be longer than ${allowedTopicLength} characters`);\n    }\n\n    if (!legalChars.test(topic)) {\n      throw new InvalidConfigError(`topic name ${topic} is illegal, contains a character other than ASCII alphanumerics .,_ and -`);\n    }\n  });\n  return true;\n}\n\nfunction validateTopics(topics) {\n  if (topics.some(function (topic) {\n    if ('partition' in topic) {\n      return typeof topic.partition !== 'number';\n    }\n\n    return false;\n  })) {\n    throw new InvalidConfigError('Offset must be a number and can not contain characters');\n  }\n}\n/*\nConverts:\n\n  [\n    {topic: 'test', partition: 0},\n    {topic: 'test', partition: 1},\n    {topic: 'Bob', partition: 0}\n  ]\n\nInto:\n\n  {\n    test: [0, 1],\n    bob: [0]\n  }\n\n*/\n\n\nfunction groupPartitionsByTopic(topicPartitions) {\n  assert(Array.isArray(topicPartitions));\n  return topicPartitions.reduce(function (result, tp) {\n    if (!(tp.topic in result)) {\n      result[tp.topic] = [tp.partition];\n    } else {\n      result[tp.topic].push(tp.partition);\n    }\n\n    return result;\n  }, {});\n}\n/*\nConverts:\n  {\n    test: [0, 1],\n    bob: [0]\n  }\n\nInto a topic partition payload:\n  [\n    {topic: 'test', partition: 0},\n    {topic: 'test', partition: 1},\n    {topic: 'Bob', partition: 0}\n  ]\n*/\n\n\nfunction createTopicPartitionList(topicPartitions) {\n  var tpList = [];\n\n  for (var topic in topicPartitions) {\n    if (!topicPartitions.hasOwnProperty(topic)) {\n      continue;\n    }\n\n    topicPartitions[topic].forEach(function (partition) {\n      tpList.push({\n        topic: topic,\n        partition: partition\n      });\n    });\n  }\n\n  return tpList;\n}\n\nmodule.exports = {\n  validateConfig: validateConfig,\n  validateTopics: validateTopics,\n  groupPartitionsByTopic: groupPartitionsByTopic,\n  createTopicPartitionList: createTopicPartitionList,\n  validateTopicNames: validateTopicNames\n};","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/kafka-node/lib/utils.js"],"names":["assert","require","InvalidConfigError","legalChars","RegExp","allowedTopicLength","validateConfig","property","value","test","join","validateTopicNames","topics","some","topic","length","validateTopics","partition","groupPartitionsByTopic","topicPartitions","Array","isArray","reduce","result","tp","push","createTopicPartitionList","tpList","hasOwnProperty","forEach","module","exports"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,kBAAkB,GAAGD,OAAO,CAAC,6BAAD,CAAhC;;AACA,IAAIE,UAAU,GAAG,IAAIC,MAAJ,CAAW,mBAAX,CAAjB;AACA,MAAMC,kBAAkB,GAAG,GAA3B;;AAEA,SAASC,cAAT,CAAyBC,QAAzB,EAAmCC,KAAnC,EAA0C;AACxC,MAAI,CAACL,UAAU,CAACM,IAAX,CAAgBD,KAAhB,CAAL,EAA6B;AAC3B,UAAM,IAAIN,kBAAJ,CAAuB,CAACK,QAAD,EAAWC,KAAX,EAAkB,mFAAlB,EAAuGE,IAAvG,CAA4G,GAA5G,CAAvB,CAAN;AACD;AACF;;AAED,SAASC,kBAAT,CAA6BC,MAA7B,EAAqC;AACnC;AACA;AACAA,EAAAA,MAAM,CAACC,IAAP,CAAY,UAAUC,KAAV,EAAiB;AAC3B,QAAIA,KAAK,CAACC,MAAN,IAAgB,CAApB,EAAuB;AACrB,YAAM,IAAIb,kBAAJ,CAAuB,wCAAvB,CAAN;AACD;;AACD,QAAIY,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,IAA/B,EAAqC;AACnC,YAAM,IAAIZ,kBAAJ,CAAuB,8BAAvB,CAAN;AACD;;AACD,QAAIY,KAAK,CAACC,MAAN,GAAeV,kBAAnB,EAAuC;AACrC,YAAM,IAAIH,kBAAJ,CAAwB,gDAA+CG,kBAAmB,aAA1F,CAAN;AACD;;AACD,QAAI,CAACF,UAAU,CAACM,IAAX,CAAgBK,KAAhB,CAAL,EAA6B;AAC3B,YAAM,IAAIZ,kBAAJ,CAAwB,cAAaY,KAAM,4EAA3C,CAAN;AACD;AACF,GAbD;AAcA,SAAO,IAAP;AACD;;AAED,SAASE,cAAT,CAAyBJ,MAAzB,EAAiC;AAC/B,MAAIA,MAAM,CAACC,IAAP,CAAY,UAAUC,KAAV,EAAiB;AAC/B,QAAI,eAAeA,KAAnB,EAA0B;AACxB,aAAO,OAAOA,KAAK,CAACG,SAAb,KAA2B,QAAlC;AACD;;AACD,WAAO,KAAP;AACD,GALG,CAAJ,EAKI;AACF,UAAM,IAAIf,kBAAJ,CAAuB,wDAAvB,CAAN;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgB,sBAAT,CAAiCC,eAAjC,EAAkD;AAChDnB,EAAAA,MAAM,CAACoB,KAAK,CAACC,OAAN,CAAcF,eAAd,CAAD,CAAN;AACA,SAAOA,eAAe,CAACG,MAAhB,CAAuB,UAAUC,MAAV,EAAkBC,EAAlB,EAAsB;AAClD,QAAI,EAAEA,EAAE,CAACV,KAAH,IAAYS,MAAd,CAAJ,EAA2B;AACzBA,MAAAA,MAAM,CAACC,EAAE,CAACV,KAAJ,CAAN,GAAmB,CAACU,EAAE,CAACP,SAAJ,CAAnB;AACD,KAFD,MAEO;AACLM,MAAAA,MAAM,CAACC,EAAE,CAACV,KAAJ,CAAN,CAAiBW,IAAjB,CAAsBD,EAAE,CAACP,SAAzB;AACD;;AACD,WAAOM,MAAP;AACD,GAPM,EAOJ,EAPI,CAAP;AAQD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,wBAAT,CAAmCP,eAAnC,EAAoD;AAClD,MAAIQ,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIb,KAAT,IAAkBK,eAAlB,EAAmC;AACjC,QAAI,CAACA,eAAe,CAACS,cAAhB,CAA+Bd,KAA/B,CAAL,EAA4C;AAC1C;AACD;;AACDK,IAAAA,eAAe,CAACL,KAAD,CAAf,CAAuBe,OAAvB,CAA+B,UAAUZ,SAAV,EAAqB;AAClDU,MAAAA,MAAM,CAACF,IAAP,CAAY;AACVX,QAAAA,KAAK,EAAEA,KADG;AAEVG,QAAAA,SAAS,EAAEA;AAFD,OAAZ;AAID,KALD;AAMD;;AACD,SAAOU,MAAP;AACD;;AAEDG,MAAM,CAACC,OAAP,GAAiB;AACfzB,EAAAA,cAAc,EAAEA,cADD;AAEfU,EAAAA,cAAc,EAAEA,cAFD;AAGfE,EAAAA,sBAAsB,EAAEA,sBAHT;AAIfQ,EAAAA,wBAAwB,EAAEA,wBAJX;AAKff,EAAAA,kBAAkB,EAAEA;AALL,CAAjB","sourcesContent":["var assert = require('assert');\nvar InvalidConfigError = require('./errors/InvalidConfigError');\nvar legalChars = new RegExp('^[a-zA-Z0-9._-]*$');\nconst allowedTopicLength = 249;\n\nfunction validateConfig (property, value) {\n  if (!legalChars.test(value)) {\n    throw new InvalidConfigError([property, value, \"is illegal, contains a character other than ASCII alphanumerics, '.', '_' and '-'\"].join(' '));\n  }\n}\n\nfunction validateTopicNames (topics) {\n  // Rewriting same validations done by Apache Kafka team for topics\n  // iterating over topics\n  topics.some(function (topic) {\n    if (topic.length <= 0) {\n      throw new InvalidConfigError('topic name is illegal, cannot be empty');\n    }\n    if (topic === '.' || topic === '..') {\n      throw new InvalidConfigError('topic name cannot be . or ..');\n    }\n    if (topic.length > allowedTopicLength) {\n      throw new InvalidConfigError(`topic name is illegal, cannot be longer than ${allowedTopicLength} characters`);\n    }\n    if (!legalChars.test(topic)) {\n      throw new InvalidConfigError(`topic name ${topic} is illegal, contains a character other than ASCII alphanumerics .,_ and -`);\n    }\n  });\n  return true;\n}\n\nfunction validateTopics (topics) {\n  if (topics.some(function (topic) {\n    if ('partition' in topic) {\n      return typeof topic.partition !== 'number';\n    }\n    return false;\n  })) {\n    throw new InvalidConfigError('Offset must be a number and can not contain characters');\n  }\n}\n\n/*\nConverts:\n\n  [\n    {topic: 'test', partition: 0},\n    {topic: 'test', partition: 1},\n    {topic: 'Bob', partition: 0}\n  ]\n\nInto:\n\n  {\n    test: [0, 1],\n    bob: [0]\n  }\n\n*/\nfunction groupPartitionsByTopic (topicPartitions) {\n  assert(Array.isArray(topicPartitions));\n  return topicPartitions.reduce(function (result, tp) {\n    if (!(tp.topic in result)) {\n      result[tp.topic] = [tp.partition];\n    } else {\n      result[tp.topic].push(tp.partition);\n    }\n    return result;\n  }, {});\n}\n\n/*\nConverts:\n  {\n    test: [0, 1],\n    bob: [0]\n  }\n\nInto a topic partition payload:\n  [\n    {topic: 'test', partition: 0},\n    {topic: 'test', partition: 1},\n    {topic: 'Bob', partition: 0}\n  ]\n*/\nfunction createTopicPartitionList (topicPartitions) {\n  var tpList = [];\n  for (var topic in topicPartitions) {\n    if (!topicPartitions.hasOwnProperty(topic)) {\n      continue;\n    }\n    topicPartitions[topic].forEach(function (partition) {\n      tpList.push({\n        topic: topic,\n        partition: partition\n      });\n    });\n  }\n  return tpList;\n}\n\nmodule.exports = {\n  validateConfig: validateConfig,\n  validateTopics: validateTopics,\n  groupPartitionsByTopic: groupPartitionsByTopic,\n  createTopicPartitionList: createTopicPartitionList,\n  validateTopicNames: validateTopicNames\n};\n"]},"metadata":{},"sourceType":"script"}