{"ast":null,"code":"'use strict';\n\nconst Client = require('./baseClient');\n\nconst logger = require('./logging')('kafka-node:KafkaClient');\n\nconst EventEmitter = require('events');\n\nconst async = require('async');\n\nconst retry = require('retry');\n\nconst assert = require('assert');\n\nconst _ = require('lodash');\n\nconst util = require('util');\n\nconst net = require('net');\n\nconst BufferList = require('bl');\n\nconst tls = require('tls');\n\nconst BrokerWrapper = require('./wrapper/BrokerWrapper');\n\nconst errors = require('./errors');\n\nconst validateConfig = require('./utils').validateConfig;\n\nconst TimeoutError = require('./errors/TimeoutError');\n\nconst NotControllerError = require('./errors/NotControllerError');\n\nconst protocol = require('./protocol');\n\nconst protocolVersions = require('./protocol/protocolVersions');\n\nconst baseProtocolVersions = protocolVersions.baseSupport;\nconst apiMap = protocolVersions.apiMap;\n\nconst NestedError = require('nested-error-stacks');\n\nconst getCodec = require('./codec');\n\nconst resourceTypeMap = require('./resources').resourceTypeMap;\n\nconst DEFAULTS = {\n  kafkaHost: 'localhost:9092',\n  connectTimeout: 10000,\n  requestTimeout: 30000,\n  idleConnection: 5 * 60 * 1000,\n  reconnectOnIdle: true,\n  autoConnect: true,\n  versions: {\n    disabled: false,\n    requestTimeout: 500\n  },\n  connectRetryOptions: {\n    retries: 5,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: 60 * 1000,\n    randomize: true\n  },\n  maxAsyncRequests: 10,\n  noAckBatchOptions: null\n};\n\nconst KafkaClient = function (options) {\n  EventEmitter.call(this); // Intentionally not calling Client to avoid constructor logic\n\n  this.options = _.defaultsDeep(options || {}, DEFAULTS);\n  this.sslOptions = this.options.sslOptions;\n  this.ssl = !!this.sslOptions;\n\n  if (this.options.ssl === true) {\n    this.options.ssl = {};\n  }\n\n  if (this.options.clientId) {\n    validateConfig('clientId', this.options.clientId);\n  }\n\n  this.clientId = this.options.clientId || 'kafka-node-client';\n  this.noAckBatchOptions = this.options.noAckBatchOptions;\n  this.brokers = {};\n  this.longpollingBrokers = {};\n  this.topicMetadata = {};\n  this.correlationId = 0;\n  this._socketId = 0;\n  /**\n   * @type {Map<any, Map<any, any>>}\n   */\n\n  this.cbqueue = new Map();\n  this.brokerMetadata = {};\n  this.clusterMetadata = {};\n  this.ready = false;\n  this._timeouts = new Set();\n  this.initialHosts = parseHostList(this.options.kafkaHost);\n\n  if (this.options.autoConnect) {\n    this.connect();\n  }\n};\n\nutil.inherits(KafkaClient, Client);\n/*\n{ '1001':\n   { jmx_port: -1,\n     timestamp: '1492521177416',\n     endpoints: [ 'PLAINTEXT://127.0.0.1:9092', 'SSL://127.0.0.1:9093' ],\n     host: '127.0.0.1',\n     version: 2,\n     port: '9092',\n     id: '1001' } }\n\n     vs\n\n{ '1001': { nodeId: 1001, host: '127.0.0.1', port: 9093 } }\n\n     */\n\nfunction parseHost(hostString) {\n  const ip = hostString.substring(0, hostString.lastIndexOf(':'));\n  const port = +hostString.substring(hostString.lastIndexOf(':') + 1);\n  const isIpv6 = ip.match(/\\[(.*)\\]/);\n  const host = isIpv6 ? isIpv6[1] : ip;\n  return {\n    host,\n    port\n  };\n}\n\nfunction parseHostList(hosts) {\n  return hosts.split(',').map(parseHost);\n}\n\nKafkaClient.prototype.connect = function () {\n  if (this.connecting) {\n    logger.debug('connect request ignored. Client is currently connecting');\n    return;\n  }\n\n  this.connecting = true;\n  const connect = retry.operation(this.options.connectRetryOptions);\n  connect.attempt(currentAttempt => {\n    if (this.closing) {\n      logger.debug('Client is closing abort retry');\n      connect.stop();\n      return;\n    }\n\n    logger.debug(`Connect attempt ${currentAttempt}`);\n    async.series([callback => {\n      this.connectToBrokers(this.initialHosts, callback);\n    }, callback => {\n      logger.debug('connected to socket, trying to load initial metadata');\n      this.loadMetadataForTopics([], (error, result) => {\n        if (error) {\n          logger.debug('loadMetadataForTopics after connect failed', error);\n          return callback(error);\n        }\n\n        this.updateMetadatas(result, true);\n        callback(null);\n      });\n    }], error => {\n      if (connect.retry(error)) {\n        return;\n      }\n\n      this.connecting = false;\n\n      if (error) {\n        logger.debug('exhausted retries. Main error', connect.mainError());\n        this.emit('error', connect.mainError());\n        return;\n      }\n\n      this.ready = true;\n      this.emit('ready');\n    });\n  });\n};\n\nKafkaClient.prototype.connectToBrokers = function (hosts, callback) {\n  assert(hosts && hosts.length, 'No hosts to connect to');\n  hosts = _.shuffle(hosts);\n  let index = 0;\n  let errors = [];\n  let broker = null;\n  async.doWhilst(callback => {\n    this.connectToBroker(hosts[index++], (error, connectedBroker) => {\n      if (error) {\n        logger.debug('failed to connect because of ', error);\n        errors.push(error);\n        callback(null);\n        return;\n      }\n\n      errors.length = 0;\n      broker = connectedBroker;\n      callback(null);\n    });\n  }, () => !this.closing && !broker && index < hosts.length, () => {\n    if (this.closing) {\n      return callback(new Error('client is closing'));\n    }\n\n    if (broker) {\n      return callback(null, broker);\n    }\n\n    if (errors.length) {\n      callback(errors.pop());\n    } else {\n      callback(new Error('failed to connect to brokers'));\n    }\n  });\n};\n\nKafkaClient.prototype.connectToBroker = function (broker, callback) {\n  const timeout = this.options.connectTimeout;\n  logger.debug(`Trying to connect to host: ${broker.host} port: ${broker.port}`);\n  let connectTimer = null;\n  callback = _.once(callback);\n\n  const onError = error => {\n    if (socket.closing) {\n      return;\n    }\n\n    clearTimeout(connectTimer);\n    connectTimer = null;\n    socket.closing = true;\n    socket.end();\n    socket.destroy();\n    socket.unref();\n    const brokerKey = `${broker.host}:${broker.port}`;\n    delete this.brokers[brokerKey];\n    callback(error);\n  };\n\n  const brokerWrapper = this.setupBroker(broker.host, broker.port, false, this.brokers);\n  const socket = brokerWrapper.socket;\n  socket.once('connect', () => {\n    logger.debug('broker socket connected %j', broker);\n\n    this._clearTimeout(connectTimer);\n\n    callback(null, brokerWrapper);\n  });\n  socket.on('error', function (error) {\n    logger.debug('Socket Error', error);\n    onError(error);\n  });\n  connectTimer = this._createTimeout(function () {\n    logger.debug('Connection timeout error with broker %j', broker);\n    onError(new TimeoutError(`Connection timeout of ${timeout}ms exceeded`));\n  }, timeout);\n};\n\nKafkaClient.prototype.getController = function (callback) {\n  // Check for cached controller\n  if (this.clusterMetadata.controllerId != null) {\n    var controller = this.brokerMetadata[this.clusterMetadata.controllerId];\n    var broker = this.getBroker(controller.host, controller.port);\n    return callback(null, broker, this.clusterMetadata.controllerId);\n  } // If cached controller is not available, refresh metadata\n\n\n  this.loadMetadata((error, result) => {\n    if (error) {\n      return callback(error);\n    } // No controller will be available if api version request timed out, or if kafka version is less than 0.10.\n\n\n    if (!result[1].clusterMetadata || result[1].clusterMetadata.controllerId == null) {\n      return callback(new errors.BrokerNotAvailableError('Controller broker not available'));\n    }\n\n    this.updateMetadatas(result);\n    var controllerId = result[1].clusterMetadata.controllerId;\n    var controllerMetadata = result[0][controllerId];\n    var broker = this.getBroker(controllerMetadata.host, controllerMetadata.port);\n\n    if (!broker || !broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      return callback(new errors.BrokerNotAvailableError('Controller broker not available'));\n    }\n\n    return callback(null, broker, this.clusterMetadata.controllerId);\n  });\n};\n\nKafkaClient.prototype.getBroker = function (host, port, longpolling) {\n  const brokers = this.getBrokers(longpolling);\n  var addr = host + ':' + port;\n  return brokers[addr] || this.setupBroker(host, port, longpolling, brokers);\n};\n\nKafkaClient.prototype.setupBroker = function (host, port, longpolling, brokers) {\n  var brokerKey = host + ':' + port;\n  brokers[brokerKey] = this.createBroker(host, port, longpolling);\n  return brokers[brokerKey];\n}; // returns a connected broker\n\n\nKafkaClient.prototype.getAvailableBroker = function (callback) {\n  const brokers = this.getBrokers();\n\n  const connectedBrokers = _.filter(brokers, function (broker) {\n    return broker.isConnected();\n  });\n\n  if (connectedBrokers.length) {\n    logger.debug('found %d connected broker(s)', connectedBrokers.length);\n    return callback(null, _.sample(connectedBrokers));\n  }\n\n  let brokersToTry;\n\n  if (_.isEmpty(brokers)) {\n    brokersToTry = _.values(this.brokerMetadata);\n  } else {\n    const badBrokers = Object.keys(brokers);\n    brokersToTry = _.filter(this.brokerMetadata, function (broker) {\n      return !_.includes(badBrokers, `${broker.host}:${broker.port}`);\n    });\n  }\n\n  if (_.isEmpty(brokersToTry)) {\n    return callback(new Error('Unable to find available brokers to try'));\n  }\n\n  this.connectToBrokers(brokersToTry, callback);\n};\n\nKafkaClient.prototype.refreshBrokers = function () {\n  var self = this;\n\n  var validBrokers = _.map(this.brokerMetadata, function (broker) {\n    return `${broker.host}:${broker.port}`;\n  });\n\n  function closeDeadBrokers(brokers) {\n    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);\n\n    if (deadBrokerKeys.length) {\n      self.closeBrokers(deadBrokerKeys.map(function (key) {\n        var broker = brokers[key];\n        delete brokers[key];\n        return broker;\n      }));\n    }\n  }\n\n  closeDeadBrokers(this.brokers);\n  closeDeadBrokers(this.longpollingBrokers);\n};\n\nKafkaClient.prototype.refreshBrokerMetadata = function (callback) {\n  if (this.refreshingMetadata || this.closing) {\n    return;\n  }\n\n  if (callback == null) {\n    callback = _.noop;\n  }\n\n  this.refreshingMetadata = true;\n  logger.debug(`${this.clientId} refreshBrokerMetadata()`);\n  async.waterfall([callback => this.getAvailableBroker(callback), (broker, callback) => this.loadMetadataFrom(broker, callback)], (error, result) => {\n    this.refreshingMetadata = false;\n\n    if (error) {\n      callback(error);\n      return this.emit('error', new NestedError('refreshBrokerMetadata failed', error));\n    }\n\n    this.updateMetadatas(result, true);\n    this.refreshBrokers();\n    callback(error);\n  });\n};\n\nKafkaClient.prototype.loadMetadataFrom = function (broker, cb) {\n  assert(broker && broker.isConnected());\n  var correlationId = this.nextId();\n  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, []);\n  this.sendWhenReady(broker, correlationId, request, protocol.decodeMetadataResponse, cb);\n};\n\nKafkaClient.prototype.setBrokerMetadata = function (brokerMetadata) {\n  assert(brokerMetadata, 'brokerMetadata is empty');\n  const oldBrokerMetadata = this.brokerMetadata;\n  this.brokerMetadata = brokerMetadata;\n  this.brokerMetadataLastUpdate = Date.now();\n\n  if (!_.isEmpty(oldBrokerMetadata) && !_.isEqual(oldBrokerMetadata, brokerMetadata)) {\n    setImmediate(() => this.emit('brokersChanged'));\n  }\n};\n\nKafkaClient.prototype.setClusterMetadata = function (clusterMetadata) {\n  assert(clusterMetadata, 'clusterMetadata is empty');\n  this.clusterMetadata = clusterMetadata;\n};\n\nKafkaClient.prototype.setControllerId = function (controllerId) {\n  if (!this.clusterMetadata) {\n    this.clusterMetadata = {\n      controllerId\n    };\n    return;\n  }\n\n  this.clusterMetadata.controllerId = controllerId;\n};\n\nKafkaClient.prototype.updateMetadatas = function (metadatas, replaceTopicMetadata) {\n  assert(metadatas && Array.isArray(metadatas) && metadatas.length === 2, 'metadata format is incorrect');\n  this.setBrokerMetadata(metadatas[0]);\n\n  if (replaceTopicMetadata) {\n    this.topicMetadata = metadatas[1].metadata;\n  } else {\n    _.extend(this.topicMetadata, metadatas[1].metadata);\n  }\n\n  if (metadatas[1].clusterMetadata) {\n    this.setClusterMetadata(metadatas[1].clusterMetadata);\n  }\n\n  logger.debug(`${this.clientId} updated internal metadata`);\n};\n\nKafkaClient.prototype.brokerForLeader = function (leader, longpolling) {\n  var addr;\n  var brokers = this.getBrokers(longpolling); // If leader is not give, choose the first broker as leader\n\n  if (typeof leader === 'undefined') {\n    if (!_.isEmpty(brokers)) {\n      addr = Object.keys(brokers)[0];\n      return brokers[addr];\n    } else if (!_.isEmpty(this.brokerMetadata)) {\n      leader = Object.keys(this.brokerMetadata)[0];\n    } else {\n      return;\n    }\n  }\n\n  var broker = this.brokerMetadata[leader];\n\n  if (!broker) {\n    return;\n  }\n\n  addr = broker.host + ':' + broker.port;\n  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers, err => {\n    if (err) {\n      this.emit('error', err);\n    }\n  });\n};\n\nKafkaClient.prototype.wrapTimeoutIfNeeded = function (socketId, correlationId, callback, overrideTimeout) {\n  if (this.options.requestTimeout === false && overrideTimeout == null) {\n    return callback;\n  }\n\n  const timeout = overrideTimeout || this.options.requestTimeout;\n  let timeoutId = null;\n\n  const wrappedFn = function () {\n    clear();\n    callback.apply(null, arguments);\n  };\n\n  function clear() {\n    clearTimeout(timeoutId);\n    timeoutId = null;\n  }\n\n  timeoutId = setTimeout(() => {\n    this.unqueueCallback(socketId, correlationId);\n    callback(new TimeoutError(`Request timed out after ${timeout}ms`));\n    callback = _.noop;\n  }, timeout);\n  wrappedFn.timeoutId = timeoutId;\n  return wrappedFn;\n};\n\nKafkaClient.prototype.queueCallback = function (socket, id, data) {\n  data[1] = this.wrapTimeoutIfNeeded(socket.socketId, id, data[1], data[2]);\n  Client.prototype.queueCallback.call(this, socket, id, data);\n};\n\nKafkaClient.prototype.getApiVersions = function (broker, cb) {\n  if (!broker || !broker.isConnected()) {\n    return cb(new errors.BrokerNotAvailableError('Broker not available (getApiVersions)'));\n  }\n\n  logger.debug(`${this.clientId} sending versions request to ${broker.socket.addr}`);\n  const correlationId = this.nextId();\n  const request = protocol.encodeVersionsRequest(this.clientId, correlationId);\n  this.queueCallback(broker.socket, correlationId, [protocol.decodeVersionsResponse, cb, this.options.versions.requestTimeout]);\n  broker.write(request);\n};\n\nKafkaClient.prototype.getListGroups = function (callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (getListGroups)'));\n  }\n\n  const brokers = this.brokerMetadata;\n  async.mapValuesLimit(brokers, this.options.maxAsyncRequests, (brokerMetadata, brokerId, cb) => {\n    const broker = this.brokerForLeader(brokerId);\n\n    if (!broker || !broker.isConnected()) {\n      return cb(new errors.BrokerNotAvailableError('Broker not available (getListGroups)'));\n    }\n\n    const correlationId = this.nextId();\n    const request = protocol.encodeListGroups(this.clientId, correlationId);\n    this.sendWhenReady(broker, correlationId, request, protocol.decodeListGroups, cb);\n  }, (err, results) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    results = _.values(results);\n    callback(null, _.merge.apply({}, results));\n  });\n};\n\nKafkaClient.prototype.getDescribeGroups = function (groups, callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (getDescribeGroups)'));\n  }\n\n  async.groupByLimit(groups, this.options.maxAsyncRequests, (group, cb) => {\n    this.sendGroupCoordinatorRequest(group, (err, coordinator) => {\n      cb(err || null, coordinator ? coordinator.coordinatorId : undefined);\n    });\n  }, (err, results) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    async.mapValuesLimit(results, this.options.maxAsyncRequests, (groups, coordinator, cb) => {\n      const broker = this.brokerForLeader(coordinator);\n\n      if (!broker || !broker.isConnected()) {\n        return cb(new errors.BrokerNotAvailableError('Broker not available (getDescribeGroups)'));\n      }\n\n      const correlationId = this.nextId();\n      const request = protocol.encodeDescribeGroups(this.clientId, correlationId, groups);\n      this.sendWhenReady(broker, correlationId, request, protocol.decodeDescribeGroups, cb);\n    }, (err, res) => {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, _.reduce(res, (result, describes, broker) => {\n        _.each(describes, (values, consumer) => {\n          result[consumer] = values;\n          result[consumer].brokerId = broker;\n        });\n\n        return result;\n      }, {}));\n    });\n  });\n};\n\nKafkaClient.prototype.close = function (callback) {\n  logger.debug('close client');\n  this.closing = true;\n  this.closeBrokers(this.brokers);\n  this.closeBrokers(this.longpollingBrokers);\n\n  this._clearAllTimeouts();\n\n  if (callback) {\n    setImmediate(function () {\n      callback(null);\n    });\n  }\n};\n\nKafkaClient.prototype.initializeBroker = function (broker, callback) {\n  if (!broker || !broker.isConnected()) {\n    return callback(new errors.BrokerNotAvailableError('Broker not available (initializeBroker)'));\n  }\n\n  if (this.options.versions.disabled) {\n    callback(null);\n    return;\n  }\n\n  this.getApiVersions(broker, (error, versions) => {\n    if (error) {\n      if (error instanceof TimeoutError) {\n        logger.debug('getApiVersions request timedout probably less than 0.10 using base support');\n        versions = baseProtocolVersions;\n      } else {\n        logger.error('ApiVersions failed with unexpected error', error);\n        callback(error);\n        return;\n      }\n    } else {\n      logger.debug(`Received versions response from ${broker.socket.addr}`);\n    }\n\n    if (_.isEmpty(versions)) {\n      return callback(new Error(`getApiVersions response was empty for broker: ${broker}`));\n    }\n\n    logger.debug('setting api support to %j', versions);\n    broker.apiSupport = versions;\n\n    if (this.options.sasl) {\n      this.saslAuth(broker, err => {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null);\n      });\n    } else {\n      callback(null);\n    }\n  });\n};\n\nKafkaClient.prototype.saslAuth = function (broker, callback) {\n  const mechanism = this.options.sasl.mechanism.toUpperCase();\n  const apiVersion = broker.apiSupport ? broker.apiSupport.saslHandshake.usable : undefined;\n\n  if (typeof apiVersion !== 'number') {\n    callback(new errors.SaslAuthenticationError(null, 'Broker does not support SASL authentication'));\n    return;\n  }\n\n  async.waterfall([callback => {\n    logger.debug(`Sending SASL/${mechanism} handshake request to ${broker}`);\n    const correlationId = this.nextId();\n    const request = protocol.encodeSaslHandshakeRequest(this.clientId, correlationId, apiVersion, mechanism);\n    this.queueCallback(broker.socket, correlationId, [protocol.decodeSaslHandshakeResponse, callback]);\n    broker.write(request);\n  }, (enabledMechanisms, callback) => {\n    logger.debug(`Sending SASL/${mechanism} authentication request to ${broker.socket.addr}`);\n    const auth = this.options.sasl;\n    const correlationId = this.nextId();\n    const request = protocol.encodeSaslAuthenticateRequest(this.clientId, correlationId, apiVersion, auth);\n    let decode = protocol.decodeSaslAuthenticateResponse;\n\n    if (apiVersion === 0) {\n      decode = _.identity;\n      broker.socket.saslAuthCorrelationId = correlationId;\n    }\n\n    this.queueCallback(broker.socket, correlationId, [decode, callback]);\n    broker.write(request);\n  }], (error, authBytes) => {\n    if (!error) {\n      broker.authenticated = true;\n    } // TODO do stuff with authBytes\n\n\n    callback(error);\n  });\n};\n\nKafkaClient.prototype.createBroker = function (host, port, longpolling) {\n  logger.debug(`${this.clientId} createBroker ${host}:${port}`);\n  var self = this;\n  var socket;\n\n  if (self.ssl) {\n    socket = tls.connect(port, host, self.sslOptions);\n  } else {\n    socket = net.createConnection(port, host);\n  }\n\n  socket.addr = host + ':' + port;\n  socket.host = host;\n  socket.port = port;\n  socket.socketId = this.nextSocketId();\n  if (longpolling) socket.longpolling = true;\n  socket.on('connect', function () {\n    var lastError = this.error;\n    this.error = null;\n\n    if (lastError) {\n      this.waiting = false;\n      self.initializeBroker(brokerWrapper, function (error) {\n        if (error) {\n          logger.error('error initializing broker after reconnect', error);\n          return;\n        }\n\n        const readyEventName = brokerWrapper.getReadyEventName();\n        self.emit(readyEventName);\n        self.emit('reconnect');\n      });\n    } else {\n      self.initializeBroker(brokerWrapper, function (error) {\n        if (error) {\n          logger.error('error initializing broker after connect', error);\n\n          if (error instanceof errors.SaslAuthenticationError) {\n            self.emit('error', error);\n          }\n\n          return;\n        }\n\n        const readyEventName = brokerWrapper.getReadyEventName();\n        self.emit(readyEventName);\n        self.emit('connect');\n      });\n    }\n  });\n  socket.on('error', function (err) {\n    this.error = err;\n\n    if (!self.connecting) {\n      self.emit('socket_error', err);\n    }\n  });\n  socket.on('close', function (hadError) {\n    self.emit('close', this);\n    logger.debug(`${self.clientId} socket closed ${this.addr} (hadError: ${hadError})`);\n\n    if (!hadError && self.closing) {\n      logger.debug(`clearing ${this.addr} callback queue without error`);\n      self.clearCallbackQueue(this);\n    } else {\n      let error = this.error;\n\n      if (!error) {\n        if (self.options.sasl && socket.saslAuthCorrelationId !== undefined) {\n          delete socket.saslAuthCorrelationId;\n          const message = 'Broker closed connection during SASL auth: bad credentials?';\n          error = new errors.SaslAuthenticationError(null, message);\n        } else {\n          error = new errors.BrokerNotAvailableError('Broker not available (socket closed)');\n\n          if (!self.connecting && !brokerWrapper.isIdle()) {\n            logger.debug(`${self.clientId} schedule refreshBrokerMetadata()`);\n            setImmediate(function () {\n              self.refreshBrokerMetadata();\n            });\n          }\n        }\n      }\n\n      self.clearCallbackQueue(this, error);\n    }\n\n    retry(this);\n  });\n  socket.on('end', function () {\n    retry(this);\n  });\n  socket.buffer = new BufferList();\n  socket.on('data', function (data) {\n    socket.buffer.append(data);\n    self.handleReceivedData(socket);\n  });\n  socket.setKeepAlive(true, 60000);\n  const brokerWrapper = new BrokerWrapper(socket, this.noAckBatchOptions, this.options.idleConnection, this.options.sasl);\n\n  function retry(s) {\n    if (s.retrying || s.closing) return;\n    s.retrying = true;\n    s.retryTimer = setTimeout(function () {\n      if (s.closing) return;\n\n      if (!self.options.reconnectOnIdle && brokerWrapper.isIdle()) {\n        logger.debug(`${self.clientId} to ${socket.addr} is idle not reconnecting`);\n        s.closing = true;\n        self.deleteDisconnected(brokerWrapper);\n        return;\n      }\n\n      if (!self.isValidBroker(s)) {\n        logger.debug(`${self.clientId} is not reconnecting to ${s.addr} invalid broker`);\n        return;\n      }\n\n      logger.debug(`${self.clientId} reconnecting to ${s.addr}`);\n      self.reconnectBroker(s);\n    }, 1000);\n  }\n\n  return brokerWrapper;\n};\n\nKafkaClient.prototype.isValidBroker = function ({\n  host,\n  port\n}) {\n  return this.connecting || _(this.brokerMetadata).values().some({\n    host,\n    port\n  });\n};\n\nKafkaClient.prototype.deleteDisconnected = function (broker) {\n  if (!broker.isConnected()) {\n    const brokers = this.getBrokers(broker.socket.longpolling);\n    const key = broker.socket.addr;\n    assert(brokers[key] === broker);\n    delete brokers[key];\n  }\n};\n\nKafkaClient.prototype.clearCallbackQueue = function (socket, error) {\n  const socketId = socket.socketId;\n  const queue = this.cbqueue.get(socketId);\n\n  if (!queue) {\n    return;\n  }\n\n  queue.forEach(function (handlers) {\n    const cb = handlers[1];\n\n    if (error) {\n      cb(error);\n    } else if (cb.timeoutId != null) {\n      clearTimeout(cb.timeoutId);\n    }\n  });\n  this.cbqueue.delete(socketId);\n};\n/**\n * Fetches metadata for brokers and cluster.\n * This includes an array containing each node (id, host and port).\n * Depending on kafka version, additional cluster information is available (controller id).\n * @param {loadMetadataCallback} cb Function to call once metadata is loaded.\n */\n\n\nKafkaClient.prototype.loadMetadata = function (callback) {\n  this.loadMetadataForTopics(null, callback);\n};\n/**\n * Fetches metadata for brokers and cluster.\n * This includes an array containing each node (id, host and port). As well as an object\n * containing the topic name, partition, leader number, replica count, and in sync replicas per partition.\n * Depending on kafka version, additional cluster information is available (controller id).\n * @param {Array} topics List of topics to fetch metadata for. An empty array ([]) will fetch all topics.\n * @param {loadMetadataCallback} callback Function to call once metadata is loaded.\n */\n\n\nKafkaClient.prototype.loadMetadataForTopics = function (topics, callback) {\n  const broker = this.brokerForLeader();\n\n  if (!broker || !broker.isConnected()) {\n    return callback(new errors.BrokerNotAvailableError('Broker not available (loadMetadataForTopics)'));\n  }\n\n  const ensureBrokerReady = (broker, cb) => {\n    if (!broker.isReady()) {\n      logger.debug('missing apiSupport waiting until broker is ready...(loadMetadataForTopics)');\n      this.waitUntilReady(broker, cb);\n    } else {\n      cb(null);\n    }\n  };\n\n  async.series([cb => {\n    ensureBrokerReady(broker, cb);\n  }, cb => {\n    const broker = this.brokerForLeader();\n    const correlationId = this.nextId();\n    const supportedCoders = getSupportedForRequestType(broker, 'metadata');\n    const request = supportedCoders.encoder(this.clientId, correlationId, topics);\n    this.queueCallback(broker.socket, correlationId, [supportedCoders.decoder, cb]);\n    broker.write(request);\n  }], (err, result) => {\n    callback(err, result[1]);\n  });\n};\n/**\n * Creates one or more topics.\n * @param {Array} topics Array of topics with partition and replication factor to create.\n * @param {createTopicsCallback} callback Function to call once operation is completed.\n */\n\n\nKafkaClient.prototype.createTopics = function (topics, callback) {\n  // Calls with [string, string, ...] are forwarded to support previous versions\n  if (topics.every(t => typeof t === 'string')) {\n    return Client.prototype.createTopics.apply(this, arguments);\n  }\n\n  this.sendControllerRequest('createTopics', [topics, this.options.requestTimeout], callback);\n};\n\nKafkaClient.prototype.topicExists = function (topics, callback) {\n  this.loadMetadataForTopics([], (error, response) => {\n    if (error) {\n      return callback(error);\n    }\n\n    this.updateMetadatas(response);\n\n    const missingTopics = _.difference(topics, Object.keys(this.topicMetadata));\n\n    if (missingTopics.length === 0) {\n      return callback(null);\n    }\n\n    callback(new errors.TopicsNotExistError(missingTopics));\n  });\n};\n\nconst encodeMessageSet = protocol.encodeMessageSet;\nconst Message = protocol.Message;\n\nfunction compress(payloads, callback) {\n  async.each(payloads, buildRequest, callback);\n\n  function buildRequest(payload, cb) {\n    const attributes = payload.attributes;\n    const codec = getCodec(attributes);\n    if (!codec) return cb(null);\n    const innerSet = encodeMessageSet(payload.messages, 1);\n    codec.encode(innerSet, function (err, message) {\n      if (err) return cb(err);\n      payload.messages = [new Message(0, attributes, payload.key, message)];\n      cb(null);\n    });\n  }\n}\n\nfunction getSupportedForRequestType(broker, requestType) {\n  assert(!_.isEmpty(broker.apiSupport), 'apiSupport is empty');\n  const brokerSupport = broker.apiSupport[requestType];\n\n  if (!brokerSupport) {\n    return null;\n  }\n\n  const usable = brokerSupport.usable;\n  const combo = apiMap[requestType][usable];\n  return {\n    encoder: combo[0],\n    decoder: combo[1]\n  };\n}\n\nKafkaClient.prototype.waitUntilReady = function (broker, callback) {\n  logger.debug('waitUntilReady ' + broker);\n  let timeoutId = null;\n\n  const onReady = () => {\n    logger.debug('broker is now ready');\n\n    if (timeoutId !== null) {\n      this._clearTimeout(timeoutId);\n\n      timeoutId = null;\n    }\n\n    callback(null);\n  };\n\n  const timeout = this.options.requestTimeout;\n  const readyEventName = broker.getReadyEventName();\n\n  if (timeout !== false) {\n    timeoutId = this._createTimeout(() => {\n      this.removeListener(readyEventName, onReady);\n\n      this._timeouts.delete(timeoutId);\n\n      callback(new TimeoutError(`Request timed out after ${timeout}ms`));\n    }, timeout);\n  }\n\n  this.once(readyEventName, onReady);\n};\n\nKafkaClient.prototype._clearTimeout = function (timeoutId) {\n  clearTimeout(timeoutId);\n\n  this._timeouts.delete(timeoutId);\n};\n\nKafkaClient.prototype._clearAllTimeouts = function () {\n  this._timeouts.forEach(function (timeoutId) {\n    clearTimeout(timeoutId);\n  });\n\n  this._timeouts.clear();\n};\n\nKafkaClient.prototype._createTimeout = function (fn, timeout) {\n  const timeoutId = setTimeout(fn, timeout);\n\n  this._timeouts.add(timeoutId);\n\n  return timeoutId;\n};\n\nKafkaClient.prototype.sendRequest = function (request, callback) {\n  const payloads = this.payloadsByLeader(request.data.payloads);\n  const longpolling = request.longpolling;\n  const sendToBroker = async.ensureAsync((payload, leader, callback) => {\n    const broker = this.brokerForLeader(leader, longpolling);\n\n    if (!broker || !broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      callback(new errors.BrokerNotAvailableError('Broker not available (sendRequest)'));\n      return;\n    }\n\n    if (!broker.isReady()) {\n      callback(new Error('Broker is not ready'));\n      return;\n    }\n\n    if (longpolling) {\n      if (broker.socket.waiting) {\n        callback(null);\n        return;\n      }\n\n      broker.socket.waiting = true;\n    }\n\n    const correlationId = this.nextId();\n    const coder = getSupportedForRequestType(broker, request.type);\n    const encoder = request.data.args != null ? coder.encoder.apply(null, request.data.args) : coder.encoder;\n    const decoder = request.data.decoderArgs != null ? coder.decoder.apply(null, request.data.decoderArgs) : coder.decoder;\n    const requestData = encoder(this.clientId, correlationId, payload);\n\n    if (request.data.requireAcks === 0) {\n      broker.writeAsync(requestData);\n      callback(null, {\n        result: 'no ack'\n      });\n    } else {\n      this.queueCallback(broker.socket, correlationId, [decoder, callback]);\n      broker.write(requestData);\n    }\n  });\n  const ensureBrokerReady = async.ensureAsync((leader, callback) => {\n    const broker = this.brokerForLeader(leader, longpolling);\n\n    if (!broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      callback(new errors.BrokerNotAvailableError('Broker not available (sendRequest -> ensureBrokerReady)'));\n      return;\n    }\n\n    if (!broker.isReady()) {\n      logger.debug(`missing apiSupport waiting until broker is ready... (sendRequest ${request.type})`);\n      this.waitUntilReady(broker, callback);\n    } else {\n      callback(null);\n    }\n  });\n  async.mapValues(payloads, function (payload, leader, callback) {\n    async.series([function (callback) {\n      ensureBrokerReady(leader, callback);\n    }, function (callback) {\n      sendToBroker(payload, leader, callback);\n    }], function (error, results) {\n      if (error) {\n        return callback(error);\n      }\n\n      callback(null, _.last(results));\n    });\n  }, callback);\n};\n/**\n * Sends a request to a specific broker by id\n */\n\n\nKafkaClient.prototype.sendRequestToBroker = function (brokerId, requestType, args, callback) {\n  const brokerMetadata = this.brokerMetadata[brokerId];\n\n  if (!brokerMetadata) {\n    return callback(new Error('No broker with id ' + brokerId));\n  }\n\n  const broker = this.getBroker(brokerMetadata.host, brokerMetadata.port);\n  async.waterfall([callback => {\n    if (broker.isReady()) {\n      return callback(null, broker);\n    }\n\n    this.waitUntilReady(broker, error => {\n      callback(error, broker);\n    });\n  }], (error, result) => {\n    if (error) {\n      return callback(error);\n    }\n\n    const broker = this.getBroker(brokerMetadata.host, brokerMetadata.port);\n    const correlationId = this.nextId();\n    const coder = getSupportedForRequestType(broker, requestType);\n\n    if (!coder) {\n      return callback(new errors.ApiNotSupportedError());\n    }\n\n    args.unshift(this.clientId, correlationId);\n    const encoder = coder.encoder;\n    const decoder = coder.decoder;\n    const request = encoder.apply(null, args);\n    this.sendWhenReady(broker, correlationId, request, decoder, callback);\n  });\n};\n\nKafkaClient.prototype.leaderLessPayloads = function (payloads) {\n  return _.filter(payloads, payload => !this.hasMetadata(payload.topic, payload.partition));\n};\n\nKafkaClient.prototype.verifyPayloadsHasLeaders = function (payloads, callback) {\n  const leaderLessPayloads = this.leaderLessPayloads(payloads);\n\n  if (leaderLessPayloads.length === 0) {\n    return callback(null);\n  }\n\n  logger.debug('payloads has no leaders! Our metadata could be out of date try refreshingMetadata', leaderLessPayloads);\n  this.refreshMetadata(_.map(leaderLessPayloads, 'topic'), error => {\n    if (error) {\n      return callback(error);\n    }\n\n    const payloadWithMissingLeaders = this.leaderLessPayloads(payloads);\n\n    if (payloadWithMissingLeaders.length) {\n      logger.error('leaders are still missing for %j', payloadWithMissingLeaders);\n      callback(new errors.BrokerNotAvailableError('Could not find the leader'));\n    } else {\n      callback(null);\n    }\n  });\n};\n\nKafkaClient.prototype.wrapControllerCheckIfNeeded = function (requestType, requestArgs, callback) {\n  if (callback.isControllerWrapper) {\n    return callback;\n  }\n\n  var hasBeenInvoked = false;\n\n  const wrappedCallback = (error, result) => {\n    if (error instanceof NotControllerError) {\n      this.setControllerId(null);\n\n      if (!hasBeenInvoked) {\n        hasBeenInvoked = true;\n        this.sendControllerRequest(requestType, requestArgs, wrappedCallback);\n        return;\n      }\n    }\n\n    callback(error, result);\n  };\n\n  wrappedCallback.isControllerWrapper = true;\n  return wrappedCallback;\n};\n\nKafkaClient.prototype.sendControllerRequest = function (requestType, args, callback) {\n  this.getController((error, controller, controllerId) => {\n    if (error) {\n      return callback(error);\n    }\n\n    const originalArgs = _.clone(args);\n\n    const originalCallback = callback;\n    callback = this.wrapControllerCheckIfNeeded(requestType, originalArgs, originalCallback);\n    this.sendRequestToBroker(controllerId, requestType, args, callback);\n  });\n};\n\nKafkaClient.prototype.sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages, callback) {\n  const memberId = consumer.memberId;\n  const generationId = consumer.generationId;\n\n  if (memberId == null && generationId == null) {\n    Client.prototype.sendFetchRequest.apply(this, arguments);\n    return;\n  }\n\n  payloads = _.cloneDeep(payloads);\n\n  function stateValidator(unused, type, message) {\n    const payloadMap = consumer.payloadMap;\n\n    if (consumer.closing || consumer.connecting || consumer.rebalancing || consumer.memberId !== memberId || consumer.generationId !== generationId) {\n      logger.error('ignoring message due to it being from an old group - memberId: ' + memberId, '!=' + consumer.memberId + ' - generationId: ' + generationId + '!=' + consumer.generationId);\n      return false;\n    }\n\n    if (type === 'message') {\n      const {\n        topic,\n        partition,\n        offset\n      } = message;\n\n      if (!payloadMap[topic] || payloadMap[topic][partition] == null) {\n        logger.error('received unexpected message', message, payloadMap); // We should have never received this in the first place\n\n        return false;\n      }\n\n      if (offset == null || offset < payloadMap[topic][partition]) {\n        // Kafka may send an older message than we expect (compressed messages, and other unknown reasons)\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (callback == null) {\n    callback = _.noop;\n  }\n\n  async.series([callback => {\n    this.verifyPayloadsHasLeaders(payloads, callback);\n  }, callback => {\n    const request = {\n      type: 'fetch',\n      longpolling: true,\n      data: {\n        payloads: payloads,\n        args: [fetchMaxWaitMs, fetchMinBytes],\n        decoderArgs: [this._createMessageHandler(consumer, stateValidator), maxTickMessages]\n      }\n    };\n    this.sendRequest(request, callback);\n  }], callback);\n};\n\nKafkaClient.prototype.sendWhenReady = function (broker, correlationId, request, decode, cb) {\n  const doSend = () => {\n    this.queueCallback(broker.socket, correlationId, [decode, cb]);\n    broker.write(request);\n  };\n\n  if (!broker.isReady()) {\n    this.waitUntilReady(broker, doSend);\n  } else {\n    doSend();\n  }\n};\n\nKafkaClient.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, callback) {\n  async.series([function (callback) {\n    logger.debug('compressing messages if needed');\n    compress(payloads, callback);\n  }, callback => {\n    this.verifyPayloadsHasLeaders(payloads, callback);\n  }, callback => {\n    const request = {\n      type: 'produce',\n      data: {\n        payloads: payloads,\n        args: [requireAcks, ackTimeoutMs],\n        requireAcks: requireAcks\n      }\n    };\n    this.sendRequest(request, callback);\n  }], (err, result) => {\n    if (err) {\n      if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n        this.emit('brokersChanged');\n      }\n\n      callback(err);\n    } else {\n      callback(null, _.chain(result).last().reduce((accu, value) => _.merge(accu, value), {}).value());\n    }\n  });\n};\n\nKafkaClient.prototype.handleReceivedData = function (socket) {\n  if (socket.saslAuthCorrelationId !== undefined) {\n    if (socket.buffer.length < 4) {\n      // not enough data yet\n      return;\n    }\n\n    const size = socket.buffer.readInt32BE(0);\n\n    if (socket.buffer.length - 4 < size) {\n      // still not enough data\n      return;\n    }\n\n    const resp = socket.buffer.slice(4, 4 + size);\n    this.invokeResponseCallback(socket, socket.saslAuthCorrelationId, resp);\n    delete socket.saslAuthCorrelationId;\n    socket.buffer.consume(size + 4);\n  } else {\n    return Client.prototype.handleReceivedData.call(this, socket);\n  }\n};\n\nKafkaClient.prototype.describeConfigs = function (payload, callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (describeConfigs)'));\n  }\n\n  let err; // Broker resource requests must go to the specific node\n  // other requests can go to any node\n\n  const brokerResourceRequests = [];\n  const nonBrokerResourceRequests = [];\n\n  _.forEach(payload.resources, function (resource) {\n    if (resourceTypeMap[resource.resourceType] === undefined) {\n      err = new Error(`Unexpected resource type ${resource.resourceType} for resource ${resource.resourceName}`);\n      return false;\n    } else {\n      resource.resourceType = resourceTypeMap[resource.resourceType];\n    }\n\n    if (resource.resourceType === resourceTypeMap['broker']) {\n      brokerResourceRequests.push(resource);\n    } else {\n      nonBrokerResourceRequests.push(resource);\n    }\n  });\n\n  if (err) {\n    return callback(err);\n  }\n\n  async.parallelLimit([cb => {\n    if (nonBrokerResourceRequests.length > 0) {\n      this.sendRequestToAnyBroker('describeConfigs', [{\n        resources: nonBrokerResourceRequests,\n        includeSynonyms: payload.includeSynonyms\n      }], cb);\n    } else {\n      cb(null, []);\n    }\n  }, ...brokerResourceRequests.map(r => {\n    return cb => {\n      this.sendRequestToBroker(r.resourceName, 'describeConfigs', [{\n        resources: [r],\n        includeSynonyms: payload.includeSynonyms\n      }], cb);\n    };\n  })], this.options.maxAsyncRequests, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, _.flatten(result));\n  });\n};\n/**\n * Sends a request to any broker in the cluster\n */\n\n\nKafkaClient.prototype.sendRequestToAnyBroker = function (requestType, args, callback) {\n  // For now just select the first broker\n  const brokerId = Object.keys(this.brokerMetadata)[0];\n  this.sendRequestToBroker(brokerId, requestType, args, callback);\n};\n\nmodule.exports = KafkaClient;","map":{"version":3,"sources":["/home/jerem/Bureau/Cours/IWA/stopcovid-front/node_modules/kafka-node/lib/kafkaClient.js"],"names":["Client","require","logger","EventEmitter","async","retry","assert","_","util","net","BufferList","tls","BrokerWrapper","errors","validateConfig","TimeoutError","NotControllerError","protocol","protocolVersions","baseProtocolVersions","baseSupport","apiMap","NestedError","getCodec","resourceTypeMap","DEFAULTS","kafkaHost","connectTimeout","requestTimeout","idleConnection","reconnectOnIdle","autoConnect","versions","disabled","connectRetryOptions","retries","factor","minTimeout","maxTimeout","randomize","maxAsyncRequests","noAckBatchOptions","KafkaClient","options","call","defaultsDeep","sslOptions","ssl","clientId","brokers","longpollingBrokers","topicMetadata","correlationId","_socketId","cbqueue","Map","brokerMetadata","clusterMetadata","ready","_timeouts","Set","initialHosts","parseHostList","connect","inherits","parseHost","hostString","ip","substring","lastIndexOf","port","isIpv6","match","host","hosts","split","map","prototype","connecting","debug","operation","attempt","currentAttempt","closing","stop","series","callback","connectToBrokers","loadMetadataForTopics","error","result","updateMetadatas","mainError","emit","length","shuffle","index","broker","doWhilst","connectToBroker","connectedBroker","push","Error","pop","timeout","connectTimer","once","onError","socket","clearTimeout","end","destroy","unref","brokerKey","brokerWrapper","setupBroker","_clearTimeout","on","_createTimeout","getController","controllerId","controller","getBroker","loadMetadata","BrokerNotAvailableError","controllerMetadata","isConnected","refreshBrokerMetadata","longpolling","getBrokers","addr","createBroker","getAvailableBroker","connectedBrokers","filter","sample","brokersToTry","isEmpty","values","badBrokers","Object","keys","includes","refreshBrokers","self","validBrokers","closeDeadBrokers","deadBrokerKeys","difference","closeBrokers","key","refreshingMetadata","noop","waterfall","loadMetadataFrom","cb","nextId","request","encodeMetadataRequest","sendWhenReady","decodeMetadataResponse","setBrokerMetadata","oldBrokerMetadata","brokerMetadataLastUpdate","Date","now","isEqual","setImmediate","setClusterMetadata","setControllerId","metadatas","replaceTopicMetadata","Array","isArray","metadata","extend","brokerForLeader","leader","err","wrapTimeoutIfNeeded","socketId","overrideTimeout","timeoutId","wrappedFn","clear","apply","arguments","setTimeout","unqueueCallback","queueCallback","id","data","getApiVersions","encodeVersionsRequest","decodeVersionsResponse","write","getListGroups","mapValuesLimit","brokerId","encodeListGroups","decodeListGroups","results","merge","getDescribeGroups","groups","groupByLimit","group","sendGroupCoordinatorRequest","coordinator","coordinatorId","undefined","encodeDescribeGroups","decodeDescribeGroups","res","reduce","describes","each","consumer","close","_clearAllTimeouts","initializeBroker","apiSupport","sasl","saslAuth","mechanism","toUpperCase","apiVersion","saslHandshake","usable","SaslAuthenticationError","encodeSaslHandshakeRequest","decodeSaslHandshakeResponse","enabledMechanisms","auth","encodeSaslAuthenticateRequest","decode","decodeSaslAuthenticateResponse","identity","saslAuthCorrelationId","authBytes","authenticated","createConnection","nextSocketId","lastError","waiting","readyEventName","getReadyEventName","hadError","clearCallbackQueue","message","isIdle","buffer","append","handleReceivedData","setKeepAlive","s","retrying","retryTimer","deleteDisconnected","isValidBroker","reconnectBroker","some","queue","get","forEach","handlers","delete","topics","ensureBrokerReady","isReady","waitUntilReady","supportedCoders","getSupportedForRequestType","encoder","decoder","createTopics","every","t","sendControllerRequest","topicExists","response","missingTopics","TopicsNotExistError","encodeMessageSet","Message","compress","payloads","buildRequest","payload","attributes","codec","innerSet","messages","encode","requestType","brokerSupport","combo","onReady","removeListener","fn","add","sendRequest","payloadsByLeader","sendToBroker","ensureAsync","coder","type","args","decoderArgs","requestData","requireAcks","writeAsync","mapValues","last","sendRequestToBroker","ApiNotSupportedError","unshift","leaderLessPayloads","hasMetadata","topic","partition","verifyPayloadsHasLeaders","refreshMetadata","payloadWithMissingLeaders","wrapControllerCheckIfNeeded","requestArgs","isControllerWrapper","hasBeenInvoked","wrappedCallback","originalArgs","clone","originalCallback","sendFetchRequest","fetchMaxWaitMs","fetchMinBytes","maxTickMessages","memberId","generationId","cloneDeep","stateValidator","unused","payloadMap","rebalancing","offset","_createMessageHandler","doSend","sendProduceRequest","ackTimeoutMs","chain","accu","value","size","readInt32BE","resp","slice","invokeResponseCallback","consume","describeConfigs","brokerResourceRequests","nonBrokerResourceRequests","resources","resource","resourceType","resourceName","parallelLimit","sendRequestToAnyBroker","includeSynonyms","r","flatten","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Client = require('./baseClient');\nconst logger = require('./logging')('kafka-node:KafkaClient');\nconst EventEmitter = require('events');\nconst async = require('async');\nconst retry = require('retry');\nconst assert = require('assert');\nconst _ = require('lodash');\nconst util = require('util');\nconst net = require('net');\nconst BufferList = require('bl');\nconst tls = require('tls');\nconst BrokerWrapper = require('./wrapper/BrokerWrapper');\nconst errors = require('./errors');\nconst validateConfig = require('./utils').validateConfig;\nconst TimeoutError = require('./errors/TimeoutError');\nconst NotControllerError = require('./errors/NotControllerError');\nconst protocol = require('./protocol');\nconst protocolVersions = require('./protocol/protocolVersions');\nconst baseProtocolVersions = protocolVersions.baseSupport;\nconst apiMap = protocolVersions.apiMap;\nconst NestedError = require('nested-error-stacks');\nconst getCodec = require('./codec');\nconst resourceTypeMap = require('./resources').resourceTypeMap;\n\nconst DEFAULTS = {\n  kafkaHost: 'localhost:9092',\n  connectTimeout: 10000,\n  requestTimeout: 30000,\n  idleConnection: 5 * 60 * 1000,\n  reconnectOnIdle: true,\n  autoConnect: true,\n  versions: {\n    disabled: false,\n    requestTimeout: 500\n  },\n  connectRetryOptions: {\n    retries: 5,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: 60 * 1000,\n    randomize: true\n  },\n  maxAsyncRequests: 10,\n  noAckBatchOptions: null\n};\n\nconst KafkaClient = function (options) {\n  EventEmitter.call(this); // Intentionally not calling Client to avoid constructor logic\n  this.options = _.defaultsDeep(options || {}, DEFAULTS);\n\n  this.sslOptions = this.options.sslOptions;\n  this.ssl = !!this.sslOptions;\n\n  if (this.options.ssl === true) {\n    this.options.ssl = {};\n  }\n\n  if (this.options.clientId) {\n    validateConfig('clientId', this.options.clientId);\n  }\n\n  this.clientId = this.options.clientId || 'kafka-node-client';\n  this.noAckBatchOptions = this.options.noAckBatchOptions;\n  this.brokers = {};\n  this.longpollingBrokers = {};\n  this.topicMetadata = {};\n  this.correlationId = 0;\n  this._socketId = 0;\n  /**\n   * @type {Map<any, Map<any, any>>}\n   */\n  this.cbqueue = new Map();\n  this.brokerMetadata = {};\n  this.clusterMetadata = {};\n  this.ready = false;\n  this._timeouts = new Set();\n\n  this.initialHosts = parseHostList(this.options.kafkaHost);\n\n  if (this.options.autoConnect) {\n    this.connect();\n  }\n};\n\nutil.inherits(KafkaClient, Client);\n\n/*\n{ '1001':\n   { jmx_port: -1,\n     timestamp: '1492521177416',\n     endpoints: [ 'PLAINTEXT://127.0.0.1:9092', 'SSL://127.0.0.1:9093' ],\n     host: '127.0.0.1',\n     version: 2,\n     port: '9092',\n     id: '1001' } }\n\n     vs\n\n{ '1001': { nodeId: 1001, host: '127.0.0.1', port: 9093 } }\n\n     */\n\nfunction parseHost (hostString) {\n  const ip = hostString.substring(0, hostString.lastIndexOf(':'));\n  const port = +hostString.substring(hostString.lastIndexOf(':') + 1);\n  const isIpv6 = ip.match(/\\[(.*)\\]/);\n  const host = isIpv6 ? isIpv6[1] : ip;\n  return {\n    host,\n    port\n  };\n}\n\nfunction parseHostList (hosts) {\n  return hosts.split(',').map(parseHost);\n}\n\nKafkaClient.prototype.connect = function () {\n  if (this.connecting) {\n    logger.debug('connect request ignored. Client is currently connecting');\n    return;\n  }\n  this.connecting = true;\n\n  const connect = retry.operation(this.options.connectRetryOptions);\n\n  connect.attempt(currentAttempt => {\n    if (this.closing) {\n      logger.debug('Client is closing abort retry');\n      connect.stop();\n      return;\n    }\n\n    logger.debug(`Connect attempt ${currentAttempt}`);\n\n    async.series(\n      [\n        callback => {\n          this.connectToBrokers(this.initialHosts, callback);\n        },\n\n        callback => {\n          logger.debug('connected to socket, trying to load initial metadata');\n          this.loadMetadataForTopics([], (error, result) => {\n            if (error) {\n              logger.debug('loadMetadataForTopics after connect failed', error);\n              return callback(error);\n            }\n            this.updateMetadatas(result, true);\n            callback(null);\n          });\n        }\n      ],\n      error => {\n        if (connect.retry(error)) {\n          return;\n        }\n\n        this.connecting = false;\n\n        if (error) {\n          logger.debug('exhausted retries. Main error', connect.mainError());\n          this.emit('error', connect.mainError());\n          return;\n        }\n\n        this.ready = true;\n        this.emit('ready');\n      }\n    );\n  });\n};\n\nKafkaClient.prototype.connectToBrokers = function (hosts, callback) {\n  assert(hosts && hosts.length, 'No hosts to connect to');\n  hosts = _.shuffle(hosts);\n  let index = 0;\n  let errors = [];\n  let broker = null;\n  async.doWhilst(\n    callback => {\n      this.connectToBroker(hosts[index++], (error, connectedBroker) => {\n        if (error) {\n          logger.debug('failed to connect because of ', error);\n          errors.push(error);\n          callback(null);\n          return;\n        }\n        errors.length = 0;\n        broker = connectedBroker;\n        callback(null);\n      });\n    },\n    () => !this.closing && !broker && index < hosts.length,\n    () => {\n      if (this.closing) {\n        return callback(new Error('client is closing'));\n      }\n\n      if (broker) {\n        return callback(null, broker);\n      }\n\n      if (errors.length) {\n        callback(errors.pop());\n      } else {\n        callback(new Error('failed to connect to brokers'));\n      }\n    }\n  );\n};\n\nKafkaClient.prototype.connectToBroker = function (broker, callback) {\n  const timeout = this.options.connectTimeout;\n  logger.debug(`Trying to connect to host: ${broker.host} port: ${broker.port}`);\n  let connectTimer = null;\n\n  callback = _.once(callback);\n\n  const onError = error => {\n    if (socket.closing) {\n      return;\n    }\n    clearTimeout(connectTimer);\n    connectTimer = null;\n    socket.closing = true;\n    socket.end();\n    socket.destroy();\n    socket.unref();\n    const brokerKey = `${broker.host}:${broker.port}`;\n    delete this.brokers[brokerKey];\n    callback(error);\n  };\n\n  const brokerWrapper = this.setupBroker(broker.host, broker.port, false, this.brokers);\n  const socket = brokerWrapper.socket;\n\n  socket.once('connect', () => {\n    logger.debug('broker socket connected %j', broker);\n    this._clearTimeout(connectTimer);\n    callback(null, brokerWrapper);\n  });\n\n  socket.on('error', function (error) {\n    logger.debug('Socket Error', error);\n    onError(error);\n  });\n\n  connectTimer = this._createTimeout(function () {\n    logger.debug('Connection timeout error with broker %j', broker);\n    onError(new TimeoutError(`Connection timeout of ${timeout}ms exceeded`));\n  }, timeout);\n};\n\nKafkaClient.prototype.getController = function (callback) {\n  // Check for cached controller\n  if (this.clusterMetadata.controllerId != null) {\n    var controller = this.brokerMetadata[this.clusterMetadata.controllerId];\n    var broker = this.getBroker(controller.host, controller.port);\n\n    return callback(null, broker, this.clusterMetadata.controllerId);\n  }\n\n  // If cached controller is not available, refresh metadata\n  this.loadMetadata((error, result) => {\n    if (error) {\n      return callback(error);\n    }\n\n    // No controller will be available if api version request timed out, or if kafka version is less than 0.10.\n    if (!result[1].clusterMetadata || result[1].clusterMetadata.controllerId == null) {\n      return callback(new errors.BrokerNotAvailableError('Controller broker not available'));\n    }\n\n    this.updateMetadatas(result);\n\n    var controllerId = result[1].clusterMetadata.controllerId;\n    var controllerMetadata = result[0][controllerId];\n\n    var broker = this.getBroker(controllerMetadata.host, controllerMetadata.port);\n\n    if (!broker || !broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      return callback(new errors.BrokerNotAvailableError('Controller broker not available'));\n    }\n\n    return callback(null, broker, this.clusterMetadata.controllerId);\n  });\n};\n\nKafkaClient.prototype.getBroker = function (host, port, longpolling) {\n  const brokers = this.getBrokers(longpolling);\n\n  var addr = host + ':' + port;\n  return brokers[addr] || this.setupBroker(host, port, longpolling, brokers);\n};\n\nKafkaClient.prototype.setupBroker = function (host, port, longpolling, brokers) {\n  var brokerKey = host + ':' + port;\n  brokers[brokerKey] = this.createBroker(host, port, longpolling);\n  return brokers[brokerKey];\n};\n\n// returns a connected broker\nKafkaClient.prototype.getAvailableBroker = function (callback) {\n  const brokers = this.getBrokers();\n  const connectedBrokers = _.filter(brokers, function (broker) {\n    return broker.isConnected();\n  });\n\n  if (connectedBrokers.length) {\n    logger.debug('found %d connected broker(s)', connectedBrokers.length);\n    return callback(null, _.sample(connectedBrokers));\n  }\n\n  let brokersToTry;\n\n  if (_.isEmpty(brokers)) {\n    brokersToTry = _.values(this.brokerMetadata);\n  } else {\n    const badBrokers = Object.keys(brokers);\n    brokersToTry = _.filter(this.brokerMetadata, function (broker) {\n      return !_.includes(badBrokers, `${broker.host}:${broker.port}`);\n    });\n  }\n\n  if (_.isEmpty(brokersToTry)) {\n    return callback(new Error('Unable to find available brokers to try'));\n  }\n\n  this.connectToBrokers(brokersToTry, callback);\n};\n\nKafkaClient.prototype.refreshBrokers = function () {\n  var self = this;\n  var validBrokers = _.map(this.brokerMetadata, function (broker) {\n    return `${broker.host}:${broker.port}`;\n  });\n\n  function closeDeadBrokers (brokers) {\n    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);\n    if (deadBrokerKeys.length) {\n      self.closeBrokers(\n        deadBrokerKeys.map(function (key) {\n          var broker = brokers[key];\n          delete brokers[key];\n          return broker;\n        })\n      );\n    }\n  }\n\n  closeDeadBrokers(this.brokers);\n  closeDeadBrokers(this.longpollingBrokers);\n};\n\nKafkaClient.prototype.refreshBrokerMetadata = function (callback) {\n  if (this.refreshingMetadata || this.closing) {\n    return;\n  }\n\n  if (callback == null) {\n    callback = _.noop;\n  }\n\n  this.refreshingMetadata = true;\n\n  logger.debug(`${this.clientId} refreshBrokerMetadata()`);\n\n  async.waterfall(\n    [callback => this.getAvailableBroker(callback), (broker, callback) => this.loadMetadataFrom(broker, callback)],\n    (error, result) => {\n      this.refreshingMetadata = false;\n      if (error) {\n        callback(error);\n        return this.emit('error', new NestedError('refreshBrokerMetadata failed', error));\n      }\n      this.updateMetadatas(result, true);\n      this.refreshBrokers();\n      callback(error);\n    }\n  );\n};\n\nKafkaClient.prototype.loadMetadataFrom = function (broker, cb) {\n  assert(broker && broker.isConnected());\n  var correlationId = this.nextId();\n  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, []);\n\n  this.sendWhenReady(broker, correlationId, request, protocol.decodeMetadataResponse, cb);\n};\n\nKafkaClient.prototype.setBrokerMetadata = function (brokerMetadata) {\n  assert(brokerMetadata, 'brokerMetadata is empty');\n  const oldBrokerMetadata = this.brokerMetadata;\n  this.brokerMetadata = brokerMetadata;\n  this.brokerMetadataLastUpdate = Date.now();\n\n  if (!_.isEmpty(oldBrokerMetadata) && !_.isEqual(oldBrokerMetadata, brokerMetadata)) {\n    setImmediate(() => this.emit('brokersChanged'));\n  }\n};\n\nKafkaClient.prototype.setClusterMetadata = function (clusterMetadata) {\n  assert(clusterMetadata, 'clusterMetadata is empty');\n  this.clusterMetadata = clusterMetadata;\n};\n\nKafkaClient.prototype.setControllerId = function (controllerId) {\n  if (!this.clusterMetadata) {\n    this.clusterMetadata = {\n      controllerId\n    };\n\n    return;\n  }\n  this.clusterMetadata.controllerId = controllerId;\n};\n\nKafkaClient.prototype.updateMetadatas = function (metadatas, replaceTopicMetadata) {\n  assert(metadatas && Array.isArray(metadatas) && metadatas.length === 2, 'metadata format is incorrect');\n  this.setBrokerMetadata(metadatas[0]);\n  if (replaceTopicMetadata) {\n    this.topicMetadata = metadatas[1].metadata;\n  } else {\n    _.extend(this.topicMetadata, metadatas[1].metadata);\n  }\n\n  if (metadatas[1].clusterMetadata) {\n    this.setClusterMetadata(metadatas[1].clusterMetadata);\n  }\n  logger.debug(`${this.clientId} updated internal metadata`);\n};\n\nKafkaClient.prototype.brokerForLeader = function (leader, longpolling) {\n  var addr;\n  var brokers = this.getBrokers(longpolling);\n  // If leader is not give, choose the first broker as leader\n  if (typeof leader === 'undefined') {\n    if (!_.isEmpty(brokers)) {\n      addr = Object.keys(brokers)[0];\n      return brokers[addr];\n    } else if (!_.isEmpty(this.brokerMetadata)) {\n      leader = Object.keys(this.brokerMetadata)[0];\n    } else {\n      return;\n    }\n  }\n\n  var broker = this.brokerMetadata[leader];\n\n  if (!broker) {\n    return;\n  }\n\n  addr = broker.host + ':' + broker.port;\n\n  return (\n    brokers[addr] ||\n    this.setupBroker(broker.host, broker.port, longpolling, brokers, err => {\n      if (err) {\n        this.emit('error', err);\n      }\n    })\n  );\n};\n\nKafkaClient.prototype.wrapTimeoutIfNeeded = function (socketId, correlationId, callback, overrideTimeout) {\n  if (this.options.requestTimeout === false && overrideTimeout == null) {\n    return callback;\n  }\n\n  const timeout = overrideTimeout || this.options.requestTimeout;\n\n  let timeoutId = null;\n\n  const wrappedFn = function () {\n    clear();\n    callback.apply(null, arguments);\n  };\n\n  function clear () {\n    clearTimeout(timeoutId);\n    timeoutId = null;\n  }\n\n  timeoutId = setTimeout(() => {\n    this.unqueueCallback(socketId, correlationId);\n    callback(new TimeoutError(`Request timed out after ${timeout}ms`));\n    callback = _.noop;\n  }, timeout);\n\n  wrappedFn.timeoutId = timeoutId;\n\n  return wrappedFn;\n};\n\nKafkaClient.prototype.queueCallback = function (socket, id, data) {\n  data[1] = this.wrapTimeoutIfNeeded(socket.socketId, id, data[1], data[2]);\n  Client.prototype.queueCallback.call(this, socket, id, data);\n};\n\nKafkaClient.prototype.getApiVersions = function (broker, cb) {\n  if (!broker || !broker.isConnected()) {\n    return cb(new errors.BrokerNotAvailableError('Broker not available (getApiVersions)'));\n  }\n\n  logger.debug(`${this.clientId} sending versions request to ${broker.socket.addr}`);\n\n  const correlationId = this.nextId();\n  const request = protocol.encodeVersionsRequest(this.clientId, correlationId);\n\n  this.queueCallback(broker.socket, correlationId, [\n    protocol.decodeVersionsResponse,\n    cb,\n    this.options.versions.requestTimeout\n  ]);\n  broker.write(request);\n};\n\nKafkaClient.prototype.getListGroups = function (callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (getListGroups)'));\n  }\n  const brokers = this.brokerMetadata;\n  async.mapValuesLimit(\n    brokers,\n    this.options.maxAsyncRequests,\n    (brokerMetadata, brokerId, cb) => {\n      const broker = this.brokerForLeader(brokerId);\n      if (!broker || !broker.isConnected()) {\n        return cb(new errors.BrokerNotAvailableError('Broker not available (getListGroups)'));\n      }\n\n      const correlationId = this.nextId();\n      const request = protocol.encodeListGroups(this.clientId, correlationId);\n      this.sendWhenReady(broker, correlationId, request, protocol.decodeListGroups, cb);\n    },\n    (err, results) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      results = _.values(results);\n      callback(null, _.merge.apply({}, results));\n    }\n  );\n};\n\nKafkaClient.prototype.getDescribeGroups = function (groups, callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (getDescribeGroups)'));\n  }\n\n  async.groupByLimit(\n    groups,\n    this.options.maxAsyncRequests,\n    (group, cb) => {\n      this.sendGroupCoordinatorRequest(group, (err, coordinator) => {\n        cb(err || null, coordinator ? coordinator.coordinatorId : undefined);\n      });\n    },\n    (err, results) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      async.mapValuesLimit(\n        results,\n        this.options.maxAsyncRequests,\n        (groups, coordinator, cb) => {\n          const broker = this.brokerForLeader(coordinator);\n          if (!broker || !broker.isConnected()) {\n            return cb(new errors.BrokerNotAvailableError('Broker not available (getDescribeGroups)'));\n          }\n\n          const correlationId = this.nextId();\n          const request = protocol.encodeDescribeGroups(this.clientId, correlationId, groups);\n          this.sendWhenReady(broker, correlationId, request, protocol.decodeDescribeGroups, cb);\n        },\n        (err, res) => {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(\n            null,\n            _.reduce(\n              res,\n              (result, describes, broker) => {\n                _.each(describes, (values, consumer) => {\n                  result[consumer] = values;\n                  result[consumer].brokerId = broker;\n                });\n                return result;\n              },\n              {}\n            )\n          );\n        }\n      );\n    }\n  );\n};\n\nKafkaClient.prototype.close = function (callback) {\n  logger.debug('close client');\n  this.closing = true;\n  this.closeBrokers(this.brokers);\n  this.closeBrokers(this.longpollingBrokers);\n  this._clearAllTimeouts();\n  if (callback) {\n    setImmediate(function () {\n      callback(null);\n    });\n  }\n};\n\nKafkaClient.prototype.initializeBroker = function (broker, callback) {\n  if (!broker || !broker.isConnected()) {\n    return callback(new errors.BrokerNotAvailableError('Broker not available (initializeBroker)'));\n  }\n\n  if (this.options.versions.disabled) {\n    callback(null);\n    return;\n  }\n\n  this.getApiVersions(broker, (error, versions) => {\n    if (error) {\n      if (error instanceof TimeoutError) {\n        logger.debug('getApiVersions request timedout probably less than 0.10 using base support');\n        versions = baseProtocolVersions;\n      } else {\n        logger.error('ApiVersions failed with unexpected error', error);\n        callback(error);\n        return;\n      }\n    } else {\n      logger.debug(`Received versions response from ${broker.socket.addr}`);\n    }\n\n    if (_.isEmpty(versions)) {\n      return callback(new Error(`getApiVersions response was empty for broker: ${broker}`));\n    }\n\n    logger.debug('setting api support to %j', versions);\n    broker.apiSupport = versions;\n\n    if (this.options.sasl) {\n      this.saslAuth(broker, err => {\n        if (err) {\n          return callback(err);\n        }\n        callback(null);\n      });\n    } else {\n      callback(null);\n    }\n  });\n};\n\nKafkaClient.prototype.saslAuth = function (broker, callback) {\n  const mechanism = this.options.sasl.mechanism.toUpperCase();\n  const apiVersion = broker.apiSupport ? broker.apiSupport.saslHandshake.usable : undefined;\n  if (typeof apiVersion !== 'number') {\n    callback(new errors.SaslAuthenticationError(null, 'Broker does not support SASL authentication'));\n    return;\n  }\n\n  async.waterfall(\n    [\n      callback => {\n        logger.debug(`Sending SASL/${mechanism} handshake request to ${broker}`);\n\n        const correlationId = this.nextId();\n        const request = protocol.encodeSaslHandshakeRequest(this.clientId, correlationId, apiVersion, mechanism);\n\n        this.queueCallback(broker.socket, correlationId, [protocol.decodeSaslHandshakeResponse, callback]);\n        broker.write(request);\n      },\n      (enabledMechanisms, callback) => {\n        logger.debug(`Sending SASL/${mechanism} authentication request to ${broker.socket.addr}`);\n\n        const auth = this.options.sasl;\n        const correlationId = this.nextId();\n        const request = protocol.encodeSaslAuthenticateRequest(this.clientId, correlationId, apiVersion, auth);\n\n        let decode = protocol.decodeSaslAuthenticateResponse;\n        if (apiVersion === 0) {\n          decode = _.identity;\n          broker.socket.saslAuthCorrelationId = correlationId;\n        }\n        this.queueCallback(broker.socket, correlationId, [decode, callback]);\n        broker.write(request);\n      }\n    ],\n    (error, authBytes) => {\n      if (!error) {\n        broker.authenticated = true;\n      }\n\n      // TODO do stuff with authBytes\n      callback(error);\n    }\n  );\n};\n\nKafkaClient.prototype.createBroker = function (host, port, longpolling) {\n  logger.debug(`${this.clientId} createBroker ${host}:${port}`);\n  var self = this;\n  var socket;\n  if (self.ssl) {\n    socket = tls.connect(port, host, self.sslOptions);\n  } else {\n    socket = net.createConnection(port, host);\n  }\n  socket.addr = host + ':' + port;\n  socket.host = host;\n  socket.port = port;\n  socket.socketId = this.nextSocketId();\n  if (longpolling) socket.longpolling = true;\n\n  socket.on('connect', function () {\n    var lastError = this.error;\n    this.error = null;\n    if (lastError) {\n      this.waiting = false;\n\n      self.initializeBroker(brokerWrapper, function (error) {\n        if (error) {\n          logger.error('error initializing broker after reconnect', error);\n          return;\n        }\n        const readyEventName = brokerWrapper.getReadyEventName();\n        self.emit(readyEventName);\n        self.emit('reconnect');\n      });\n    } else {\n      self.initializeBroker(brokerWrapper, function (error) {\n        if (error) {\n          logger.error('error initializing broker after connect', error);\n          if (error instanceof errors.SaslAuthenticationError) {\n            self.emit('error', error);\n          }\n          return;\n        }\n\n        const readyEventName = brokerWrapper.getReadyEventName();\n        self.emit(readyEventName);\n        self.emit('connect');\n      });\n    }\n  });\n  socket.on('error', function (err) {\n    this.error = err;\n    if (!self.connecting) {\n      self.emit('socket_error', err);\n    }\n  });\n  socket.on('close', function (hadError) {\n    self.emit('close', this);\n    logger.debug(`${self.clientId} socket closed ${this.addr} (hadError: ${hadError})`);\n    if (!hadError && self.closing) {\n      logger.debug(`clearing ${this.addr} callback queue without error`);\n      self.clearCallbackQueue(this);\n    } else {\n      let error = this.error;\n      if (!error) {\n        if (self.options.sasl && socket.saslAuthCorrelationId !== undefined) {\n          delete socket.saslAuthCorrelationId;\n          const message = 'Broker closed connection during SASL auth: bad credentials?';\n          error = new errors.SaslAuthenticationError(null, message);\n        } else {\n          error = new errors.BrokerNotAvailableError('Broker not available (socket closed)');\n          if (!self.connecting && !brokerWrapper.isIdle()) {\n            logger.debug(`${self.clientId} schedule refreshBrokerMetadata()`);\n            setImmediate(function () {\n              self.refreshBrokerMetadata();\n            });\n          }\n        }\n      }\n      self.clearCallbackQueue(this, error);\n    }\n    retry(this);\n  });\n  socket.on('end', function () {\n    retry(this);\n  });\n  socket.buffer = new BufferList();\n  socket.on('data', function (data) {\n    socket.buffer.append(data);\n    self.handleReceivedData(socket);\n  });\n  socket.setKeepAlive(true, 60000);\n\n  const brokerWrapper = new BrokerWrapper(\n    socket,\n    this.noAckBatchOptions,\n    this.options.idleConnection,\n    this.options.sasl\n  );\n\n  function retry (s) {\n    if (s.retrying || s.closing) return;\n    s.retrying = true;\n    s.retryTimer = setTimeout(function () {\n      if (s.closing) return;\n      if (!self.options.reconnectOnIdle && brokerWrapper.isIdle()) {\n        logger.debug(`${self.clientId} to ${socket.addr} is idle not reconnecting`);\n        s.closing = true;\n        self.deleteDisconnected(brokerWrapper);\n        return;\n      }\n\n      if (!self.isValidBroker(s)) {\n        logger.debug(`${self.clientId} is not reconnecting to ${s.addr} invalid broker`);\n        return;\n      }\n\n      logger.debug(`${self.clientId} reconnecting to ${s.addr}`);\n      self.reconnectBroker(s);\n    }, 1000);\n  }\n  return brokerWrapper;\n};\n\nKafkaClient.prototype.isValidBroker = function ({ host, port }) {\n  return (\n    this.connecting ||\n    _(this.brokerMetadata)\n      .values()\n      .some({ host, port })\n  );\n};\n\nKafkaClient.prototype.deleteDisconnected = function (broker) {\n  if (!broker.isConnected()) {\n    const brokers = this.getBrokers(broker.socket.longpolling);\n    const key = broker.socket.addr;\n    assert(brokers[key] === broker);\n    delete brokers[key];\n  }\n};\n\nKafkaClient.prototype.clearCallbackQueue = function (socket, error) {\n  const socketId = socket.socketId;\n  const queue = this.cbqueue.get(socketId);\n  if (!queue) {\n    return;\n  }\n\n  queue.forEach(function (handlers) {\n    const cb = handlers[1];\n    if (error) {\n      cb(error);\n    } else if (cb.timeoutId != null) {\n      clearTimeout(cb.timeoutId);\n    }\n  });\n\n  this.cbqueue.delete(socketId);\n};\n\n/**\n * Fetches metadata for brokers and cluster.\n * This includes an array containing each node (id, host and port).\n * Depending on kafka version, additional cluster information is available (controller id).\n * @param {loadMetadataCallback} cb Function to call once metadata is loaded.\n */\nKafkaClient.prototype.loadMetadata = function (callback) {\n  this.loadMetadataForTopics(null, callback);\n};\n\n/**\n * Fetches metadata for brokers and cluster.\n * This includes an array containing each node (id, host and port). As well as an object\n * containing the topic name, partition, leader number, replica count, and in sync replicas per partition.\n * Depending on kafka version, additional cluster information is available (controller id).\n * @param {Array} topics List of topics to fetch metadata for. An empty array ([]) will fetch all topics.\n * @param {loadMetadataCallback} callback Function to call once metadata is loaded.\n */\nKafkaClient.prototype.loadMetadataForTopics = function (topics, callback) {\n  const broker = this.brokerForLeader();\n\n  if (!broker || !broker.isConnected()) {\n    return callback(new errors.BrokerNotAvailableError('Broker not available (loadMetadataForTopics)'));\n  }\n\n  const ensureBrokerReady = (broker, cb) => {\n    if (!broker.isReady()) {\n      logger.debug('missing apiSupport waiting until broker is ready...(loadMetadataForTopics)');\n      this.waitUntilReady(broker, cb);\n    } else {\n      cb(null);\n    }\n  };\n\n  async.series(\n    [\n      cb => {\n        ensureBrokerReady(broker, cb);\n      },\n      cb => {\n        const broker = this.brokerForLeader();\n        const correlationId = this.nextId();\n        const supportedCoders = getSupportedForRequestType(broker, 'metadata');\n        const request = supportedCoders.encoder(this.clientId, correlationId, topics);\n\n        this.queueCallback(broker.socket, correlationId, [supportedCoders.decoder, cb]);\n        broker.write(request);\n      }\n    ],\n    (err, result) => {\n      callback(err, result[1]);\n    }\n  );\n};\n\n/**\n * Creates one or more topics.\n * @param {Array} topics Array of topics with partition and replication factor to create.\n * @param {createTopicsCallback} callback Function to call once operation is completed.\n */\nKafkaClient.prototype.createTopics = function (topics, callback) {\n  // Calls with [string, string, ...] are forwarded to support previous versions\n  if (topics.every(t => typeof t === 'string')) {\n    return Client.prototype.createTopics.apply(this, arguments);\n  }\n\n  this.sendControllerRequest('createTopics', [topics, this.options.requestTimeout], callback);\n};\n\nKafkaClient.prototype.topicExists = function (topics, callback) {\n  this.loadMetadataForTopics([], (error, response) => {\n    if (error) {\n      return callback(error);\n    }\n    this.updateMetadatas(response);\n    const missingTopics = _.difference(topics, Object.keys(this.topicMetadata));\n    if (missingTopics.length === 0) {\n      return callback(null);\n    }\n    callback(new errors.TopicsNotExistError(missingTopics));\n  });\n};\n\nconst encodeMessageSet = protocol.encodeMessageSet;\nconst Message = protocol.Message;\n\nfunction compress (payloads, callback) {\n  async.each(payloads, buildRequest, callback);\n\n  function buildRequest (payload, cb) {\n    const attributes = payload.attributes;\n    const codec = getCodec(attributes);\n\n    if (!codec) return cb(null);\n\n    const innerSet = encodeMessageSet(payload.messages, 1);\n    codec.encode(innerSet, function (err, message) {\n      if (err) return cb(err);\n      payload.messages = [new Message(0, attributes, payload.key, message)];\n      cb(null);\n    });\n  }\n}\n\nfunction getSupportedForRequestType (broker, requestType) {\n  assert(!_.isEmpty(broker.apiSupport), 'apiSupport is empty');\n  const brokerSupport = broker.apiSupport[requestType];\n\n  if (!brokerSupport) {\n    return null;\n  }\n\n  const usable = brokerSupport.usable;\n\n  const combo = apiMap[requestType][usable];\n  return {\n    encoder: combo[0],\n    decoder: combo[1]\n  };\n}\n\nKafkaClient.prototype.waitUntilReady = function (broker, callback) {\n  logger.debug('waitUntilReady ' + broker);\n  let timeoutId = null;\n\n  const onReady = () => {\n    logger.debug('broker is now ready');\n\n    if (timeoutId !== null) {\n      this._clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    callback(null);\n  };\n\n  const timeout = this.options.requestTimeout;\n  const readyEventName = broker.getReadyEventName();\n\n  if (timeout !== false) {\n    timeoutId = this._createTimeout(() => {\n      this.removeListener(readyEventName, onReady);\n      this._timeouts.delete(timeoutId);\n      callback(new TimeoutError(`Request timed out after ${timeout}ms`));\n    }, timeout);\n  }\n\n  this.once(readyEventName, onReady);\n};\n\nKafkaClient.prototype._clearTimeout = function (timeoutId) {\n  clearTimeout(timeoutId);\n  this._timeouts.delete(timeoutId);\n};\n\nKafkaClient.prototype._clearAllTimeouts = function () {\n  this._timeouts.forEach(function (timeoutId) {\n    clearTimeout(timeoutId);\n  });\n\n  this._timeouts.clear();\n};\n\nKafkaClient.prototype._createTimeout = function (fn, timeout) {\n  const timeoutId = setTimeout(fn, timeout);\n  this._timeouts.add(timeoutId);\n  return timeoutId;\n};\n\nKafkaClient.prototype.sendRequest = function (request, callback) {\n  const payloads = this.payloadsByLeader(request.data.payloads);\n  const longpolling = request.longpolling;\n\n  const sendToBroker = async.ensureAsync((payload, leader, callback) => {\n    const broker = this.brokerForLeader(leader, longpolling);\n    if (!broker || !broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      callback(new errors.BrokerNotAvailableError('Broker not available (sendRequest)'));\n      return;\n    }\n\n    if (!broker.isReady()) {\n      callback(new Error('Broker is not ready'));\n      return;\n    }\n\n    if (longpolling) {\n      if (broker.socket.waiting) {\n        callback(null);\n        return;\n      }\n      broker.socket.waiting = true;\n    }\n\n    const correlationId = this.nextId();\n    const coder = getSupportedForRequestType(broker, request.type);\n\n    const encoder = request.data.args != null ? coder.encoder.apply(null, request.data.args) : coder.encoder;\n    const decoder =\n      request.data.decoderArgs != null ? coder.decoder.apply(null, request.data.decoderArgs) : coder.decoder;\n\n    const requestData = encoder(this.clientId, correlationId, payload);\n\n    if (request.data.requireAcks === 0) {\n      broker.writeAsync(requestData);\n      callback(null, { result: 'no ack' });\n    } else {\n      this.queueCallback(broker.socket, correlationId, [decoder, callback]);\n      broker.write(requestData);\n    }\n  });\n\n  const ensureBrokerReady = async.ensureAsync((leader, callback) => {\n    const broker = this.brokerForLeader(leader, longpolling);\n    if (!broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      callback(new errors.BrokerNotAvailableError('Broker not available (sendRequest -> ensureBrokerReady)'));\n      return;\n    }\n    if (!broker.isReady()) {\n      logger.debug(`missing apiSupport waiting until broker is ready... (sendRequest ${request.type})`);\n      this.waitUntilReady(broker, callback);\n    } else {\n      callback(null);\n    }\n  });\n\n  async.mapValues(\n    payloads,\n    function (payload, leader, callback) {\n      async.series(\n        [\n          function (callback) {\n            ensureBrokerReady(leader, callback);\n          },\n          function (callback) {\n            sendToBroker(payload, leader, callback);\n          }\n        ],\n        function (error, results) {\n          if (error) {\n            return callback(error);\n          }\n          callback(null, _.last(results));\n        }\n      );\n    },\n    callback\n  );\n};\n\n/**\n * Sends a request to a specific broker by id\n */\nKafkaClient.prototype.sendRequestToBroker = function (brokerId, requestType, args, callback) {\n  const brokerMetadata = this.brokerMetadata[brokerId];\n\n  if (!brokerMetadata) {\n    return callback(new Error('No broker with id ' + brokerId));\n  }\n\n  const broker = this.getBroker(brokerMetadata.host, brokerMetadata.port);\n\n  async.waterfall(\n    [\n      callback => {\n        if (broker.isReady()) {\n          return callback(null, broker);\n        }\n\n        this.waitUntilReady(broker, error => {\n          callback(error, broker);\n        });\n      }\n    ],\n    (error, result) => {\n      if (error) {\n        return callback(error);\n      }\n\n      const broker = this.getBroker(brokerMetadata.host, brokerMetadata.port);\n      const correlationId = this.nextId();\n      const coder = getSupportedForRequestType(broker, requestType);\n\n      if (!coder) {\n        return callback(new errors.ApiNotSupportedError());\n      }\n\n      args.unshift(this.clientId, correlationId);\n      const encoder = coder.encoder;\n      const decoder = coder.decoder;\n      const request = encoder.apply(null, args);\n\n      this.sendWhenReady(broker, correlationId, request, decoder, callback);\n    }\n  );\n};\n\nKafkaClient.prototype.leaderLessPayloads = function (payloads) {\n  return _.filter(payloads, payload => !this.hasMetadata(payload.topic, payload.partition));\n};\n\nKafkaClient.prototype.verifyPayloadsHasLeaders = function (payloads, callback) {\n  const leaderLessPayloads = this.leaderLessPayloads(payloads);\n\n  if (leaderLessPayloads.length === 0) {\n    return callback(null);\n  }\n  logger.debug('payloads has no leaders! Our metadata could be out of date try refreshingMetadata', leaderLessPayloads);\n  this.refreshMetadata(_.map(leaderLessPayloads, 'topic'), error => {\n    if (error) {\n      return callback(error);\n    }\n    const payloadWithMissingLeaders = this.leaderLessPayloads(payloads);\n    if (payloadWithMissingLeaders.length) {\n      logger.error('leaders are still missing for %j', payloadWithMissingLeaders);\n      callback(new errors.BrokerNotAvailableError('Could not find the leader'));\n    } else {\n      callback(null);\n    }\n  });\n};\n\nKafkaClient.prototype.wrapControllerCheckIfNeeded = function (requestType, requestArgs, callback) {\n  if (callback.isControllerWrapper) {\n    return callback;\n  }\n\n  var hasBeenInvoked = false;\n\n  const wrappedCallback = (error, result) => {\n    if (error instanceof NotControllerError) {\n      this.setControllerId(null);\n\n      if (!hasBeenInvoked) {\n        hasBeenInvoked = true;\n        this.sendControllerRequest(requestType, requestArgs, wrappedCallback);\n        return;\n      }\n    }\n\n    callback(error, result);\n  };\n\n  wrappedCallback.isControllerWrapper = true;\n\n  return wrappedCallback;\n};\n\nKafkaClient.prototype.sendControllerRequest = function (requestType, args, callback) {\n  this.getController((error, controller, controllerId) => {\n    if (error) {\n      return callback(error);\n    }\n\n    const originalArgs = _.clone(args);\n    const originalCallback = callback;\n    callback = this.wrapControllerCheckIfNeeded(requestType, originalArgs, originalCallback);\n\n    this.sendRequestToBroker(controllerId, requestType, args, callback);\n  });\n};\n\nKafkaClient.prototype.sendFetchRequest = function (\n  consumer,\n  payloads,\n  fetchMaxWaitMs,\n  fetchMinBytes,\n  maxTickMessages,\n  callback\n) {\n  const memberId = consumer.memberId;\n  const generationId = consumer.generationId;\n\n  if (memberId == null && generationId == null) {\n    Client.prototype.sendFetchRequest.apply(this, arguments);\n    return;\n  }\n\n  payloads = _.cloneDeep(payloads);\n  function stateValidator (unused, type, message) {\n    const payloadMap = consumer.payloadMap;\n    if (\n      consumer.closing ||\n      consumer.connecting ||\n      consumer.rebalancing ||\n      consumer.memberId !== memberId ||\n      consumer.generationId !== generationId\n    ) {\n      logger.error(\n        'ignoring message due to it being from an old group - memberId: ' + memberId,\n        '!=' + consumer.memberId + ' - generationId: ' + generationId + '!=' + consumer.generationId\n      );\n      return false;\n    }\n    if (type === 'message') {\n      const { topic, partition, offset } = message;\n      if (!payloadMap[topic] || payloadMap[topic][partition] == null) {\n        logger.error('received unexpected message', message, payloadMap);\n        // We should have never received this in the first place\n        return false;\n      }\n\n      if (offset == null || offset < payloadMap[topic][partition]) {\n        // Kafka may send an older message than we expect (compressed messages, and other unknown reasons)\n        return false;\n      }\n    }\n\n    return true;\n  }\n  if (callback == null) {\n    callback = _.noop;\n  }\n\n  async.series(\n    [\n      callback => {\n        this.verifyPayloadsHasLeaders(payloads, callback);\n      },\n      callback => {\n        const request = {\n          type: 'fetch',\n          longpolling: true,\n          data: {\n            payloads: payloads,\n            args: [fetchMaxWaitMs, fetchMinBytes],\n            decoderArgs: [this._createMessageHandler(consumer, stateValidator), maxTickMessages]\n          }\n        };\n\n        this.sendRequest(request, callback);\n      }\n    ],\n    callback\n  );\n};\n\nKafkaClient.prototype.sendWhenReady = function (broker, correlationId, request, decode, cb) {\n  const doSend = () => {\n    this.queueCallback(broker.socket, correlationId, [decode, cb]);\n    broker.write(request);\n  };\n  if (!broker.isReady()) {\n    this.waitUntilReady(broker, doSend);\n  } else {\n    doSend();\n  }\n};\n\nKafkaClient.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, callback) {\n  async.series(\n    [\n      function (callback) {\n        logger.debug('compressing messages if needed');\n        compress(payloads, callback);\n      },\n      callback => {\n        this.verifyPayloadsHasLeaders(payloads, callback);\n      },\n      callback => {\n        const request = {\n          type: 'produce',\n          data: {\n            payloads: payloads,\n            args: [requireAcks, ackTimeoutMs],\n            requireAcks: requireAcks\n          }\n        };\n        this.sendRequest(request, callback);\n      }\n    ],\n    (err, result) => {\n      if (err) {\n        if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n          this.emit('brokersChanged');\n        }\n        callback(err);\n      } else {\n        callback(\n          null,\n          _.chain(result)\n            .last()\n            .reduce((accu, value) => _.merge(accu, value), {})\n            .value()\n        );\n      }\n    }\n  );\n};\n\nKafkaClient.prototype.handleReceivedData = function (socket) {\n  if (socket.saslAuthCorrelationId !== undefined) {\n    if (socket.buffer.length < 4) {\n      // not enough data yet\n      return;\n    }\n\n    const size = socket.buffer.readInt32BE(0);\n    if (socket.buffer.length - 4 < size) {\n      // still not enough data\n      return;\n    }\n\n    const resp = socket.buffer.slice(4, 4 + size);\n    this.invokeResponseCallback(socket, socket.saslAuthCorrelationId, resp);\n    delete socket.saslAuthCorrelationId;\n    socket.buffer.consume(size + 4);\n  } else {\n    return Client.prototype.handleReceivedData.call(this, socket);\n  }\n};\n\nKafkaClient.prototype.describeConfigs = function (payload, callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (describeConfigs)'));\n  }\n  let err;\n\n  // Broker resource requests must go to the specific node\n  // other requests can go to any node\n  const brokerResourceRequests = [];\n  const nonBrokerResourceRequests = [];\n\n  _.forEach(payload.resources, function (resource) {\n    if (resourceTypeMap[resource.resourceType] === undefined) {\n      err = new Error(`Unexpected resource type ${resource.resourceType} for resource ${resource.resourceName}`);\n      return false;\n    } else {\n      resource.resourceType = resourceTypeMap[resource.resourceType];\n    }\n\n    if (resource.resourceType === resourceTypeMap['broker']) {\n      brokerResourceRequests.push(resource);\n    } else {\n      nonBrokerResourceRequests.push(resource);\n    }\n  });\n\n  if (err) {\n    return callback(err);\n  }\n\n  async.parallelLimit([\n    (cb) => {\n      if (nonBrokerResourceRequests.length > 0) {\n        this.sendRequestToAnyBroker('describeConfigs', [{ resources: nonBrokerResourceRequests, includeSynonyms: payload.includeSynonyms }], cb);\n      } else {\n        cb(null, []);\n      }\n    },\n    ...brokerResourceRequests.map(r => {\n      return (cb) => {\n        this.sendRequestToBroker(r.resourceName, 'describeConfigs', [{ resources: [r], includeSynonyms: payload.includeSynonyms }], cb);\n      };\n    })\n  ], this.options.maxAsyncRequests, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, _.flatten(result));\n  });\n};\n\n/**\n * Sends a request to any broker in the cluster\n */\nKafkaClient.prototype.sendRequestToAnyBroker = function (requestType, args, callback) {\n  // For now just select the first broker\n  const brokerId = Object.keys(this.brokerMetadata)[0];\n  this.sendRequestToBroker(brokerId, requestType, args, callback);\n};\n\nmodule.exports = KafkaClient;\n"]},"metadata":{},"sourceType":"script"}